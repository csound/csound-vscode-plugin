{
    "opcodes": [
        {
            "category": "Orchestra Syntax:Header",
            "opcodes": [
                {
                    "description": "Sets the value of 0 decibels using full scale amplitude.",
                    "synopsis": "0dbfs = iarg",
                    "opcodeName": "0dbfs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the base frequency for pitch A4.",
                    "synopsis": "**A4** = iarg",
                    "opcodeName": "A4",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the control rate.",
                    "synopsis": "**kr** = iarg",
                    "opcodeName": "kr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the number of samples in a control period.",
                    "synopsis": "**ksmps** = iarg",
                    "opcodeName": "ksmps",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the number of channels of audio output.",
                    "synopsis": "**nchnls** = iarg",
                    "opcodeName": "nchnls",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the number of channels of audio input.",
                    "synopsis": "**nchnls_i** = iarg",
                    "opcodeName": "nchnls_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the audio sampling rate.",
                    "synopsis": "**sr** = iarg",
                    "opcodeName": "sr",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Orchestra Syntax:Block Statements",
            "opcodes": [
                {
                    "description": "Ends the current instrument block.",
                    "synopsis": "**endin**",
                    "opcodeName": "endin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of an user-defined opcode block.",
                    "synopsis": "**endop**",
                    "opcodeName": "endop",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Starts an instrument block.",
                    "synopsis": "**instr** i, j, ...",
                    "opcodeName": "instr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Defines the start of user-defined opcode block.",
                    "synopsis": "**opcode** name, outtypes, intypes",
                    "opcodeName": "opcode",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Orchestra Syntax:Macros",
            "opcodes": [
                {
                    "description": "Defines a macro.",
                    "synopsis": "#define NAME # replacement text #, #define NAME(a b c) # replacement text #",
                    "opcodeName": "#define",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Calls a defined macro.",
                    "synopsis": "$NAME",
                    "opcodeName": "$NAME",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Conditional reading of code.",
                    "synopsis": "#ifdef NAME  .... #else  .... #end",
                    "opcodeName": "#ifdef",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Conditional reading of code.",
                    "synopsis": "**ifndef** NAME\n....\n**else** \n....\n**end** ",
                    "opcodeName": "ifndef",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Includes an external file for processing.",
                    "synopsis": "#include \"filename\"",
                    "opcodeName": "#include",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Un-defines a macro.",
                    "synopsis": "#undef NAME",
                    "opcodeName": "#undef",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Generators:Additive Synthesis/Resynthesis",
            "opcodes": [
                {
                    "description": "Output is an additive set of individually controlled sinusoids, using an oscillator bank.",
                    "synopsis": "ares **adsyn** kamod, kfmod, ksmod, ifilcod",
                    "opcodeName": "adsyn",
                    "functionalSynopsis": "ares = **adsyn:a**(kamod, kfmod, ksmod, ifilcod)"
                },
                {
                    "description": "Performs additive synthesis with an arbitrary number of partials, not necessarily harmonic.",
                    "synopsis": "ares **adsynt** kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]",
                    "opcodeName": "adsynt",
                    "functionalSynopsis": "ares = **adsynt:a**(kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs])"
                },
                {
                    "description": "Performs additive synthesis with an arbitrary number of partials -not necessarily harmonic- with interpolation.",
                    "synopsis": "ar **adsynt2** kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]",
                    "opcodeName": "adsynt2",
                    "functionalSynopsis": "ar = **adsynt2:a**(kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs])"
                },
                {
                    "description": "An oscillator which takes tonality and brightness as arguments.",
                    "synopsis": "ares **hsboscil** kamp, ktone, kbrite, ibasfreq, iwfn, ioctfn \\\n               [, ioctcnt] [, iphs]",
                    "opcodeName": "hsboscil",
                    "functionalSynopsis": "ares = **hsboscil:a**(kamp, ktone, kbrite, ibasfreq, iwfn, ioctfn \\)"
                }
            ]
        },
        {
            "category": "Signal Generators:Basic Oscillators",
            "opcodes": [
                {
                    "description": "A low frequency oscillator of various shapes.",
                    "synopsis": "kres **lfo** kamp, kcps [, itype]\nares **lfo** kamp, kcps [, itype]",
                    "opcodeName": "lfo",
                    "functionalSynopsis": "kres = **lfo:k**(kamp, kcps [, itype])\nares = **lfo:a**(kamp, kcps [, itype])"
                },
                {
                    "description": "Mixes the output of any number of oscillators.",
                    "synopsis": "ares **oscbnk**  kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, \\\n      kl2minf, kl2maxf, ilfomode, keqminf, keqmaxf, keqminl, keqmaxl, \\\n      keqminq, keqmaxq, ieqmode, kfn [, il1fn] [, il2fn] [, ieqffn]   \\\n      [, ieqlfn] [, ieqqfn] [, itabl] [, ioutfn]",
                    "opcodeName": "oscbnk",
                    "functionalSynopsis": "ares = **oscbnk:a**( kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, \\)"
                },
                {
                    "description": "A simple oscillator.",
                    "synopsis": "ares **oscil** xamp, xcps [, ifn, iphs]\nkres **oscil** kamp, kcps [, ifn, iphs]",
                    "opcodeName": "oscil",
                    "functionalSynopsis": "ares = **oscil:a**(xamp, xcps [, ifn, iphs])\nkres = **oscil:k**(kamp, kcps [, ifn, iphs])"
                },
                {
                    "description": "A simple oscillator with cubic interpolation.",
                    "synopsis": "ares **oscil3** xamp, xcps [, ifn, iphs]\nkres **oscil3** kamp, kcps [, ifn, iphs]",
                    "opcodeName": "oscil3",
                    "functionalSynopsis": "ares = **oscil3:a**(xamp, xcps [, ifn, iphs])\nkres = **oscil3:k**(kamp, kcps [, ifn, iphs])"
                },
                {
                    "description": "A simple oscillator with linear interpolation.",
                    "synopsis": "ares **oscili** xamp, xcps[, ifn, iphs]\nkres **oscili** kamp, kcps[, ifn, iphs]",
                    "opcodeName": "oscili",
                    "functionalSynopsis": "ares = **oscili:a**(xamp, xcps[, ifn, iphs])\nkres = **oscili:k**(kamp, kcps[, ifn, iphs])"
                },
                {
                    "description": "A linearly interpolated oscillator that allows changing the table number at k-rate.",
                    "synopsis": "ares **oscilikt** xamp, xcps, kfn [, iphs] [, istor]\nkres **oscilikt** kamp, kcps, kfn [, iphs] [, istor]",
                    "opcodeName": "oscilikt",
                    "functionalSynopsis": "ares = **oscilikt:a**(xamp, xcps, kfn [, iphs] [, istor])\nkres = **oscilikt:k**(kamp, kcps, kfn [, iphs] [, istor])"
                },
                {
                    "description": "A linearly interpolated oscillator that allows allows phase modulation.",
                    "synopsis": "ares **osciliktp** kcps, kfn, kphs [, istor]",
                    "opcodeName": "osciliktp",
                    "functionalSynopsis": "ares = **osciliktp:a**(kcps, kfn, kphs [, istor])"
                },
                {
                    "description": "A linearly interpolated oscillator with sync status that allows changing the table number at k-rate.",
                    "synopsis": "ares **oscilikts** xamp, xcps, kfn, async, kphs [, istor]",
                    "opcodeName": "oscilikts",
                    "functionalSynopsis": "ares = **oscilikts:a**(xamp, xcps, kfn, async, kphs [, istor])"
                },
                {
                    "description": "Accesses table values at a user-defined frequency.",
                    "synopsis": "ares **osciln** kamp, ifrq, ifn, itimes",
                    "opcodeName": "osciln",
                    "functionalSynopsis": "ares = **osciln:a**(kamp, ifrq, ifn, itimes)"
                },
                {
                    "description": "A simple, fast sine oscillator",
                    "synopsis": "ares **oscils** iamp, icps, iphs [, iflg]",
                    "opcodeName": "oscils",
                    "functionalSynopsis": "ares = **oscils:a**(iamp, icps, iphs [, iflg])"
                },
                {
                    "description": "Same as the osciln opcode.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "High precision oscillator.",
                    "synopsis": "ares **poscil** aamp, acps [, ifn, iphs]\nares **poscil** aamp, kcps [, ifn, iphs]\nares **poscil** kamp, acps [, ifn, iphs]\nares **poscil** kamp, kcps [, ifn, iphs]\nires **poscil** kamp, kcps [, ifn, iphs]\nkres **poscil** kamp, kcps [, ifn, iphs]",
                    "opcodeName": "poscil",
                    "functionalSynopsis": "ares = **poscil:a**(aamp, acps [, ifn, iphs])\nares = **poscil:a**(aamp, kcps [, ifn, iphs])\nares = **poscil:a**(kamp, acps [, ifn, iphs])\nares = **poscil:a**(kamp, kcps [, ifn, iphs])\nires = **poscil:unknown**(kamp, kcps [, ifn, iphs])\nkres = **poscil:k**(kamp, kcps [, ifn, iphs])"
                },
                {
                    "description": "High precision oscillator with cubic interpolation.",
                    "synopsis": "ares **poscil3** aamp, acps [, ifn, iphs]\nares **poscil3** aamp, kcps [, ifn, iphs]\nares **poscil3** kamp, acps [, ifn, iphs]\nares **poscil3** kamp, kcps [, ifn, iphs]\nires **poscil3** kamp, kcps [, ifn, iphs]\nkres **poscil3** kamp, kcps [, ifn, iphs]",
                    "opcodeName": "poscil3",
                    "functionalSynopsis": "ares = **poscil3:a**(aamp, acps [, ifn, iphs])\nares = **poscil3:a**(aamp, kcps [, ifn, iphs])\nares = **poscil3:a**(kamp, acps [, ifn, iphs])\nares = **poscil3:a**(kamp, kcps [, ifn, iphs])\nires = **poscil3:unknown**(kamp, kcps [, ifn, iphs])\nkres = **poscil3:k**(kamp, kcps [, ifn, iphs])"
                },
                {
                    "description": "Easier-to-use user-controllable vibrato.",
                    "synopsis": "kout **vibr** kAverageAmp, kAverageFreq, ifn",
                    "opcodeName": "vibr",
                    "functionalSynopsis": "kout = **vibr:k**(kAverageAmp, kAverageFreq, ifn)"
                },
                {
                    "description": "Generates a natural-sounding user-controllable vibrato.",
                    "synopsis": "kout **vibrato** kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq, kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs",
                    "opcodeName": "vibrato",
                    "functionalSynopsis": "kout = **vibrato:k**(kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq, kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs)"
                }
            ]
        },
        {
            "category": "Signal Generators:Dynamic Spectrum Oscillators",
            "opcodes": [
                {
                    "description": "Output is a set of harmonically related sine partials.",
                    "synopsis": "ares **buzz** xamp, xcps, knh, ifn [, iphs]",
                    "opcodeName": "buzz",
                    "functionalSynopsis": "ares = **buzz:a**(xamp, xcps, knh, ifn [, iphs])"
                },
                {
                    "description": "Output is a set of harmonically related cosine partials.",
                    "synopsis": "ares **gbuzz** xamp, xcps, knh, klh, kmul, ifn [, iphs]",
                    "opcodeName": "gbuzz",
                    "functionalSynopsis": "ares = **gbuzz:a**(xamp, xcps, knh, klh, kmul, ifn [, iphs])"
                },
                {
                    "description": "Generates a set of impulses.",
                    "synopsis": "ares **mpulse** kamp, kintvl [, ioffset]",
                    "opcodeName": "mpulse",
                    "functionalSynopsis": "ares = **mpulse:a**(kamp, kintvl [, ioffset])"
                },
                {
                    "description": "A mostly bandlimited shape-shifting square-pulse-saw-sinewave oscillator with hardsync.",
                    "synopsis": "aout [, asyncout] **squinewave** acps, aClip, aSkew, asyncin [, iMinSweep] [, iphase]\naout [, asyncout] **squinewave** acps, aClip, aSkew [, ksyncin] [, iMinSweep] [, iphase]",
                    "opcodeName": "squinewave",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Implementation of a band limited, analog modeled oscillator.",
                    "synopsis": "ares **vco** xamp, xcps, iwave, kpw [, ifn] [, imaxd] [, ileak] [, inyx] \\\n      [, iphs] [, iskip]",
                    "opcodeName": "vco",
                    "functionalSynopsis": "ares = **vco:a**(xamp, xcps, iwave, kpw [, ifn] [, imaxd] [, ileak] [, inyx] \\)"
                },
                {
                    "description": "Implementation of a band-limited oscillator using pre-calculated tables.",
                    "synopsis": "ares **vco2** kamp, kcps [, imode] [, kpw] [, kphs] [, inyx]",
                    "opcodeName": "vco2",
                    "functionalSynopsis": "ares = **vco2:a**(kamp, kcps [, imode] [, kpw] [, kphs] [, inyx])"
                },
                {
                    "description": "Returns a table number at k-time for a given oscillator frequency and wavform.",
                    "synopsis": "kfn **vco2ft** kcps, iwave [, inyx]",
                    "opcodeName": "vco2ft",
                    "functionalSynopsis": "kfn = **vco2ft:k**(kcps, iwave [, inyx])"
                },
                {
                    "description": "Returns a table number at i-time for a given oscillator frequency and wavform.",
                    "synopsis": "ifn **vco2ift** icps, iwave [, inyx]",
                    "opcodeName": "vco2ift",
                    "functionalSynopsis": "ifn = **vco2ift:unknown**(icps, iwave [, inyx])"
                },
                {
                    "description": "Calculates tables for use by vco2 opcode.",
                    "synopsis": "ifn **vco2init** iwave [, ibasfn] [, ipmul] [, iminsiz] [, imaxsiz] [, isrcft]",
                    "opcodeName": "vco2init",
                    "functionalSynopsis": "ifn = **vco2init:unknown**(iwave [, ibasfn] [, ipmul] [, iminsiz] [, imaxsiz] [, isrcft])"
                }
            ]
        },
        {
            "category": "Signal Generators:FM Synthesis",
            "opcodes": [
                {
                    "description": "Two mutually frequency and/or phase modulated oscillators.",
                    "synopsis": "a1, a2 **crossfm** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 **crossfmi** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 **crosspm** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 **crosspmi** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 **crossfmpm** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 **crossfmpmi** xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]",
                    "opcodeName": "crossfm",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Uses FM synthesis to create a Hammond B3 organ sound.",
                    "synopsis": "ares **fmb3** kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\\n      ifn4, ivfn]",
                    "opcodeName": "fmb3",
                    "functionalSynopsis": "ares = **fmb3:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\)"
                },
                {
                    "description": "Uses FM synthesis to create a tublar bell sound.",
                    "synopsis": "ares **fmbell** kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\\n      ifn4, ivfn, isus]",
                    "opcodeName": "fmbell",
                    "functionalSynopsis": "ares = **fmbell:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\)"
                },
                {
                    "description": "Uses FM synthesis to create a",
                    "synopsis": "ares **fmmetal** kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\\n      ifn4, ivfn",
                    "opcodeName": "fmmetal",
                    "functionalSynopsis": "ares = **fmmetal:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\)"
                },
                {
                    "description": "Uses FM synthesis to create a percussive flute sound.",
                    "synopsis": "ares **fmpercfl** kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, \\\n      ifn3, ifn4, ivfn]",
                    "opcodeName": "fmpercfl",
                    "functionalSynopsis": "ares = **fmpercfl:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, \\)"
                },
                {
                    "description": "Uses FM synthesis to create a Fender Rhodes electric piano sound.",
                    "synopsis": "ares **fmrhode** kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, \\\n      ifn3, ifn4, ivfn",
                    "opcodeName": "fmrhode",
                    "functionalSynopsis": "ares = **fmrhode:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, \\)"
                },
                {
                    "description": "FM Singing Voice Synthesis",
                    "synopsis": "ares **fmvoice** kamp, kfreq, kvowel, ktilt, kvibamt, kvibrate[, ifn1, \\\n      ifn2, ifn3, ifn4, ivibfn]",
                    "opcodeName": "fmvoice",
                    "functionalSynopsis": "ares = **fmvoice:a**(kamp, kfreq, kvowel, ktilt, kvibamt, kvibrate[, ifn1, \\)"
                },
                {
                    "description": "Uses FM synthesis to create a Wurlitzer electric piano sound.",
                    "synopsis": "ares **fmwurlie** kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\\n      ifn4, ivfn",
                    "opcodeName": "fmwurlie",
                    "functionalSynopsis": "ares = **fmwurlie:a**(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\)"
                },
                {
                    "description": "A basic frequency modulated oscillator.",
                    "synopsis": "ares **foscil** xamp, kcps, xcar, xmod, kndx [, ifn , iphs]",
                    "opcodeName": "foscil",
                    "functionalSynopsis": "ares = **foscil:a**(xamp, kcps, xcar, xmod, kndx [, ifn , iphs])"
                },
                {
                    "description": "Basic frequency modulated oscillator with linear interpolation.",
                    "synopsis": "ares **foscili** xamp, kcps, xcar, xmod,\n    kndx [, ifn, iphs]",
                    "opcodeName": "foscili",
                    "functionalSynopsis": "ares = **foscili:a**(xamp, kcps, xcar, xmod,)"
                }
            ]
        },
        {
            "category": "Signal Generators:Granular Synthesis",
            "opcodes": [
                {
                    "description": "Synchronous granular synthesis, using a soundfile as source.",
                    "synopsis": "asig **diskgrain** Sfname, kamp, kfreq, kpitch, kgrsize, kprate, \\\n      ifun, iolaps [,imaxgrsize , ioffset]",
                    "opcodeName": "diskgrain",
                    "functionalSynopsis": "asig = **diskgrain:a**(Sfname, kamp, kfreq, kpitch, kgrsize, kprate, \\)"
                },
                {
                    "description": "Produces sinusoid bursts useful for formant and granular synthesis.",
                    "synopsis": "ares **fof** xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\\n      ifna, ifnb, itotdur [, iphs] [, ifmode] [, iskip]",
                    "opcodeName": "fof",
                    "functionalSynopsis": "ares = **fof:a**(xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\)"
                },
                {
                    "description": "Produces sinusoid bursts including k-rate incremental indexing with each successive burst.",
                    "synopsis": "ares **fof2** xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\\n      ifna, ifnb, itotdur, kphs, kgliss [, iskip]",
                    "opcodeName": "fof2",
                    "functionalSynopsis": "ares = **fof2:a**(xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\)"
                },
                {
                    "description": "Audio output is a succession of grains derived from data in a stored function table",
                    "synopsis": "ares **fog** xamp, xdens, xtrans, aspd, koct, kband, kris, kdur, kdec, \\\n      iolaps, ifna, ifnb, itotdur [, iphs] [, itmode] [, iskip]",
                    "opcodeName": "fog",
                    "functionalSynopsis": "ares = **fog:a**(xamp, xdens, xtrans, aspd, koct, kband, kris, kdur, kdec, \\)"
                },
                {
                    "description": "Generates granular synthesis textures.",
                    "synopsis": "ares **grain** xamp, xpitch, xdens, kampoff, kpitchoff, kgdur, igfn, \\\n      iwfn, imgdur [, igrnd]",
                    "opcodeName": "grain",
                    "functionalSynopsis": "ares = **grain:a**(xamp, xpitch, xdens, kampoff, kpitchoff, kgdur, igfn, \\)"
                },
                {
                    "description": "Easy-to-use granular synthesis texture generator.",
                    "synopsis": "ares **grain2** kcps, kfmd, kgdur, iovrlp, kfn, iwfn [, irpow] \\\n      [, iseed] [, imode]",
                    "opcodeName": "grain2",
                    "functionalSynopsis": "ares = **grain2:a**(kcps, kfmd, kgdur, iovrlp, kfn, iwfn [, irpow] \\)"
                },
                {
                    "description": "Generate granular synthesis textures with more user control.",
                    "synopsis": "ares **grain3** kcps, kphs, kfmd, kpmd, kgdur, kdens, imaxovr, kfn, iwfn, \\\n      kfrpow, kprpow [, iseed] [, imode]",
                    "opcodeName": "grain3",
                    "functionalSynopsis": "ares = **grain3:a**(kcps, kphs, kfmd, kpmd, kgdur, kdens, imaxovr, kfn, iwfn, \\)"
                },
                {
                    "description": "A more complex granular synthesis texture generator.",
                    "synopsis": "ares **granule** xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec \\\n      [, iseed] [, ipitch1] [, ipitch2] [, ipitch3] [, ipitch4] [, ifnenv]",
                    "opcodeName": "granule",
                    "functionalSynopsis": "ares = **granule:a**(xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec \\)"
                },
                {
                    "description": "Granular synthesizer with &quot;per grain&quot; control\n      over many of its parameters.  Has a sync input to\n      sychronize its internal grain scheduler clock to an external\n      clock source.",
                    "synopsis": "a1 [, a2, a3, a4, a5, a6, a7, a8] **partikkel** agrainfreq, \\\n              kdistribution, idisttab, async, kenv2amt, ienv2tab, ienv_attack, \\\n              ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, \\\n              kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \\\n              ifmamptab, kfmenv, icosine, ktraincps, knumpartials, kchroma, \\\n              ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, \\\n              kwaveform4, iwaveamptab, asamplepos1, asamplepos2, asamplepos3, \\\n              asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains \\\n              [, iopcode_id, ipanlaws]",
                    "opcodeName": "partikkel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Get mask index for a specific mask parameter of a running",
                    "synopsis": "kindex **partikkelget** kparameterindex, iopcode_id",
                    "opcodeName": "partikkelget",
                    "functionalSynopsis": "kindex = **partikkelget:k**(kparameterindex, iopcode_id)"
                },
                {
                    "description": "Set mask index for a specific mask parameter of a running",
                    "synopsis": "**partikkelset** kparameterindex, kmaskindex, iopcode_id",
                    "opcodeName": "partikkelset",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs",
                    "synopsis": "async [,aphase] **partikkelsync** iopcode_id",
                    "opcodeName": "partikkelsync",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a mono sound sample from a table and applies time-stretching and/or pitch modification.",
                    "synopsis": "ares [, ac] **sndwarp** xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, \\\n      irandw, ioverlap, ifn2, itimemode",
                    "opcodeName": "sndwarp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a stereo sound sample from a table and applies time-stretching and/or pitch modification.",
                    "synopsis": "ar1, ar2 [,ac1] [, ac2] **sndwarpst** xamp, xtimewarp, xresample, ifn1, \\\n      ibeg, iwsize, irandw, ioverlap, ifn2, itimemode",
                    "opcodeName": "sndwarpst",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Synchronous granular synthesis.",
                    "synopsis": "asig **syncgrain** kamp, kfreq, kpitch, kgrsize, kprate, ifun1, \\\n      ifun2, iolaps",
                    "opcodeName": "syncgrain",
                    "functionalSynopsis": "asig = **syncgrain:a**(kamp, kfreq, kpitch, kgrsize, kprate, ifun1, \\)"
                },
                {
                    "description": "Synchronous granular synthesis.",
                    "synopsis": "asig **syncloop** kamp, kfreq, kpitch, kgrsize, kprate, klstart, \\\n      klend, ifun1, ifun2, iolaps[,istart, iskip]",
                    "opcodeName": "syncloop",
                    "functionalSynopsis": "asig = **syncloop:a**(kamp, kfreq, kpitch, kgrsize, kprate, klstart, \\)"
                },
                {
                    "description": "Simple vocal simulation based on glottal pulses with formant characteristics.",
                    "synopsis": "ar **vosim** kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip]",
                    "opcodeName": "vosim",
                    "functionalSynopsis": "ar = **vosim:a**(kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip])"
                }
            ]
        },
        {
            "category": "Signal Generators:Hyper Vectorial Synthesis",
            "opcodes": [
                {
                    "description": "Allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.",
                    "synopsis": "**hvs1** kx, inumParms, inumPointsX, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]",
                    "opcodeName": "hvs1",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.",
                    "synopsis": "**hvs2** kx, ky, inumParms, inumPointsX, inumPointsY, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]",
                    "opcodeName": "hvs2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows three-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.",
                    "synopsis": "**hvs3** kx, ky, kz, inumParms, inumPointsX, inumPointsY, inumPointsZ, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]",
                    "opcodeName": "hvs3",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Generators:Linear and Exponential Generators",
            "opcodes": [
                {
                    "description": "Break point function with linear interpolation",
                    "synopsis": "ky **bpf** kx, kx1, ky1, kx2, ..., kxn, kyn\niy **bpf** ix, ix1, iy1, ix2, ..., ixn, iyn\nkys[] **bpf** kxs[], kx1, ky1, kx2, ..., kxn, kyn\niys[] **bpf** ixs[], ix1, iy1, ix2, ..., ixn, iyn\nky **bpf** kx, kxs[], kys[]\niy **bpf** ix, ixs[], iys[]\nay **bpf** ax, kx1, ky1, kx2, ..., kxn, kyn\nay **bpf** ax, kxs[], kys[]\nky, kw **bpf** kx, kxs[], kys[], kws[]",
                    "opcodeName": "bpf",
                    "functionalSynopsis": "ky = **bpf:k**(kx, kx1, ky1, kx2, ..., kxn, kyn)\niy = **bpf:unknown**(ix, ix1, iy1, ix2, ..., ixn, iyn)\nkys[] = **bpf:k**(kxs[], kx1, ky1, kx2, ..., kxn, kyn)\niys[] = **bpf:unknown**(ixs[], ix1, iy1, ix2, ..., ixn, iyn)\nky = **bpf:k**(kx, kxs[], kys[])\niy = **bpf:unknown**(ix, ixs[], iys[])\nay = **bpf:a**(ax, kx1, ky1, kx2, ..., kxn, kyn)\nay = **bpf:a**(ax, kxs[], kys[])"
                },
                {
                    "description": "Break point function with cosine (easy-in/easy-out) interpolation",
                    "synopsis": "ky **bpfcos** kx, kx1, ky1, kx2, ..., kxn, kyn\nkys[] **bpfcos** kxs[], kx1, ky1, kx2, ..., kxn, kyn\nky **bpfcos** kx, kxs[], kys[]\nky **bpfcos** kx, ixs[], iys[]\nky, kz **bpfcos** kx, kxs[], kys[], kzs[] \nky, kz **bpfcos** kx, ixs[], iys[], izs[] \nkys[] **bpfcos** kxs[], kx1, ky1, kx2, ..., kxn, kyn\nky **bpfcos** kx, ixs[], iys[]\nky, kz **bpfcos** kx, kxs[], kys[], kzs[] ",
                    "opcodeName": "bpfcos",
                    "functionalSynopsis": "ky = **bpfcos:k**(kx, kx1, ky1, kx2, ..., kxn, kyn)\nkys[] = **bpfcos:k**(kxs[], kx1, ky1, kx2, ..., kxn, kyn)\nky = **bpfcos:k**(kx, kxs[], kys[])\nky = **bpfcos:k**(kx, ixs[], iys[])\nkys[] = **bpfcos:k**(kxs[], kx1, ky1, kx2, ..., kxn, kyn)\nky = **bpfcos:k**(kx, ixs[], iys[])"
                },
                {
                    "description": "Trace a series of line segments between specified points with\n      cosine interpolation.",
                    "synopsis": "ares **cosseg** ia, idur1, ib [, idur2] [, ic] [...]\nkres **cosseg** ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "cosseg",
                    "functionalSynopsis": "ares = **cosseg:a**(ia, idur1, ib [, idur2] [, ic] [...])\nkres = **cosseg:k**(ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of line segments between specified absolute points with\n      cosine interpolation.",
                    "synopsis": "ares **cossegb** ia, itim1, ib [, itim2] [, ic] [...]\nkres **cossegb** ia, itim1, ib [, itim2] [, ic] [...]",
                    "opcodeName": "cossegb",
                    "functionalSynopsis": "ares = **cossegb:a**(ia, itim1, ib [, itim2] [, ic] [...])\nkres = **cossegb:k**(ia, itim1, ib [, itim2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of line segments between specified points with\n      cosine interpolation, including a release segment.",
                    "synopsis": "ares **cossegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres **cossegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz",
                    "opcodeName": "cossegr",
                    "functionalSynopsis": "ares = **cossegr:a**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)\nkres = **cossegr:k**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)"
                },
                {
                    "description": "This opcode implements a formula for generating a normalised exponential curve in range 0 - 1. It is based on the Max / MSP work of Eric Singer (c) 1994.",
                    "synopsis": "kout **expcurve** kindex, ksteepness",
                    "opcodeName": "expcurve",
                    "functionalSynopsis": "kout = **expcurve:k**(kindex, ksteepness)"
                },
                {
                    "description": "Trace an exponential curve between specified points.",
                    "synopsis": "ares **expon** ia, idur, ib\nkres **expon** ia, idur, ib",
                    "opcodeName": "expon",
                    "functionalSynopsis": "ares = **expon:a**(ia, idur, ib)\nkres = **expon:k**(ia, idur, ib)"
                },
                {
                    "description": "Trace a series of exponential segments between specified points.",
                    "synopsis": "ares **expseg** ia, idur1, ib [, idur2] [, ic] [...]\nkres **expseg** ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "expseg",
                    "functionalSynopsis": "ares = **expseg:a**(ia, idur1, ib [, idur2] [, ic] [...])\nkres = **expseg:k**(ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "An exponential segment generator operating at a-rate.",
                    "synopsis": "ares **expsega** ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "expsega",
                    "functionalSynopsis": "ares = **expsega:a**(ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of exponential segments between specified\n      absolute points.",
                    "synopsis": "ares **expsegb** ia, itim1, ib [, itim2] [, ic] [...]\nkres **expsegb** ia, itim1, ib [, itim2] [, ic] [...]",
                    "opcodeName": "expsegb",
                    "functionalSynopsis": "ares = **expsegb:a**(ia, itim1, ib [, itim2] [, ic] [...])\nkres = **expsegb:k**(ia, itim1, ib [, itim2] [, ic] [...])"
                },
                {
                    "description": "An exponential segment generator operating at a-rate with\n      absolute times.",
                    "synopsis": "ares **expsegba** ia, itim1, ib [, itim2] [, ic] [...]",
                    "opcodeName": "expsegba",
                    "functionalSynopsis": "ares = **expsegba:a**(ia, itim1, ib [, itim2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of exponential segments between specified points including a release segment.",
                    "synopsis": "ares **expsegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres **expsegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz",
                    "opcodeName": "expsegr",
                    "functionalSynopsis": "ares = **expsegr:a**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)\nkres = **expsegr:k**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)"
                },
                {
                    "description": "An implementation of a logarithmic gain curve which is similar to the gainslider~ object from Cycling 74 Max / MSP.",
                    "synopsis": "kout **gainslider** kindex",
                    "opcodeName": "gainslider",
                    "functionalSynopsis": "kout = **gainslider:k**(kindex)"
                },
                {
                    "description": "Linear to cosine interpolation",
                    "synopsis": "ky **lincos** kx, ky0, ky1 [, kx0, kx1 ]\niy **lincos** ix, iy0, iy1 [, ix0, ix1 ]",
                    "opcodeName": "lincos",
                    "functionalSynopsis": "ky = **lincos:k**(kx, ky0, ky1 [, kx0, kx1 ])\niy = **lincos:unknown**(ix, iy0, iy1 [, ix0, ix1 ])"
                },
                {
                    "description": "Trace a straight line between specified points.",
                    "synopsis": "ares **line** ia, idur, ib\nkres **line** ia, idur, ib",
                    "opcodeName": "line",
                    "functionalSynopsis": "ares = **line:a**(ia, idur, ib)\nkres = **line:k**(ia, idur, ib)"
                },
                {
                    "description": "Linear to linear interpolation",
                    "synopsis": "ky **linlin** kx, ky0, ky1 [, kx0, kx1 ]\niy **linlin** ix, iy0, iy1 [, ix0, ix1 ]\nkys[] **linlin** kxs[], ky0, ky1 [, kx0, kx1 ]\niys[] **linlin** ixs[], ky0, ky1, [ kx0, kx1 ]\nkC[] **linlin** kx, kA[], kB[] [, kx0, kx1 ]",
                    "opcodeName": "linlin",
                    "functionalSynopsis": "ky = **linlin:k**(kx, ky0, ky1 [, kx0, kx1 ])\niy = **linlin:unknown**(ix, iy0, iy1 [, ix0, ix1 ])\nkys[] = **linlin:k**(kxs[], ky0, ky1 [, kx0, kx1 ])\niys[] = **linlin:unknown**(ixs[], ky0, ky1, [ kx0, kx1 ])\nkC[] = **linlin:k**(kx, kA[], kB[] [, kx0, kx1 ])"
                },
                {
                    "description": "Trace a series of line segments between specified points.",
                    "synopsis": "ares **linseg** ia, idur1, ib [, idur2] [, ic] [...]\nkres **linseg** ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "linseg",
                    "functionalSynopsis": "ares = **linseg:a**(ia, idur1, ib [, idur2] [, ic] [...])\nkres = **linseg:k**(ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of line segments between specified absolute points.",
                    "synopsis": "ares **linsegb** ia, itim1, ib [, itim2] [, ic] [...]\nkres **linsegb** ia, itim1, ib [, itim2] [, ic] [...]",
                    "opcodeName": "linsegb",
                    "functionalSynopsis": "ares = **linsegb:a**(ia, itim1, ib [, itim2] [, ic] [...])\nkres = **linsegb:k**(ia, itim1, ib [, itim2] [, ic] [...])"
                },
                {
                    "description": "Trace a series of line segments between specified points including a release segment.",
                    "synopsis": "ares **linsegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres **linsegr** ia, idur1, ib [, idur2] [, ic] [...], irel, iz",
                    "opcodeName": "linsegr",
                    "functionalSynopsis": "ares = **linsegr:a**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)\nkres = **linsegr:k**(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)"
                },
                {
                    "description": "This opcode implements a formula for generating a normalised logarithmic curve in range 0 - 1. It is based on the Max / MSP work of Eric Singer (c) 1994.",
                    "synopsis": "kout **logcurve** kindex, ksteepness",
                    "opcodeName": "logcurve",
                    "functionalSynopsis": "kout = **logcurve:k**(kindex, ksteepness)"
                },
                {
                    "description": "Generate control signal consisting of linear segments delimited by two or more specified points.",
                    "synopsis": "ksig **loopseg** kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] \\\n[, kvalue2] [, ktime2][...]",
                    "opcodeName": "loopseg",
                    "functionalSynopsis": "ksig = **loopseg:k**(kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] \\)"
                },
                {
                    "description": "Control signals based on linear segments.",
                    "synopsis": "ksig **loopsegp**  kphase, kvalue0, kdur0, kvalue1 \\\n      [, kdur1, ... , kdurN-1, kvalueN]",
                    "opcodeName": "loopsegp",
                    "functionalSynopsis": "ksig = **loopsegp:k**( kphase, kvalue0, kdur0, kvalue1 \\)"
                },
                {
                    "description": "Generate control signal consisting of exponential or linear segments delimited by two or more specified points.",
                    "synopsis": "ksig **looptseg** kfreq, ktrig, iphase, kvalue0, ktype0, ktime0, [, kvalue1] [,ktype1] [, ktime1] \\\n      [, kvalue2] [,ktype2] [, ktime2] [...] [, kvalueN] [,ktypeN] [, ktimeN]",
                    "opcodeName": "looptseg",
                    "functionalSynopsis": "ksig = **looptseg:k**(kfreq, ktrig, iphase, kvalue0, ktype0, ktime0, [, kvalue1] [,ktype1] [, ktime1] \\)"
                },
                {
                    "description": "Generate control signal consisting of exponential segments delimited by two or more specified points.",
                    "synopsis": "ksig **loopxseg** kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\\n      [, kvalue2] [, ktime2] [...]",
                    "opcodeName": "loopxseg",
                    "functionalSynopsis": "ksig = **loopxseg:k**(kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\)"
                },
                {
                    "description": "Generate control signal consisting of held segments.",
                    "synopsis": "ksig **lpshold** kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...]",
                    "opcodeName": "lpshold",
                    "functionalSynopsis": "ksig = **lpshold:k**(kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...])"
                },
                {
                    "description": "Control signals based on held segments.",
                    "synopsis": "ksig **lpsholdp**  kphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\\n      [, kvalue2] [, ktime2] [...]",
                    "opcodeName": "lpsholdp",
                    "functionalSynopsis": "ksig = **lpsholdp:k**( kphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\)"
                },
                {
                    "description": "Arbitrary signal scaling.",
                    "synopsis": "kscl **scale** kinput, kmax, kmin[, kimax, kimin]",
                    "opcodeName": "scale",
                    "functionalSynopsis": "kscl = **scale:k**(kinput, kmax, kmin[, kimax, kimin])"
                },
                {
                    "description": "Arbitrary signal scaling with optional smoothing.",
                    "synopsis": "kscl **scale2** kinput, kmin, kmax[, kimin, kimax][ihtime]",
                    "opcodeName": "scale2",
                    "functionalSynopsis": "kscl = **scale2:k**(kinput, kmin, kmax[, kimin, kimax][ihtime])"
                },
                {
                    "description": "Constructs a user-definable envelope.",
                    "synopsis": "ares **transeg** ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\nkres **transeg** ia, idur, itype, ib [, idur2] [, itype] [, ic] ...",
                    "opcodeName": "transeg",
                    "functionalSynopsis": "ares = **transeg:a**(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)\nkres = **transeg:k**(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)"
                },
                {
                    "description": "Constructs a user-definable envelope in absolute time.",
                    "synopsis": "ares **transegb** ia, itim, itype, ib [, itim2] [, itype] [, ic] ...\nkres **transegb** ia, itim, itype, ib [, itim2] [, itype] [, ic] ...",
                    "opcodeName": "transegb",
                    "functionalSynopsis": "ares = **transegb:a**(ia, itim, itype, ib [, itim2] [, itype] [, ic] ...)\nkres = **transegb:k**(ia, itim, itype, ib [, itim2] [, itype] [, ic] ...)"
                },
                {
                    "description": "Constructs a user-definable envelope with extended release segment.",
                    "synopsis": "ares **transegr** ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\nkres **transegr** ia, idur, itype, ib [, idur2] [, itype] [, ic] ...",
                    "opcodeName": "transegr",
                    "functionalSynopsis": "ares = **transegr:a**(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)\nkres = **transegr:k**(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)"
                },
                {
                    "description": "Triggers a series of exponential segments between specified points.",
                    "synopsis": "ares **trigexpseg** kTrig, ia, idur1, ib [, idur2] [, ic] [...]\nkres **trigexpseg** kTrig, ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "trigexpseg",
                    "functionalSynopsis": "ares = **trigexpseg:a**(kTrig, ia, idur1, ib [, idur2] [, ic] [...])\nkres = **trigexpseg:k**(kTrig, ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "Triggers a series of line segments between specified points.",
                    "synopsis": "ares **triglinseg** kTrig, ia, idur1, ib [, idur2] [, ic] [...]\nkres **triglinseg** kTrig, ia, idur1, ib [, idur2] [, ic] [...]",
                    "opcodeName": "triglinseg",
                    "functionalSynopsis": "ares = **triglinseg:a**(kTrig, ia, idur1, ib [, idur2] [, ic] [...])\nkres = **triglinseg:k**(kTrig, ia, idur1, ib [, idur2] [, ic] [...])"
                },
                {
                    "description": "2D linear interpolation",
                    "synopsis": "kout **xyscale** kx, ky, k00, k10, k01, k11",
                    "opcodeName": "xyscale",
                    "functionalSynopsis": "kout = **xyscale:k**(kx, ky, k00, k10, k01, k11)"
                }
            ]
        },
        {
            "category": "Signal Generators:Envelope Generators",
            "opcodes": [
                {
                    "description": "Calculates the classical ADSR envelope using linear segments.",
                    "synopsis": "ares **adsr** iatt, idec, islev, irel [, idel]\nkres **adsr** iatt, idec, islev, irel [, idel]",
                    "opcodeName": "adsr",
                    "functionalSynopsis": "ares = **adsr:a**(iatt, idec, islev, irel [, idel])\nkres = **adsr:k**(iatt, idec, islev, irel [, idel])"
                },
                {
                    "description": "Applies an envelope consisting of 3 segments.",
                    "synopsis": "ares **envlpx** xamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]\nkres **envlpx** kamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]",
                    "opcodeName": "envlpx",
                    "functionalSynopsis": "ares = **envlpx:a**(xamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod])\nkres = **envlpx:k**(kamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod])"
                },
                {
                    "description": "The",
                    "synopsis": "ares **envlpxr** xamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]\nkres **envlpxr** kamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]",
                    "opcodeName": "envlpxr",
                    "functionalSynopsis": "ares = **envlpxr:a**(xamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind])\nkres = **envlpxr:k**(kamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind])"
                },
                {
                    "description": "A gated linear attack-decay-sustain with exponential release.",
                    "synopsis": "ares **gtadsr** asig, katt, kdec, ksus,\n    krel, kgate\nxres **gtadsr** kamp, katt, kdec, ksus,\n    krel, kgate",
                    "opcodeName": "gtadsr",
                    "functionalSynopsis": "ares = **gtadsr:a**(asig, katt, kdec, ksus,)\nxres = **gtadsr:unknown**(kamp, katt, kdec, ksus,)"
                },
                {
                    "description": "Applies a straight line rise and decay pattern to an input amp signal.",
                    "synopsis": "ares **linen** xamp, irise, idur, idec\nkres **linen** kamp, irise, idur, idec",
                    "opcodeName": "linen",
                    "functionalSynopsis": "ares = **linen:a**(xamp, irise, idur, idec)\nkres = **linen:k**(kamp, irise, idur, idec)"
                },
                {
                    "description": "The",
                    "synopsis": "ares **linenr** xamp, irise, idec, iatdec\nkres **linenr** kamp, irise, idec, iatdec",
                    "opcodeName": "linenr",
                    "functionalSynopsis": "ares = **linenr:a**(xamp, irise, idec, iatdec)\nkres = **linenr:k**(kamp, irise, idec, iatdec)"
                },
                {
                    "description": "Calculates the classical ADSR envelope using the",
                    "synopsis": "ares **madsr** iatt, idec, islev, irel [, idel] [, ireltim]\nkres **madsr** iatt, idec, islev, irel [, idel] [, ireltim]",
                    "opcodeName": "madsr",
                    "functionalSynopsis": "ares = **madsr:a**(iatt, idec, islev, irel [, idel] [, ireltim])\nkres = **madsr:k**(iatt, idec, islev, irel [, idel] [, ireltim])"
                },
                {
                    "description": "Calculates the classical ADSR envelope using the",
                    "synopsis": "ares **mxadsr** iatt, idec, islev, irel [, idel] [, ireltim]\nkres **mxadsr** iatt, idec, islev, irel [, idel] [, ireltim]",
                    "opcodeName": "mxadsr",
                    "functionalSynopsis": "ares = **mxadsr:a**(iatt, idec, islev, irel [, idel] [, ireltim])\nkres = **mxadsr:k**(iatt, idec, islev, irel [, idel] [, ireltim])"
                },
                {
                    "description": "Calculates the classical ADSR envelope.",
                    "synopsis": "ares **xadsr** iatt, idec, islev, irel [, idel]\nkres **xadsr** iatt, idec, islev, irel [, idel]",
                    "opcodeName": "xadsr",
                    "functionalSynopsis": "ares = **xadsr:a**(iatt, idec, islev, irel [, idel])\nkres = **xadsr:k**(iatt, idec, islev, irel [, idel])"
                }
            ]
        },
        {
            "category": "Signal Generators:Models and Emulations",
            "opcodes": [
                {
                    "description": "Semi-physical model of a bamboo sound.",
                    "synopsis": "ares **bamboo** kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n      [, ifreq1] [, ifreq2]",
                    "opcodeName": "bamboo",
                    "functionalSynopsis": "ares = **bamboo:a**(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\)"
                },
                {
                    "description": "Creates a tone similar to a struck metal bar.",
                    "synopsis": "ares **barmodel** kbcL, kbcR, iK, ib, kscan, iT30, ipos, ivel, iwid",
                    "opcodeName": "barmodel",
                    "functionalSynopsis": "ares = **barmodel:a**(kbcL, kbcR, iK, ib, kscan, iT30, ipos, ivel, iwid)"
                },
                {
                    "description": "Semi-physical model of a cabasa sound.",
                    "synopsis": "ares **cabasa** iamp, idettack [, inum] [, idamp] [, imaxshake]",
                    "opcodeName": "cabasa",
                    "functionalSynopsis": "ares = **cabasa:a**(iamp, idettack [, inum] [, idamp] [, imaxshake])"
                },
                {
                    "description": "Simulates Chua's oscillator, an LRC oscillator with an active resistor, proved capable of bifurcation and chaotic attractors, with k-rate control of circuit elements.",
                    "synopsis": "aI3, aV2, aV1 **chuap** kL, kR0, kC2, kG, kGa, kGb, kE, kC1, iI3, iV2, iV1, ktime_step",
                    "opcodeName": "chuap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Semi-physical model of a crunch sound.",
                    "synopsis": "ares **crunch** iamp, idettack [, inum] [, idamp] [, imaxshake]",
                    "opcodeName": "crunch",
                    "functionalSynopsis": "ares = **crunch:a**(iamp, idettack [, inum] [, idamp] [, imaxshake])"
                },
                {
                    "description": "Semi-physical model of a water drop.",
                    "synopsis": "ares **dripwater** kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n      [, ifreq1] [, ifreq2]",
                    "opcodeName": "dripwater",
                    "functionalSynopsis": "ares = **dripwater:a**(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\)"
                },
                {
                    "description": "Dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis.",
                    "synopsis": "ares **gendy** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n           kampscl, kdurscl [, initcps] [, knum]\nkres **gendy** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n           kampscl, kdurscl [, initcps] [, knum]",
                    "opcodeName": "gendy",
                    "functionalSynopsis": "ares = **gendy:a**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)\nkres = **gendy:k**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)"
                },
                {
                    "description": "Dynamic stochastic approach to waveform synthesis using cubic interpolation.",
                    "synopsis": "ares **gendyc** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl [, initcps] [, knum]\nkres **gendyc** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl [, initcps] [, knum]",
                    "opcodeName": "gendyc",
                    "functionalSynopsis": "ares = **gendyc:a**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)\nkres = **gendyc:k**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)"
                },
                {
                    "description": "Variation of the dynamic stochastic approach to waveform\n      synthesis conceived by Iannis Xenakis.",
                    "synopsis": "ares **gendyx** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]\nkres **gendyx** kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]",
                    "opcodeName": "gendyx",
                    "functionalSynopsis": "ares = **gendyx:a**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)\nkres = **gendyx:k**(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\)"
                },
                {
                    "description": "Audio output is a tone related to the striking of a cow bell or similar.",
                    "synopsis": "ares **gogobel** kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivfn",
                    "opcodeName": "gogobel",
                    "functionalSynopsis": "ares = **gogobel:a**(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivfn)"
                },
                {
                    "description": "Semi-physical model of a guiro sound.",
                    "synopsis": "ares **guiro** kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1]",
                    "opcodeName": "guiro",
                    "functionalSynopsis": "ares = **guiro:a**(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1])"
                },
                {
                    "description": "Implements the Lorenz system of equations.",
                    "synopsis": "ax, ay, az **lorenz** ksv, krv, kbv, kh, ix, iy, iz, iskip [, iskipinit]",
                    "opcodeName": "lorenz",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Mandelbrot set",
                    "synopsis": "kiter, koutrig **mandel**  ktrig, kx, ky, kmaxIter",
                    "opcodeName": "mandel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "An emulation of a mandolin.",
                    "synopsis": "ares **mandol** kamp, kfreq, kpluck, kdetune, kgain, ksize \\\n    [, ifn] [, iminfreq]",
                    "opcodeName": "mandol",
                    "functionalSynopsis": "ares = **mandol:a**(kamp, kfreq, kpluck, kdetune, kgain, ksize \\)"
                },
                {
                    "description": "Physical model related to the striking of a wooden block.",
                    "synopsis": "ares **marimba** kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec \\\n      [, idoubles] [, itriples]",
                    "opcodeName": "marimba",
                    "functionalSynopsis": "ares = **marimba:a**(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec \\)"
                },
                {
                    "description": "An emulation of a mini-Moog synthesizer.",
                    "synopsis": "ares **moog** kamp, kfreq, kfiltq, kfiltrate, kvibf, kvamp, iafn, iwfn, ivfn",
                    "opcodeName": "moog",
                    "functionalSynopsis": "ares = **moog:a**(kamp, kfreq, kfiltq, kfiltrate, kvibf, kvamp, iafn, iwfn, ivfn)"
                },
                {
                    "description": "Simulates a planet orbiting in a binary star system.",
                    "synopsis": "ax, ay, az **planet** kmass1, kmass2, ksep, ix, iy, iz, ivx, ivy, ivz, idelta \\\n      [, ifriction] [, iskip]",
                    "opcodeName": "planet",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a tone similar to a piano string prepared in a Cageian fashion.",
                    "synopsis": "ares **prepiano** ifreq, iNS, iD, iK, \\\n    iT30,iB, kbcl, kbcr, imass, ihvfreq, iinit, ipos, ivel, isfreq, \\\n    isspread[, irattles, irubbers]\nal,ar **prepiano** ifreq, iNS, iD, iK, \\\n    iT30,iB, kbcl, kbcr, imass, ihvfreq, iinit, ipos, ivel, isfreq, \\\n    isspread[, irattles, irubbers]",
                    "opcodeName": "prepiano",
                    "functionalSynopsis": "ares = **prepiano:a**(ifreq, iNS, iD, iK, \\)\nal,ar = **prepiano:a**(ifreq, iNS, iD, iK, \\)"
                },
                {
                    "description": "Semi-physical model of a sandpaper sound.",
                    "synopsis": "ares **sandpaper** iamp, idettack [, inum] [, idamp] [, imaxshake]",
                    "opcodeName": "sandpaper",
                    "functionalSynopsis": "ares = **sandpaper:a**(iamp, idettack [, inum] [, idamp] [, imaxshake])"
                },
                {
                    "description": "Semi-physical model of a sekere sound.",
                    "synopsis": "ares **sekere** iamp, idettack [, inum] [, idamp] [, imaxshake]",
                    "opcodeName": "sekere",
                    "functionalSynopsis": "ares = **sekere:a**(iamp, idettack [, inum] [, idamp] [, imaxshake])"
                },
                {
                    "description": "Sounds like the shaking of a maraca or similar gourd instrument.",
                    "synopsis": "ares **shaker** kamp, kfreq, kbeans, kdamp, ktimes [, idecay]",
                    "opcodeName": "shaker",
                    "functionalSynopsis": "ares = **shaker:a**(kamp, kfreq, kbeans, kdamp, ktimes [, idecay])"
                },
                {
                    "description": "Semi-physical model of a sleighbell sound.",
                    "synopsis": "ares **sleighbells** kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n      [, ifreq1] [, ifreq2]",
                    "opcodeName": "sleighbells",
                    "functionalSynopsis": "ares = **sleighbells:a**(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\)"
                },
                {
                    "description": "Semi-physical model of a stick sound.",
                    "synopsis": "ares **stix** iamp, idettack [, inum] [, idamp] [, imaxshake]",
                    "opcodeName": "stix",
                    "functionalSynopsis": "ares = **stix:a**(iamp, idettack [, inum] [, idamp] [, imaxshake])"
                },
                {
                    "description": "Semi-physical model of a tambourine sound.",
                    "synopsis": "ares **tambourine** kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n      [, ifreq1] [, ifreq2]",
                    "opcodeName": "tambourine",
                    "functionalSynopsis": "ares = **tambourine:a**(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\)"
                },
                {
                    "description": "Physical model related to the striking of a metal block.",
                    "synopsis": "ares **vibes** kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec",
                    "opcodeName": "vibes",
                    "functionalSynopsis": "ares = **vibes:a**(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec)"
                },
                {
                    "description": "An emulation of a human voice.",
                    "synopsis": "ares **voice** kamp, kfreq, kphoneme, kform, kvibf, kvamp, ifn, ivfn",
                    "opcodeName": "voice",
                    "functionalSynopsis": "ares = **voice:a**(kamp, kfreq, kphoneme, kform, kvibf, kvamp, ifn, ivfn)"
                }
            ]
        },
        {
            "category": "Signal Generators:Phasors",
            "opcodes": [
                {
                    "description": "produces two outputs: a periodic phase signal and a periodic exponential decaying signal.",
                    "synopsis": "aexp,aph **ephasor** kfreq, kR",
                    "opcodeName": "ephasor",
                    "functionalSynopsis": "aexp,aph = **ephasor:a**(kfreq, kR)"
                },
                {
                    "description": "Produce a normalized moving phase value.",
                    "synopsis": "ares **phasor** xcps [, iphs]\nkres **phasor** kcps [, iphs]",
                    "opcodeName": "phasor",
                    "functionalSynopsis": "ares = **phasor:a**(xcps [, iphs])\nkres = **phasor:k**(kcps [, iphs])"
                },
                {
                    "description": "Produce an arbitrary number of normalized moving phase values.",
                    "synopsis": "ares **phasorbnk** xcps, kndx, icnt [, iphs]\nkres **phasorbnk** kcps, kndx, icnt [, iphs]",
                    "opcodeName": "phasorbnk",
                    "functionalSynopsis": "ares = **phasorbnk:a**(xcps, kndx, icnt [, iphs])\nkres = **phasorbnk:k**(kcps, kndx, icnt [, iphs])"
                },
                {
                    "description": "A resettable linear ramp between two levels (renamed as trigphasor)",
                    "synopsis": "aindex **sc_phasor** xtrig, xrate, kstart, kend [, kresetPos] \nkindex **sc_phasor** xtrig, xrate, kstart, kend [, kresetPos] ",
                    "opcodeName": "sc_phasor",
                    "functionalSynopsis": "aindex = **sc_phasor:a**(xtrig, xrate, kstart, kend [, kresetPos] )\nkindex = **sc_phasor:k**(xtrig, xrate, kstart, kend [, kresetPos] )"
                },
                {
                    "description": "Produces a normalized moving phase value with sync input and output.",
                    "synopsis": "aphase, asyncout **syncphasor** xcps, asyncin, [, iphs]",
                    "opcodeName": "syncphasor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A resettable linear ramp between two levels",
                    "synopsis": "aindex **trigphasor** xtrig, xrate, kstart, kend [, kresetPos] \nkindex **trigphasor** xtrig, xrate, kstart, kend [, kresetPos] ",
                    "opcodeName": "trigphasor",
                    "functionalSynopsis": "aindex = **trigphasor:a**(xtrig, xrate, kstart, kend [, kresetPos] )\nkindex = **trigphasor:k**(xtrig, xrate, kstart, kend [, kresetPos] )"
                }
            ]
        },
        {
            "category": "Signal Generators:Random (Noise) Generators",
            "opcodes": [
                {
                    "description": "Beta distribution random number generator (positive values only).",
                    "synopsis": "ares **betarand** krange, kalpha, kbeta\nires **betarand** krange, kalpha, kbeta\nkres **betarand** krange, kalpha, kbeta",
                    "opcodeName": "betarand",
                    "functionalSynopsis": "ares = **betarand:a**(krange, kalpha, kbeta)\nires = **betarand:unknown**(krange, kalpha, kbeta)\nkres = **betarand:k**(krange, kalpha, kbeta)"
                },
                {
                    "description": "Exponential distribution random number generator.",
                    "synopsis": "ares **bexprnd** krange\nires **bexprnd** krange\nkres **bexprnd** krange",
                    "opcodeName": "bexprnd",
                    "functionalSynopsis": "ares = **bexprnd:a**(krange)\nires = **bexprnd:unknown**(krange)\nkres = **bexprnd:k**(krange)"
                },
                {
                    "description": "Cauchy distribution random number generator.",
                    "synopsis": "ares **cauchy** kalpha\nires **cauchy** kalpha\nkres **cauchy** kalpha",
                    "opcodeName": "cauchy",
                    "functionalSynopsis": "ares = **cauchy:a**(kalpha)\nires = **cauchy:unknown**(kalpha)\nkres = **cauchy:k**(kalpha)"
                },
                {
                    "description": "Cauchy distribution random number generator with\n      interpolation.",
                    "synopsis": "ares **cauchyi** klambda, xamp, xcps\nires **cauchyi** klambda, xamp, xcps\nkres **cauchyi** klambda, xamp, xcps",
                    "opcodeName": "cauchyi",
                    "functionalSynopsis": "ares = **cauchyi:a**(klambda, xamp, xcps)\nires = **cauchyi:unknown**(klambda, xamp, xcps)\nkres = **cauchyi:k**(klambda, xamp, xcps)"
                },
                {
                    "description": "Continuous USER-defined-distribution RaNDom generator.",
                    "synopsis": "aout **cuserrnd** kmin, kmax, ktableNum\niout **cuserrnd** imin, imax, itableNum\nkout **cuserrnd** kmin, kmax, ktableNum",
                    "opcodeName": "cuserrnd",
                    "functionalSynopsis": "aout = **cuserrnd:a**(kmin, kmax, ktableNum)\niout = **cuserrnd:unknown**(imin, imax, itableNum)\nkout = **cuserrnd:k**(kmin, kmax, ktableNum)"
                },
                {
                    "description": "Discrete USER-defined-distribution RaNDom generator.",
                    "synopsis": "aout **duserrnd** ktableNum\niout **duserrnd** itableNum\nkout **duserrnd** ktableNum",
                    "opcodeName": "duserrnd",
                    "functionalSynopsis": "aout = **duserrnd:a**(ktableNum)\niout = **duserrnd:unknown**(itableNum)\nkout = **duserrnd:k**(ktableNum)"
                },
                {
                    "description": "Random impulses.",
                    "synopsis": "ares **dust** kamp, kdensity\nkres **dust** kamp, kdensity",
                    "opcodeName": "dust",
                    "functionalSynopsis": "ares = **dust:a**(kamp, kdensity)\nkres = **dust:k**(kamp, kdensity)"
                },
                {
                    "description": "Random impulses.",
                    "synopsis": "ares **dust2** kamp, kdensity\nkres **dust2** kamp, kdensity",
                    "opcodeName": "dust2",
                    "functionalSynopsis": "ares = **dust2:a**(kamp, kdensity)\nkres = **dust2:k**(kamp, kdensity)"
                },
                {
                    "description": "Exponential distribution random number generator (positive values only).",
                    "synopsis": "ares **exprand** klambda\nires **exprand** klambda\nkres **exprand** klambda",
                    "opcodeName": "exprand",
                    "functionalSynopsis": "ares = **exprand:a**(klambda)\nires = **exprand:unknown**(klambda)\nkres = **exprand:k**(klambda)"
                },
                {
                    "description": "Exponential distribution random number generator with\n      interpolation (positive values only).",
                    "synopsis": "ares **exprandi** klambda, xamp, xcps\nires **exprandi** klambda, xamp, xcps\nkres **exprandi** klambda, xamp, xcps",
                    "opcodeName": "exprandi",
                    "functionalSynopsis": "ares = **exprandi:a**(klambda, xamp, xcps)\nires = **exprandi:unknown**(klambda, xamp, xcps)\nkres = **exprandi:k**(klambda, xamp, xcps)"
                },
                {
                    "description": "A fractal noise generator.",
                    "synopsis": "ares **fractalnoise** kamp, kbeta",
                    "opcodeName": "fractalnoise",
                    "functionalSynopsis": "ares = **fractalnoise:a**(kamp, kbeta)"
                },
                {
                    "description": "Gaussian distribution random number generator.",
                    "synopsis": "ares **gauss** krange\nires **gauss** irange\nkres **gauss** krange\nares **gauss** kmean, ksdev\nires **gauss** imean, isdev\nkres **gauss** kmean, ksdev",
                    "opcodeName": "gauss",
                    "functionalSynopsis": "ares = **gauss:a**(krange)\nires = **gauss:unknown**(irange)\nkres = **gauss:k**(krange)\nares = **gauss:a**(kmean, ksdev)\nires = **gauss:unknown**(imean, isdev)\nkres = **gauss:k**(kmean, ksdev)"
                },
                {
                    "description": "Gaussian distribution random number generator with\n      interpolation.",
                    "synopsis": "ares **gaussi** krange, xamp, xcps\nires **gaussi** krange, xamp, xcps\nkres **gaussi** krange, xamp, xcps",
                    "opcodeName": "gaussi",
                    "functionalSynopsis": "ares = **gaussi:a**(krange, xamp, xcps)\nires = **gaussi:unknown**(krange, xamp, xcps)\nkres = **gaussi:k**(krange, xamp, xcps)"
                },
                {
                    "description": "Random impulses around a certain frequency.",
                    "synopsis": "ares **gausstrig** kamp, kcps, kdev [, imode] [, ifrst1]\nkres **gausstrig** kamp, kcps, kdev [, imode] [, ifrst1]",
                    "opcodeName": "gausstrig",
                    "functionalSynopsis": "ares = **gausstrig:a**(kamp, kcps, kdev [, imode] [, ifrst1])\nkres = **gausstrig:k**(kamp, kcps, kdev [, imode] [, ifrst1])"
                },
                {
                    "description": "Reads the global seed value.",
                    "synopsis": "ians** getseed**\nkans** getseed**",
                    "opcodeName": " getseed",
                    "functionalSynopsis": "ians** = **getseed:unknown**()\nkans** = **getseed:k**()"
                },
                {
                    "description": "Generates a segmented line whose segments are randomly generated.",
                    "synopsis": "kout **jitter** kamp, kcpsMin, kcpsMax",
                    "opcodeName": "jitter",
                    "functionalSynopsis": "kout = **jitter:k**(kamp, kcpsMin, kcpsMax)"
                },
                {
                    "description": "Generates a segmented line with user-controllable random segments.",
                    "synopsis": "kout **jitter2** ktotamp, kamp1, kcps1,\n    kamp2, kcps2, kamp3, kcps3[ , iopt]",
                    "opcodeName": "jitter2",
                    "functionalSynopsis": "kout = **jitter2:k**(ktotamp, kamp1, kcps1,)"
                },
                {
                    "description": "A jitter-spline generator.",
                    "synopsis": "ares **jspline** xamp, kcpsMin, kcpsMax\nkres **jspline** kamp, kcpsMin, kcpsMax",
                    "opcodeName": "jspline",
                    "functionalSynopsis": "ares = **jspline:a**(xamp, kcpsMin, kcpsMax)\nkres = **jspline:k**(kamp, kcpsMin, kcpsMax)"
                },
                {
                    "description": "Linear Feedback Shift Register (LFSR).",
                    "synopsis": "knum **lfsr** ilen, iprob [, iseed]",
                    "opcodeName": "lfsr",
                    "functionalSynopsis": "knum = **lfsr:k**(ilen, iprob [, iseed])"
                },
                {
                    "description": "Linear distribution random number generator (positive values only).",
                    "synopsis": "ares **linrand** krange\nires **linrand** krange\nkres **linrand** krange",
                    "opcodeName": "linrand",
                    "functionalSynopsis": "ares = **linrand:a**(krange)\nires = **linrand:unknown**(krange)\nkres = **linrand:k**(krange)"
                },
                {
                    "description": "A white noise generator with an IIR lowpass filter.",
                    "synopsis": "ares **noise** xamp, kbeta",
                    "opcodeName": "noise",
                    "functionalSynopsis": "ares = **noise:a**(xamp, kbeta)"
                },
                {
                    "description": "Cauchy distribution random number generator (positive values only).",
                    "synopsis": "ares **pcauchy** kalpha\nires **pcauchy** kalpha\nkres **pcauchy** kalpha",
                    "opcodeName": "pcauchy",
                    "functionalSynopsis": "ares = **pcauchy:a**(kalpha)\nires = **pcauchy:unknown**(kalpha)\nkres = **pcauchy:k**(kalpha)"
                },
                {
                    "description": "Generates pink noise.",
                    "synopsis": "ares **pinker**",
                    "opcodeName": "pinker",
                    "functionalSynopsis": "ares = **pinker:a**()"
                },
                {
                    "description": "Generates approximate pink noise.",
                    "synopsis": "ares **pinkish** xin [, imethod] [, inumbands] [, iseed] [, iskip]",
                    "opcodeName": "pinkish",
                    "functionalSynopsis": "ares = **pinkish:a**(xin [, imethod] [, inumbands] [, iseed] [, iskip])"
                },
                {
                    "description": "Poisson distribution random number generator (positive values only).",
                    "synopsis": "ares **poisson** klambda\nires **poisson** klambda\nkres **poisson** klambda",
                    "opcodeName": "poisson",
                    "functionalSynopsis": "ares = **poisson:a**(klambda)\nires = **poisson:unknown**(klambda)\nkres = **poisson:k**(klambda)"
                },
                {
                    "description": "Generates a controlled random number series.",
                    "synopsis": "ares **rand** xamp [, iseed] [, isel] [, ioffset]\nkres **rand** xamp [, iseed] [, isel] [, ioffset]",
                    "opcodeName": "rand",
                    "functionalSynopsis": "ares = **rand:a**(xamp [, iseed] [, isel] [, ioffset])\nkres = **rand:k**(xamp [, iseed] [, isel] [, ioffset])"
                },
                {
                    "description": "Generates random numbers and holds them for a period of time.",
                    "synopsis": "ares **randh** xamp, xcps [, iseed] [, isize] [, ioffset]\nkres **randh** kamp, kcps [, iseed] [, isize] [, ioffset]",
                    "opcodeName": "randh",
                    "functionalSynopsis": "ares = **randh:a**(xamp, xcps [, iseed] [, isize] [, ioffset])\nkres = **randh:k**(kamp, kcps [, iseed] [, isize] [, ioffset])"
                },
                {
                    "description": "Generates a controlled random number series with interpolation between each new number.",
                    "synopsis": "ares **randi** xamp, xcps [, iseed] [, isize] [, ioffset]\nkres **randi** kamp, kcps [, iseed] [, isize] [, ioffset]",
                    "opcodeName": "randi",
                    "functionalSynopsis": "ares = **randi:a**(xamp, xcps [, iseed] [, isize] [, ioffset])\nkres = **randi:k**(kamp, kcps [, iseed] [, isize] [, ioffset])"
                },
                {
                    "description": "Generates a controlled pseudo-random number series between min and max values.",
                    "synopsis": "ares **random** kmin, kmax\nires **random** imin, imax\nkres **random** kmin, kmax",
                    "opcodeName": "random",
                    "functionalSynopsis": "ares = **random:a**(kmin, kmax)\nires = **random:unknown**(imin, imax)\nkres = **random:k**(kmin, kmax)"
                },
                {
                    "description": "Generates random numbers with a user-defined limit and holds them for a period of time.",
                    "synopsis": "ares **randomh** kmin, kmax, xcps [,imode] [,ifirstval]\nkres **randomh** kmin, kmax, kcps [,imode] [,ifirstval]",
                    "opcodeName": "randomh",
                    "functionalSynopsis": "ares = **randomh:a**(kmin, kmax, xcps [,imode] [,ifirstval])\nkres = **randomh:k**(kmin, kmax, kcps [,imode] [,ifirstval])"
                },
                {
                    "description": "Generates a user-controlled random number series with interpolation between each new number.",
                    "synopsis": "ares **randomi** kmin, kmax, xcps [,imode] [,ifirstval]\nkres **randomi** kmin, kmax, kcps [,imode] [,ifirstval]",
                    "opcodeName": "randomi",
                    "functionalSynopsis": "ares = **randomi:a**(kmin, kmax, xcps [,imode] [,ifirstval])\nkres = **randomi:k**(kmin, kmax, kcps [,imode] [,ifirstval])"
                },
                {
                    "description": "31-bit bipolar random opcodes with controllable distribution.",
                    "synopsis": "ax **rnd31** kscl, krpow [, iseed]\nix **rnd31** iscl, irpow [, iseed]\nkx **rnd31** kscl, krpow [, iseed]",
                    "opcodeName": "rnd31",
                    "functionalSynopsis": "ax = **rnd31:a**(kscl, krpow [, iseed])\nix = **rnd31:unknown**(iscl, irpow [, iseed])\nkx = **rnd31:k**(kscl, krpow [, iseed])"
                },
                {
                    "description": "Sets the global rndseed value.",
                    "synopsis": "**rndseed** ival",
                    "opcodeName": "rndseed",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generate random spline curves.",
                    "synopsis": "ares **rspline** xrangeMin, xrangeMax, kcpsMin, kcpsMax\nkres **rspline** krangeMin, krangeMax, kcpsMin, kcpsMax",
                    "opcodeName": "rspline",
                    "functionalSynopsis": "ares = **rspline:a**(xrangeMin, xrangeMax, kcpsMin, kcpsMax)\nkres = **rspline:k**(krangeMin, krangeMax, kcpsMin, kcpsMax)"
                },
                {
                    "description": "Sets the global seed value.",
                    "synopsis": "**seed** ival",
                    "opcodeName": "seed",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates a controlled pseudo-random number series between min and max values according to a trigger.",
                    "synopsis": "kout **trandom** ktrig, kmin, kmax",
                    "opcodeName": "trandom",
                    "functionalSynopsis": "kout = **trandom:k**(ktrig, kmin, kmax)"
                },
                {
                    "description": "Triangular distribution random number generator",
                    "synopsis": "ares **trirand** krange\nires **trirand** krange\nkres **trirand** krange",
                    "opcodeName": "trirand",
                    "functionalSynopsis": "ares = **trirand:a**(krange)\nires = **trirand:unknown**(krange)\nkres = **trirand:k**(krange)"
                },
                {
                    "description": "Uniform distribution random number generator (positive values only).",
                    "synopsis": "ares **unirand** krange\nires **unirand** krange\nkres **unirand** krange",
                    "opcodeName": "unirand",
                    "functionalSynopsis": "ares = **unirand:a**(krange)\nires = **unirand:unknown**(krange)\nkres = **unirand:k**(krange)"
                },
                {
                    "description": "truly random opcodes with controllable range.",
                    "synopsis": "ax **urandom** [imin, imax]\nix **urandom** [imin, imax]\nkx **urandom** [imin, imax]",
                    "opcodeName": "urandom",
                    "functionalSynopsis": "ax = **urandom:a**([imin, imax])\nix = **urandom:unknown**([imin, imax])\nkx = **urandom:k**([imin, imax])"
                },
                {
                    "description": "A discrete user-defined-distribution random generator that can be used as a function.",
                    "synopsis": "aout = **urd**(ktableNum)\niout = **urd**(itableNum)\nkout = **urd**(ktableNum)",
                    "opcodeName": "urd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Weibull distribution random number generator (positive values only).",
                    "synopsis": "ares **weibull** ksigma, ktau\nires **weibull** ksigma, ktau\nkres **weibull** ksigma, ktau",
                    "opcodeName": "weibull",
                    "functionalSynopsis": "ares = **weibull:a**(ksigma, ktau)\nires = **weibull:unknown**(ksigma, ktau)\nkres = **weibull:k**(ksigma, ktau)"
                }
            ]
        },
        {
            "category": "Signal Generators:Sample Playback",
            "opcodes": [
                {
                    "description": "Generates breakbeat-style cut-ups of a mono audio stream.",
                    "synopsis": "a1 **bbcutm** asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats \\\n      [, istutterspeed] [, istutterchance] [, ienvchoice ]",
                    "opcodeName": "bbcutm",
                    "functionalSynopsis": "a1 = **bbcutm:a**(asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats \\)"
                },
                {
                    "description": "Generates breakbeat-style cut-ups of a stereo audio stream.",
                    "synopsis": "a1,a2 **bbcuts** asource1, asource2, ibps, isubdiv, ibarlength, iphrasebars, \\\n      inumrepeats [, istutterspeed] [, istutterchance] [, ienvchoice]",
                    "opcodeName": "bbcuts",
                    "functionalSynopsis": "a1,a2 = **bbcuts:a**(asource1, asource2, ibps, isubdiv, ibarlength, iphrasebars, \\)"
                },
                {
                    "description": "Function-table-based crossfading looper.",
                    "synopsis": "asig1[, asig2] **flooper** kamp, kpitch, istart, idur, ifad, ifn",
                    "opcodeName": "flooper",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Function-table-based crossfading looper.",
                    "synopsis": "asig1[,asig2] **flooper2** kamp, kpitch, kloopstart, kloopend, kcrossfade, ifn \\\n      [, istart, imode, ifenv, iskip]",
                    "opcodeName": "flooper2",
                    "functionalSynopsis": "asig1[,asig2] = **flooper2:a**(kamp, kpitch, kloopstart, kloopend, kcrossfade, ifn \\)"
                },
                {
                    "description": "Collects all audio from all Fluidsynth engines in a performance",
                    "synopsis": "aleft, aright **fluidAllOut**",
                    "opcodeName": "fluidAllOut",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a MIDI controller data message to fluid.",
                    "synopsis": "**fluidCCi** iEngineNumber, iChannelNumber, iControllerNumber, iValue",
                    "opcodeName": "fluidCCi",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a MIDI controller data message to fluid.",
                    "synopsis": "**fluidCCk** iEngineNumber, iChannelNumber, iControllerNumber, kValue",
                    "opcodeName": "fluidCCk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI note on, note off, and other messages to a SoundFont preset.",
                    "synopsis": "**fluidControl** ienginenum, kstatus, kchannel, \\\n    kdata1, kdata2 [,imsgs]",
                    "opcodeName": "fluidControl",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Instantiates a fluidsynth engine.",
                    "synopsis": "ienginenum **fluidEngine** [iChorusEnabled] [, iRevervEnabled] [, iNumChannels] [, iPolyphony] ",
                    "opcodeName": "fluidEngine",
                    "functionalSynopsis": "ienginenum = **fluidEngine:unknown**([iChorusEnabled] [, iRevervEnabled] [, iNumChannels] [, iPolyphony] )"
                },
                {
                    "description": "Retrieves program information from currently loaded soundfont.",
                    "synopsis": "SPrograms[] **fluidInfo** ienginenum",
                    "opcodeName": "fluidInfo",
                    "functionalSynopsis": "SPrograms[] = **fluidInfo:unknown**(ienginenum)"
                },
                {
                    "description": "Loads a SoundFont into a fluidEngine, optionally listing SoundFont contents.",
                    "synopsis": "isfnum **fluidLoad** soundfont, ienginenum[, ilistpresets]",
                    "opcodeName": "fluidLoad",
                    "functionalSynopsis": "isfnum = **fluidLoad:unknown**(soundfont, ienginenum[, ilistpresets])"
                },
                {
                    "description": "Plays a note on a channel in a fluidSynth engine.",
                    "synopsis": "**fluidNote** ienginenum, ichannelnum, imidikey, imidivel",
                    "opcodeName": "fluidNote",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs sound from a given fluidEngine",
                    "synopsis": "aleft, aright **fluidOut** ienginenum",
                    "opcodeName": "fluidOut",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Assigns a preset from a SoundFont to a channel on a fluidEngine.",
                    "synopsis": "**fluidProgramSelect** ienginenum, ichannelnum, isfnum, ibanknum, ipresetnum",
                    "opcodeName": "fluidProgramSelect",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Set interpolation method for channel in Fluid Engine",
                    "synopsis": "**fluidSetInterpMethod** ienginenum, ichannelnum, iInterpMethod",
                    "opcodeName": "fluidSetInterpMethod",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read sampled sound from a table.",
                    "synopsis": "ar1 [,ar2] **loscil** xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n    [, imod2] [, ibeg2] [, iend2]\naph, ar1 [,ar2] **loscilphs** xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n      [, imod2] [, ibeg2] [, iend2]",
                    "opcodeName": "loscil",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read sampled sound from a table using cubic interpolation. A version that outputs the exact\n      table position (phase) corresponding to the output sample is\n      provided as an alternative opcode.",
                    "synopsis": "ar1 [,ar2] **loscil3** xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n    [, imod2] [, ibeg2] [, iend2]\naph, ar1 [,ar2] **loscil3phs** xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n      [, imod2] [, ibeg2] [, iend2]",
                    "opcodeName": "loscil3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read multi-channel sampled sound from a table.",
                    "synopsis": "ar1 [, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \\\n      ar15, ar16] **loscilx** xamp, kcps, ifn \\\n    [, iwsize, ibas, istrt, imod, ibeg, iend]\nar[] **loscilx** xamp, kcps, ifn \\\n    [, iwsize, ibas, istrt, imod, ibeg, iend]",
                    "opcodeName": "loscilx",
                    "functionalSynopsis": "ar[] = **loscilx:a**(xamp, kcps, ifn \\)"
                },
                {
                    "description": "Generates a table index for sample playback",
                    "synopsis": "ares **lphasor** xtrns [, ilps] [, ilpe] [, imode] [, istrt] [, istor]",
                    "opcodeName": "lphasor",
                    "functionalSynopsis": "ares = **lphasor:a**(xtrns [, ilps] [, ilpe] [, imode] [, istrt] [, istor])"
                },
                {
                    "description": "Read sampled sound from a table with looping and high precision.",
                    "synopsis": "ares **lposcil** kamp, kfreqratio, kloop, kend, ifn [, iphs]",
                    "opcodeName": "lposcil",
                    "functionalSynopsis": "ares = **lposcil:a**(kamp, kfreqratio, kloop, kend, ifn [, iphs])"
                },
                {
                    "description": "Read sampled sound from a table with high precision and cubic interpolation.",
                    "synopsis": "ares **lposcil3** kamp, kfreqratio, kloop, kend, ifn [, iphs]",
                    "opcodeName": "lposcil3",
                    "functionalSynopsis": "ares = **lposcil3:a**(kamp, kfreqratio, kloop, kend, ifn [, iphs])"
                },
                {
                    "description": "Read sampled sound from a table with looping and high precision.",
                    "synopsis": "ar **lposcila** aamp, kfreqratio, kloop, kend, ift [,iphs] ",
                    "opcodeName": "lposcila",
                    "functionalSynopsis": "ar = **lposcila:a**(aamp, kfreqratio, kloop, kend, ift [,iphs] )"
                },
                {
                    "description": "Read stereo sampled sound from a table with looping and high precision.",
                    "synopsis": "ar1, ar2 **lposcilsa** aamp, kfreqratio, kloop, kend, ift [,iphs] ",
                    "opcodeName": "lposcilsa",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read stereo sampled sound from a table with looping and high precision.",
                    "synopsis": "ar1, ar2 **lposcilsa2** aamp, kfreqratio, kloop, kend, ift [,iphs] ",
                    "opcodeName": "lposcilsa2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints a list of all instruments of a previously loaded SoundFont2 (SF2) file.",
                    "synopsis": "**sfilist** ifilhandle [, Sprintprefix] ",
                    "opcodeName": "sfilist",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound.",
                    "synopsis": "ar1, ar2 **sfinstr** ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n      [, iflag] [, ioffset]",
                    "opcodeName": "sfinstr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound with cubic interpolation.",
                    "synopsis": "ar1, ar2 **sfinstr3** ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n      [, iflag] [, ioffset]",
                    "opcodeName": "sfinstr3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample instrument, generating a mono sound with cubic interpolation.",
                    "synopsis": "ares **sfinstr3m** ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n      [, iflag] [, ioffset]",
                    "opcodeName": "sfinstr3m",
                    "functionalSynopsis": "ares = **sfinstr3m:a**(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\)"
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample instrument, generating a mono sound.",
                    "synopsis": "ares **sfinstrm** ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n      [, iflag] [, ioffset]",
                    "opcodeName": "sfinstrm",
                    "functionalSynopsis": "ares = **sfinstrm:a**(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\)"
                },
                {
                    "description": "Loads an entire SoundFont2 (SF2) sample file into memory.",
                    "synopsis": "ir **sfload** &quot;filename&quot;",
                    "opcodeName": "sfload",
                    "functionalSynopsis": "ir = **sfload:unknown**(&quot;filename&quot;)"
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound, with user-defined\n      time-varying crossfade looping.",
                    "synopsis": "ar1, ar2 **sflooper** ivel, inotenum, kamp, kpitch, ipreindex, kloopstart, kloopend, kcrossfade \\\n      [, istart, imode, ifenv, iskip, iflag] ",
                    "opcodeName": "sflooper",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Assigns all presets of a SoundFont2 (SF2) sample file to a sequence of progressive index numbers.",
                    "synopsis": "**sfpassign** istartindex, ifilhandle[, imsgs]",
                    "opcodeName": "sfpassign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound.",
                    "synopsis": "ar1, ar2 **sfplay** ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]",
                    "opcodeName": "sfplay",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound with cubic interpolation.",
                    "synopsis": "ar1, ar2 **sfplay3** ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]",
                    "opcodeName": "sfplay3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample preset, generating a mono sound with cubic interpolation.",
                    "synopsis": "ares **sfplay3m** ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]",
                    "opcodeName": "sfplay3m",
                    "functionalSynopsis": "ares = **sfplay3m:a**(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])"
                },
                {
                    "description": "Plays a SoundFont2 (SF2) sample preset, generating a mono sound.",
                    "synopsis": "ares **sfplaym** ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]",
                    "opcodeName": "sfplaym",
                    "functionalSynopsis": "ares = **sfplaym:a**(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])"
                },
                {
                    "description": "Prints a list of all presets of a SoundFont2 (SF2) sample file.",
                    "synopsis": "**sfplist** ifilhandle",
                    "opcodeName": "sfplist",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Assigns an existing preset of a SoundFont2 (SF2) sample file to an index number.",
                    "synopsis": "ir **sfpreset** iprog, ibank, ifilhandle, ipreindex",
                    "opcodeName": "sfpreset",
                    "functionalSynopsis": "ir = **sfpreset:unknown**(iprog, ibank, ifilhandle, ipreindex)"
                },
                {
                    "description": "A sound looper with pitch control.",
                    "synopsis": "asig, krec **sndloop** ain, kpitch, ktrig, idur, ifad",
                    "opcodeName": "sndloop",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A simple time stretch by repeating cycles.",
                    "synopsis": "ares **waveset** ain, krep [, ilen]",
                    "opcodeName": "waveset",
                    "functionalSynopsis": "ares = **waveset:a**(ain, krep [, ilen])"
                }
            ]
        },
        {
            "category": "Signal Generators:Scanned Synthesis",
            "opcodes": [
                {
                    "description": "Copies from one table to another with a gain control.",
                    "synopsis": "**scanhammer** isrc, idst, ipos, imult",
                    "opcodeName": "scanhammer",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows the position and velocity of a node in a scanned process to be read.",
                    "synopsis": "kpos, kvel **scanmap** iscan, kamp, kvamp [, iwhich]",
                    "opcodeName": "scanmap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generate audio output using scanned synthesis.",
                    "synopsis": "ares **scans** kamp, kfreq, ifn, id [, iorder]",
                    "opcodeName": "scans",
                    "functionalSynopsis": "ares = **scans:a**(kamp, kfreq, ifn, id [, iorder])"
                },
                {
                    "description": "Allows the position and velocity of a node in a scanned process to be written.",
                    "synopsis": "**scansmap** kpos, kvel, iscan, kamp, kvamp [, iwhich]",
                    "opcodeName": "scansmap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A simpler scanned synthesis implementation.",
                    "synopsis": "aout **scantable** kamp, kpch, ipos, imass, istiff, idamp, ivel",
                    "opcodeName": "scantable",
                    "functionalSynopsis": "aout = **scantable:a**(kamp, kpch, ipos, imass, istiff, idamp, ivel)"
                },
                {
                    "description": "Compute the waveform and the wavetable for use in scanned synthesis.",
                    "synopsis": "**scanu** init, irate, ifndisplace,\n    ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr,\n    kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id",
                    "opcodeName": "scanu",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Compute the waveform and the wavetable for use in scanned synthesis.",
                    "synopsis": "**scanu2** init, irate, ifndisplace,\n    ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr,\n    kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id",
                    "opcodeName": "scanu2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows the position and velocity of a node in a scanned process to be read.",
                    "synopsis": "kpos, kvel **xscanmap** iscan, kamp, kvamp [, iwhich]",
                    "opcodeName": "xscanmap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Fast scanned synthesis waveform and the wavetable generator.",
                    "synopsis": "ares **xscans** kamp, kfreq, ifntraj, id [, iorder]",
                    "opcodeName": "xscans",
                    "functionalSynopsis": "ares = **xscans:a**(kamp, kfreq, ifntraj, id [, iorder])"
                },
                {
                    "description": "Allows the position and velocity of a node in a scanned process to be read.",
                    "synopsis": "**xscansmap** kpos, kvel, iscan, kamp, kvamp [, iwhich]",
                    "opcodeName": "xscansmap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Compute the waveform and the wavetable for use in scanned synthesis.",
                    "synopsis": "**xscanu** init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, \\\n      kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id",
                    "opcodeName": "xscanu",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Generators:STK Opcodes",
            "opcodes": [
                {
                    "description": "STKBandedWG uses banded waveguide techniques to model a variety of sounds.",
                    "synopsis": "asignal **STKBandedWG** ifrequency, iamplitude, [kpress, kv1[, kmot, kv2[, klfo, kv3[, klfodepth, kv4[, kvel, kv5[, kstrk, kv6[, kinstr, kv7]]]]]]]",
                    "opcodeName": "STKBandedWG",
                    "functionalSynopsis": "asignal = **STKBandedWG:a**(ifrequency, iamplitude, [kpress, kv1[, kmot, kv2[, klfo, kv3[, klfodepth, kv4[, kvel, kv5[, kstrk, kv6[, kinstr, kv7]]]]]]])"
                },
                {
                    "description": "STK Hammond-oid organ-like FM synthesis instrument.",
                    "synopsis": "asignal **STKBeeThree** ifrequency, iamplitude, [kop4, kv1[, kop3, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKBeeThree",
                    "functionalSynopsis": "asignal = **STKBeeThree:a**(ifrequency, iamplitude, [kop4, kv1[, kop3, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKBlowBotl uses a helmholtz resonator (biquad filter) with a polynomial jet excitation.",
                    "synopsis": "asignal **STKBlowBotl** ifrequency, iamplitude, [knoise, kv1[, klfo, kv2[, klfodepth, kv3[, kvol, kv4]]]]",
                    "opcodeName": "STKBlowBotl",
                    "functionalSynopsis": "asignal = **STKBlowBotl:a**(ifrequency, iamplitude, [knoise, kv1[, klfo, kv2[, klfodepth, kv3[, kvol, kv4]]]])"
                },
                {
                    "description": "STK clarinet physical model with one register hole and one tonehole.",
                    "synopsis": "asignal **STKBlowHole** ifrequency, iamplitude, [kreed, kv1[, knoise, kv2[, khole, kv3[, kreg, kv4[, kbreath, kv5]]]]]",
                    "opcodeName": "STKBlowHole",
                    "functionalSynopsis": "asignal = **STKBlowHole:a**(ifrequency, iamplitude, [kreed, kv1[, knoise, kv2[, khole, kv3[, kreg, kv4[, kbreath, kv5]]]]])"
                },
                {
                    "description": "STKBowed is a bowed string instrument.",
                    "synopsis": "asignal **STKBowed** ifrequency, iamplitude, [kpress, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]",
                    "opcodeName": "STKBowed",
                    "functionalSynopsis": "asignal = **STKBowed:a**(ifrequency, iamplitude, [kpress, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]])"
                },
                {
                    "description": "STKBrass is a simple brass instrument.",
                    "synopsis": "asignal **STKBrass** ifrequency, iamplitude, [klip, kv1[, kslide, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]",
                    "opcodeName": "STKBrass",
                    "functionalSynopsis": "asignal = **STKBrass:a**(ifrequency, iamplitude, [klip, kv1[, kslide, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]])"
                },
                {
                    "description": "STKClarinet uses a simple clarinet physical model.",
                    "synopsis": "asignal **STKClarinet** ifrequency, iamplitude, [kstiff, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]]",
                    "opcodeName": "STKClarinet",
                    "functionalSynopsis": "asignal = **STKClarinet:a**(ifrequency, iamplitude, [kstiff, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]])"
                },
                {
                    "description": "STKDrummer is a drum sampling synthesizer.",
                    "synopsis": "asignal **STKDrummer** ifrequency, iamplitude",
                    "opcodeName": "STKDrummer",
                    "functionalSynopsis": "asignal = **STKDrummer:a**(ifrequency, iamplitude)"
                },
                {
                    "description": "STKFMVoices is a singing FM synthesis instrument.",
                    "synopsis": "asignal **STKFMVoices** ifrequency, iamplitude, [kvowel, kv1[, kspec, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKFMVoices",
                    "functionalSynopsis": "asignal = **STKFMVoices:a**(ifrequency, iamplitude, [kvowel, kv1[, kspec, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKFlute uses a simple flute physical model.",
                    "synopsis": "asignal **STKFlute** ifrequency, iamplitude, [kjet, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]]",
                    "opcodeName": "STKFlute",
                    "functionalSynopsis": "asignal = **STKFlute:a**(ifrequency, iamplitude, [kjet, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]])"
                },
                {
                    "description": "STKHevyMetl produces metal sounds.",
                    "synopsis": "asignal **STKHevyMetl** ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKHevyMetl",
                    "functionalSynopsis": "asignal = **STKHevyMetl:a**(ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKMandolin produces mamdolin-like sounds.",
                    "synopsis": "asignal **STKMandolin** ifrequency, iamplitude, [kbody, kv1[, kpos, kv2[, ksus, kv3[, kdetune, kv4[, kmic, kv5]]]]]",
                    "opcodeName": "STKMandolin",
                    "functionalSynopsis": "asignal = **STKMandolin:a**(ifrequency, iamplitude, [kbody, kv1[, kpos, kv2[, ksus, kv3[, kdetune, kv4[, kmic, kv5]]]]])"
                },
                {
                    "description": "STKModalBar is a resonant bar instrument.",
                    "synopsis": "asignal **STKModalBar** ifrequency, iamplitude, [khard, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kmix, kv5[, kvol, kv6[, kinstr, kv7]]]]]]]",
                    "opcodeName": "STKModalBar",
                    "functionalSynopsis": "asignal = **STKModalBar:a**(ifrequency, iamplitude, [khard, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kmix, kv5[, kvol, kv6[, kinstr, kv7]]]]]]])"
                },
                {
                    "description": "STKMoog produces moog-like swept filter sounds.",
                    "synopsis": "asignal **STKMoog** ifrequency, iamplitude, [kq, kv1[, krate, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]",
                    "opcodeName": "STKMoog",
                    "functionalSynopsis": "asignal = **STKMoog:a**(ifrequency, iamplitude, [kq, kv1[, krate, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]])"
                },
                {
                    "description": "STKPercFlut is a percussive flute FM synthesis instrument.",
                    "synopsis": "asignal **STKPercFlut** ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKPercFlut",
                    "functionalSynopsis": "asignal = **STKPercFlut:a**(ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKPlucked uses a plucked string physical model.",
                    "synopsis": "asignal **STKPlucked** ifrequency, iamplitude",
                    "opcodeName": "STKPlucked",
                    "functionalSynopsis": "asignal = **STKPlucked:a**(ifrequency, iamplitude)"
                },
                {
                    "description": "STKResonate is a noise driven formant filter.",
                    "synopsis": "asignal **STKResonate** ifrequency, iamplitude, [kfreq, kv1[, kpole, kv2[, knotch, kv3[, kzero, kv4[, kenv, kv5]]]]]",
                    "opcodeName": "STKResonate",
                    "functionalSynopsis": "asignal = **STKResonate:a**(ifrequency, iamplitude, [kfreq, kv1[, kpole, kv2[, knotch, kv3[, kzero, kv4[, kenv, kv5]]]]])"
                },
                {
                    "description": "STK Fender Rhodes-like electric piano FM synthesis instrument.",
                    "synopsis": "asignal **STKRhodey** ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKRhodey",
                    "functionalSynopsis": "asignal = **STKRhodey:a**(ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKSaxofony is a faux conical bore reed instrument.",
                    "synopsis": "asignal **STKSaxofony** ifrequency, iamplitude, [kstiff, kv1[, kapert, kv2[, kblow, kv3[, knoise, kv4[, klfo, kv5[, klfodepth, kv6[, kbreath, kv7]]]]]]]",
                    "opcodeName": "STKSaxofony",
                    "functionalSynopsis": "asignal = **STKSaxofony:a**(ifrequency, iamplitude, [kstiff, kv1[, kapert, kv2[, kblow, kv3[, knoise, kv4[, klfo, kv5[, klfodepth, kv6[, kbreath, kv7]]]]]]])"
                },
                {
                    "description": "STKShakers is an instrument that simulates environmental sounds or collisions of multiple independent sound producing objects.",
                    "synopsis": "asignal **STKShakers** ifrequency, iamplitude, [kenerg, kv1[, kdecay, kv2[, kshake, kv3[, knum, kv4[, kres, kv5[, kinstr, kv6]]]]]]",
                    "opcodeName": "STKShakers",
                    "functionalSynopsis": "asignal = **STKShakers:a**(ifrequency, iamplitude, [kenerg, kv1[, kdecay, kv2[, kshake, kv3[, knum, kv4[, kres, kv5[, kinstr, kv6]]]]]])"
                },
                {
                    "description": "STKSimple is a wavetable/noise instrument.",
                    "synopsis": "asignal **STKSimple** ifrequency, iamplitude, [kpos, kv1[, kcross, kv2[, kenv, kv3[, kgain, kv4]]]]",
                    "opcodeName": "STKSimple",
                    "functionalSynopsis": "asignal = **STKSimple:a**(ifrequency, iamplitude, [kpos, kv1[, kcross, kv2[, kenv, kv3[, kgain, kv4]]]])"
                },
                {
                    "description": "STKSitar uses a plucked string physical model.",
                    "synopsis": "asignal **STKSitar** ifrequency, iamplitude",
                    "opcodeName": "STKSitar",
                    "functionalSynopsis": "asignal = **STKSitar:a**(ifrequency, iamplitude)"
                },
                {
                    "description": "STKStifKarp is a plucked stiff string instrument.",
                    "synopsis": "asignal **STKStifKarp** ifrequency, iamplitude, [kpos, kv1[, ksus, kv2[, kstretch, kv3]]]",
                    "opcodeName": "STKStifKarp",
                    "functionalSynopsis": "asignal = **STKStifKarp:a**(ifrequency, iamplitude, [kpos, kv1[, ksus, kv2[, kstretch, kv3]]])"
                },
                {
                    "description": "STKTubeBell is a  tubular bell (orchestral chime) FM synthesis instrument.",
                    "synopsis": "asignal **STKTubeBell** ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKTubeBell",
                    "functionalSynopsis": "asignal = **STKTubeBell:a**(ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                },
                {
                    "description": "STKVoicForm is a  four formant synthesis instrument.",
                    "synopsis": "asignal **STKVoicForm** ifrequency, iamplitude, [kmix, kv1[, ksel, kv2[, klfo, kv3[, klfodepth, kv4[, kloud, kv5]]]]]",
                    "opcodeName": "STKVoicForm",
                    "functionalSynopsis": "asignal = **STKVoicForm:a**(ifrequency, iamplitude, [kmix, kv1[, ksel, kv2[, klfo, kv3[, klfodepth, kv4[, kloud, kv5]]]]])"
                },
                {
                    "description": "STKWhistle produces whistle sounds.",
                    "synopsis": "asignal **STKWhistle** ifrequency, iamplitude, [kmod, kv1[, knoise, kv2[, kfipfreq, kv3[, kfipgain, kv4[, kvol, kv5]]]]]",
                    "opcodeName": "STKWhistle",
                    "functionalSynopsis": "asignal = **STKWhistle:a**(ifrequency, iamplitude, [kmod, kv1[, knoise, kv2[, kfipfreq, kv3[, kfipgain, kv4[, kvol, kv5]]]]])"
                },
                {
                    "description": "STKWurley simulates a Wurlitzer electric piano FM synthesis instrument.",
                    "synopsis": "asignal **STKWurley** ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]",
                    "opcodeName": "STKWurley",
                    "functionalSynopsis": "asignal = **STKWurley:a**(ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]])"
                }
            ]
        },
        {
            "category": "Signal Generators:Table Access",
            "opcodes": [
                {
                    "description": "Accesses table values by incremental sampling.",
                    "synopsis": "kres **oscil1** idel, kamp, idur [, ifn]",
                    "opcodeName": "oscil1",
                    "functionalSynopsis": "kres = **oscil1:k**(idel, kamp, idur [, ifn])"
                },
                {
                    "description": "Accesses table values by incremental sampling with linear interpolation.",
                    "synopsis": "kres **oscil1i** idel, kamp, idur [, ifn]",
                    "opcodeName": "oscil1i",
                    "functionalSynopsis": "kres = **oscil1i:k**(idel, kamp, idur [, ifn])"
                },
                {
                    "description": "Accesses table values by direct indexing.",
                    "synopsis": "ares **ptable** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **ptable** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **ptable** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "ptable",
                    "functionalSynopsis": "ares = **ptable:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **ptable:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **ptable:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Accesses table values by direct indexing with cubic interpolation.",
                    "synopsis": "ares **ptable3** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **ptable3** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **ptable3** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "ptable3",
                    "functionalSynopsis": "ares = **ptable3:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **ptable3:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **ptable3:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Accesses table values by direct indexing with linear interpolation.",
                    "synopsis": "ares **ptablei** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **ptablei** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **ptablei** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "ptablei",
                    "functionalSynopsis": "ares = **ptablei:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **ptablei:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **ptablei:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Fast table opcode.",
                    "synopsis": "kr **tab** kndx, ifn[, ixmode]\nar **tab** xndx, ifn[, ixmode]",
                    "opcodeName": "tab",
                    "functionalSynopsis": "kr = **tab:k**(kndx, ifn[, ixmode])\nar = **tab:a**(xndx, ifn[, ixmode])"
                },
                {
                    "description": "Fast table opcodes.",
                    "synopsis": "ir **tab_i** indx, ifn[, ixmode]",
                    "opcodeName": "tab_i",
                    "functionalSynopsis": "ir = **tab_i:unknown**(indx, ifn[, ixmode])"
                },
                {
                    "description": "Accesses table values by direct indexing.",
                    "synopsis": "ares **table** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **table** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **table** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "table",
                    "functionalSynopsis": "ares = **table:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **table:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **table:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Accesses table values by direct indexing with cubic interpolation.",
                    "synopsis": "ares **table3** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **table3** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **table3** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "table3",
                    "functionalSynopsis": "ares = **table3:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **table3:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **table3:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Accesses table values by direct indexing with linear interpolation.",
                    "synopsis": "ares **tablei** andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires **tablei** indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres **tablei** kndx, ifn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "tablei",
                    "functionalSynopsis": "ares = **tablei:a**(andx, ifn [, ixmode] [, ixoff] [, iwrap])\nires = **tablei:unknown**(indx, ifn [, ixmode] [, ixoff] [, iwrap])\nkres = **tablei:k**(kndx, ifn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Fast table opcodes.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Fast table opcodes.",
                    "synopsis": "**tabw_i** isig, indx, ifn [,ixmode]",
                    "opcodeName": "tabw_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Generators:Wave Terrain Synthesis",
            "opcodes": [
                {
                    "description": "A wave-terrain synthesis opcode using curves computed with the superformula",
                    "synopsis": "aout **sterrain** kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, km1, km2, kn1, kn2, kn3, ka, kb, kperiod\n    ",
                    "opcodeName": "sterrain",
                    "functionalSynopsis": "aout = **sterrain:a**(kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, km1, km2, kn1, kn2, kn3, ka, kb, kperiod)"
                },
                {
                    "description": "A simple wave-terrain synthesis opcode.",
                    "synopsis": "aout **wterrain** kamp, kpch, k_xcenter, k_ycenter, k_xradius, k_yradius, \\\n      itabx, itaby",
                    "opcodeName": "wterrain",
                    "functionalSynopsis": "aout = **wterrain:a**(kamp, kpch, k_xcenter, k_ycenter, k_xradius, k_yradius, \\)"
                },
                {
                    "description": "A wave-terrain synthesis opcode using different curves",
                    "synopsis": "aout **wterrain2** kamp, kcps, kx, ky, krx, kry, krot, \\\n      ktab0, ktab1, kcurve, kcurveparam\n    ",
                    "opcodeName": "wterrain2",
                    "functionalSynopsis": "aout = **wterrain2:a**(kamp, kcps, kx, ky, krx, kry, krot, \\)"
                }
            ]
        },
        {
            "category": "Signal Generators:Waveguide Physical Modeling",
            "opcodes": [
                {
                    "description": "Produces a naturally decaying plucked string or drum sound.",
                    "synopsis": "ares **pluck** kamp, kcps, icps, ifn, imeth [, iparm1] [, iparm2]",
                    "opcodeName": "pluck",
                    "functionalSynopsis": "ares = **pluck:a**(kamp, kcps, icps, ifn, imeth [, iparm1] [, iparm2])"
                },
                {
                    "description": "Physical model of the plucked string.",
                    "synopsis": "ares **repluck** iplk, kamp, icps, kpick, krefl, axcite",
                    "opcodeName": "repluck",
                    "functionalSynopsis": "ares = **repluck:a**(iplk, kamp, icps, kpick, krefl, axcite)"
                },
                {
                    "description": "A string resonator with variable fundamental frequency.",
                    "synopsis": "ares **streson** asig, kfr, kfdbgain",
                    "opcodeName": "streson",
                    "functionalSynopsis": "ares = **streson:a**(asig, kfr, kfdbgain)"
                },
                {
                    "description": "Creates a tone similar to a bowed string.",
                    "synopsis": "ares **wgbow** kamp, kfreq, kpres, krat, kvibf, kvamp \\\n    [, ifn] [, iminfreq]",
                    "opcodeName": "wgbow",
                    "functionalSynopsis": "ares = **wgbow:a**(kamp, kfreq, kpres, krat, kvibf, kvamp \\)"
                },
                {
                    "description": "A physical model of a bowed bar.",
                    "synopsis": "ares **wgbowedbar** kamp, kfreq, kpos, kbowpres, kgain [, iconst] [, itvel] \\\n      [, ibowpos] [, ilow]",
                    "opcodeName": "wgbowedbar",
                    "functionalSynopsis": "ares = **wgbowedbar:a**(kamp, kfreq, kpos, kbowpres, kgain [, iconst] [, itvel] \\)"
                },
                {
                    "description": "Creates a tone related to a brass instrument.",
                    "synopsis": "ares **wgbrass** kamp, kfreq, ktens, iatt, kvibf, kvamp \\\n    [, ifn] [, iminfreq]",
                    "opcodeName": "wgbrass",
                    "functionalSynopsis": "ares = **wgbrass:a**(kamp, kfreq, ktens, iatt, kvibf, kvamp \\)"
                },
                {
                    "description": "Creates a tone similar to a clarinet.",
                    "synopsis": "ares **wgclar** kamp, kfreq, kstiff, \\\n    iatt, idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq]",
                    "opcodeName": "wgclar",
                    "functionalSynopsis": "ares = **wgclar:a**(kamp, kfreq, kstiff, \\)"
                },
                {
                    "description": "Creates a tone similar to a flute.",
                    "synopsis": "ares **wgflute** kamp, kfreq, kjet, iatt,\n    idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq] [, ijetrf] [, iendrf]",
                    "opcodeName": "wgflute",
                    "functionalSynopsis": "ares = **wgflute:a**(kamp, kfreq, kjet, iatt,)"
                },
                {
                    "description": "A high fidelity simulation of a plucked string.",
                    "synopsis": "ares **wgpluck** icps, iamp, kpick, iplk, idamp, ifilt, axcite",
                    "opcodeName": "wgpluck",
                    "functionalSynopsis": "ares = **wgpluck:a**(icps, iamp, kpick, iplk, idamp, ifilt, axcite)"
                },
                {
                    "description": "Physical model of the plucked string.",
                    "synopsis": "ares **wgpluck2** iplk, kamp, icps, kpick, krefl",
                    "opcodeName": "wgpluck2",
                    "functionalSynopsis": "ares = **wgpluck2:a**(iplk, kamp, icps, kpick, krefl)"
                }
            ]
        },
        {
            "category": "Signal I/O:File I/O",
            "opcodes": [
                {
                    "description": "Periodically writes an orchestra control-signal value to an external file.",
                    "synopsis": "**dumpk**  ksig, ifilname, iformat, iprd",
                    "opcodeName": "dumpk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically writes two orchestra control-signal values to an external file.",
                    "synopsis": "**dumpk2** ksig1, ksig2, ifilname, iformat, iprd",
                    "opcodeName": "dumpk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically writes three orchestra control-signal values to an external file.",
                    "synopsis": "**dumpk3** ksig1, ksig2, ksig3, ifilname, iformat, iprd",
                    "opcodeName": "dumpk3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically writes four orchestra control-signal values to an external file.",
                    "synopsis": "**dumpk4** ksig1, ksig2, ksig3, ksig4, ifilname, iformat, iprd",
                    "opcodeName": "dumpk4",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Closes a previously opened file.",
                    "synopsis": "**ficlose** ihandle\n**ficlose** Sfilename",
                    "opcodeName": "ficlose",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read signals from a file at a-rate.",
                    "synopsis": "**fin** ifilename, iskipframes, iformat, ain1 [, ain2] [, ain3] [,...]\n**fin** ifilename, iskipframes, iformat, arr[]",
                    "opcodeName": "fin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read signals from a file at i-rate.",
                    "synopsis": "**fini** ifilename, iskipframes, iformat, in1 [, in2] [, in3] [, ...]",
                    "opcodeName": "fini",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read signals from a file at k-rate.",
                    "synopsis": "**fink** ifilename, iskipframes, iformat, kin1 [, kin2] [, kin3] [,...]",
                    "opcodeName": "fink",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Opens a file in a specific mode.",
                    "synopsis": "ihandle **fiopen** ifilename, imode",
                    "opcodeName": "fiopen",
                    "functionalSynopsis": "ihandle = **fiopen:unknown**(ifilename, imode)"
                },
                {
                    "description": "Outputs a-rate signals to an arbitrary number of channels.",
                    "synopsis": "**fout** ifilename, iformat, aout1 [, aout2, aout3,...,aoutN]\n**fout** ifilename, iformat, array[]",
                    "opcodeName": "fout",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs i-rate signals of an arbitrary number of channels to a specified file.",
                    "synopsis": "**fouti** ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]",
                    "opcodeName": "fouti",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs i-rate signals from an arbitrary number of channels to a specified file.",
                    "synopsis": "**foutir** ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]",
                    "opcodeName": "foutir",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs k-rate signals of an arbitrary number of channels to a specified file, in raw (headerless) format.",
                    "synopsis": "**foutk** ifilename, iformat, kout1 [, kout2, kout3,....,koutN]",
                    "opcodeName": "foutk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Similar to printks but prints to a file.",
                    "synopsis": "**fprintks** &quot;filename&quot;, &quot;string&quot;, [, kval1] [, kval2] [...]",
                    "opcodeName": "fprintks",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Similar to prints but prints to a file.",
                    "synopsis": "**fprints** &quot;filename&quot;, &quot;string&quot; [, ival1] [, ival2] [...]",
                    "opcodeName": "fprints",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read signals and arrays from an hdf5 file.",
                    "synopsis": "xout1[, xout2, xout3, ..., xoutN] **hdf5read** ifilename, ivariablename1[, ivariablename2, ivariablename3, ..., ivariablenameN]",
                    "opcodeName": "hdf5read",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write signals and arrays to an hdf5 file.",
                    "synopsis": "**hdf5write** ifilename, xout1[, xout2, xout3, ..., xoutN]",
                    "opcodeName": "hdf5write",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read a line of text from an external file.",
                    "synopsis": "Sres, kline **readf** ifilname",
                    "opcodeName": "readf",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read a line of text from an external file.",
                    "synopsis": "Sres, iline **readfi** ifilname",
                    "opcodeName": "readfi",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically reads an orchestra control-signal value from an external file.",
                    "synopsis": "kres **readk** ifilname, iformat, iprd",
                    "opcodeName": "readk",
                    "functionalSynopsis": "kres = **readk:k**(ifilname, iformat, iprd)"
                },
                {
                    "description": "Periodically reads two orchestra control-signal values from an external file.",
                    "synopsis": "kr1, kr2 **readk2** ifilname, iformat, iprd",
                    "opcodeName": "readk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically reads three orchestra control-signal values from an external file.",
                    "synopsis": "kr1, kr2, kr3 **readk3** ifilname, iformat, iprd",
                    "opcodeName": "readk3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Periodically reads four orchestra control-signal values from an external file.",
                    "synopsis": "kr1, kr2, kr3, kr4 **readk4** ifilname, iformat, iprd",
                    "opcodeName": "readk4",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read and write signals and arrays using a websocket connection.",
                    "synopsis": "xout1[, xout2, xout3, ..., xoutN] **websocket** iport, xin",
                    "opcodeName": "websocket",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal I/O:Signal Input",
            "opcodes": [
                {
                    "description": "Reads audio data from an external device or stream and can alter its pitch.",
                    "synopsis": "ar1 [, ar2 [, ar3 [, ... arN]]] **diskin** ifilcod[, kpitch[, iskiptim \\\n      [, iwraparound[, iformat[, iskipinit]]]]]\nar1[] **diskin** ifilcod[, kpitch[, iskiptim \\\n      [, iwraparound[, iformat[, iskipinit]]]]]",
                    "opcodeName": "diskin",
                    "functionalSynopsis": "ar1[] = **diskin:a**(ifilcod[, kpitch[, iskiptim \\)"
                },
                {
                    "description": "Reads audio data from a file, and can alter its pitch using one of several\n      available interpolation types, as well as convert the sample rate to match\n      the orchestra sr setting.",
                    "synopsis": "a1[, a2[, ... aN]] **diskin2** ifilcod[, kpitch[, iskiptim \\\n      [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]\nar1[] **diskin2** ifilcod[, kpitch[, iskiptim \\\n      [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]",
                    "opcodeName": "diskin2",
                    "functionalSynopsis": "ar1[] = **diskin2:a**(ifilcod[, kpitch[, iskiptim \\)"
                },
                {
                    "description": "Reads mono audio data from an external device or stream.",
                    "synopsis": "ar1 **in**\naarray **in**",
                    "opcodeName": "in",
                    "functionalSynopsis": "ar1 = **in:a**()\naarray = **in:a**()"
                },
                {
                    "description": "Reads a 32-channel audio signal from an external device or stream.",
                    "synopsis": "ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \\\n      ar15, ar16, ar17, ar18, ar19, ar20, ar21, ar22, ar23, ar24, ar25, ar26, \\\n      ar27, ar28, ar29, ar30, ar31, ar32 **in32**",
                    "opcodeName": "in32",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads from numbered channels in an external audio signal or stream.",
                    "synopsis": "ain1[, ...] **inch** kchan1[,...]",
                    "opcodeName": "inch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads six-channel audio data from an external device or stream.",
                    "synopsis": "ar1, ar2, ar3, ar4, ar5, ar6 **inh**",
                    "opcodeName": "inh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads eight-channel audio data from an external device or stream.",
                    "synopsis": "ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8 **ino**",
                    "opcodeName": "ino",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads quad audio data from an external device or stream.",
                    "synopsis": "ar1, ar2,  ar3, a4 **inq**",
                    "opcodeName": "inq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allow input from a range of adjacent audio channels from the audio input device",
                    "synopsis": "**inrg** kstart, ain1 [,ain2, ain3, ..., ainN]",
                    "opcodeName": "inrg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads stereo audio data from an external device or stream.",
                    "synopsis": "ar1, ar2 **ins**",
                    "opcodeName": "ins",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a k-rate signal from a user-defined channel.",
                    "synopsis": "ivalue **invalue** &quot;channel name&quot;\nkvalue **invalue** &quot;channel name&quot;\nSname **invalue** &quot;channel name&quot;",
                    "opcodeName": "invalue",
                    "functionalSynopsis": "ivalue = **invalue:unknown**(&quot;channel name&quot;)\nkvalue = **invalue:k**(&quot;channel name&quot;)\nSname = **invalue:unknown**(&quot;channel name&quot;)"
                },
                {
                    "description": "Reads a 16-channel audio signal from an external device or stream.",
                    "synopsis": "ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, \\\n      ar13, ar14, ar15, ar16 **inx**",
                    "opcodeName": "inx",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads multi-channel audio samples into a ZAK array from an external device or stream.",
                    "synopsis": "**inz** ksig1",
                    "opcodeName": "inz",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads mono or stereo audio data from an external MP3 file.",
                    "synopsis": "ar1, ar2 **mp3in** ifilcod[, iskptim, iformat, iskipinit, ibufsize]\nar1 **mp3in** ifilcod[, iskptim, iformat, iskipinit, ibufsize]",
                    "opcodeName": "mp3in",
                    "functionalSynopsis": "ar1 = **mp3in:a**(ifilcod[, iskptim, iformat, iskipinit, ibufsize])"
                },
                {
                    "description": "Reads audio data from an external device or stream.",
                    "synopsis": "ar1[, ar2[, ar3[, ... a24]]] **soundin** ifilcod [, iskptim] [, iformat] \\\n      [, iskipinit] [, ibufsize]",
                    "opcodeName": "soundin",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal I/O:Signal Output",
            "opcodes": [
                {
                    "description": "A MIDI delay opcode.",
                    "synopsis": "**mdelay** kstatus, kchan, kd1, kd2, kdelay",
                    "opcodeName": "mdelay",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the audio spout frame.",
                    "synopsis": "aout1 [,aout2 ... aoutX] **monitor**\naarra **monitor**",
                    "opcodeName": "monitor",
                    "functionalSynopsis": "aarra = **monitor:a**()"
                },
                {
                    "description": "Writes audio data to an external device or stream.",
                    "synopsis": "**out** asig1[, asig2,....]\n**out** aarray",
                    "opcodeName": "out",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes 32-channel audio data to an external device or stream.",
                    "synopsis": "**out32** asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, asig10, \\\n      asig11, asig12, asig13, asig14, asig15, asig16, asig17, asig18, \\\n      asig19, asig20, asig21, asig22, asig23, asig24, asig25, asig26, \\\n      asig27, asig28, asig29, asig30, asig31, asig32",
                    "opcodeName": "out32",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Replicates one audio data sream to multiple channels.",
                    "synopsis": "**outall** asig",
                    "opcodeName": "outall",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes audio data with an arbitrary number of channels to an external device or stream.",
                    "synopsis": "**outc** asig1 [, asig2] [...]",
                    "opcodeName": "outc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes multi-channel audio data, with user-controllable channels, to an external device or stream.",
                    "synopsis": "**outch** kchan1, asig1 [, kchan2] [, asig2] [...]",
                    "opcodeName": "outch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes 6-channel audio data to an external device or stream.",
                    "synopsis": "**outh** asig1, asig2, asig3, asig4, asig5, asig6",
                    "opcodeName": "outh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes 8-channel audio data to an external device or stream.",
                    "synopsis": "**outo** asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8",
                    "opcodeName": "outo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes 4-channel audio data to an external device or stream.",
                    "synopsis": "**outq** asig1, asig2, asig3, asig4",
                    "opcodeName": "outq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to quad channel 1 of an external device or stream.",
                    "synopsis": "**outq1** asig",
                    "opcodeName": "outq1",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to quad channel 2 of an external device or stream.",
                    "synopsis": "**outq2** asig",
                    "opcodeName": "outq2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to quad channel 3 of an external device or stream.",
                    "synopsis": "**outq3** asig",
                    "opcodeName": "outq3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to quad channel 4 of an external device or stream.",
                    "synopsis": "**outq4** asig",
                    "opcodeName": "outq4",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allow output to a range of adjacent audio channels on the audio output device",
                    "synopsis": "**outrg** kstart, aout1 [,aout2, aout3, ..., aoutN]",
                    "opcodeName": "outrg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes stereo audio data to an external device or stream.",
                    "synopsis": "**outs** asig1, asig2",
                    "opcodeName": "outs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to stereo channel 1 of an external device or stream.",
                    "synopsis": "**outs1** asig",
                    "opcodeName": "outs1",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes samples to stereo channel 2 of an external device or stream.",
                    "synopsis": "**outs2** asig",
                    "opcodeName": "outs2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends an i-rate or k-rate signal or string to a user-defined channel.",
                    "synopsis": "**outvalue** &quot;channel name&quot;, ivalue\n**outvalue** &quot;channel name&quot;, kvalue\n**outvalue** &quot;channel name&quot;, &quot;string&quot;",
                    "opcodeName": "outvalue",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes 16-channel audio data to an external device or stream.",
                    "synopsis": "**outx** asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, \\\n      asig9, asig10, asig11, asig12, asig13, asig14, asig15, asig16",
                    "opcodeName": "outx",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes multi-channel audio data from a ZAK array to an external device or stream.",
                    "synopsis": "**outz** ksig1",
                    "opcodeName": "outz",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated. Writes audio output to a disk file.",
                    "synopsis": "**soundout**  asig1, ifilcod [, iformat]",
                    "opcodeName": "soundout",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated. Writes audio output to a disk file.",
                    "synopsis": "**soundouts**  asigl, asigr, ifilcod [, iformat]",
                    "opcodeName": "soundouts",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal I/O:Software Bus",
            "opcodes": [
                {
                    "description": "Reads data from the software bus",
                    "synopsis": "kval **chani** kchan\naval **chani** kchan",
                    "opcodeName": "chani",
                    "functionalSynopsis": "kval = **chani:k**(kchan)\naval = **chani:a**(kchan)"
                },
                {
                    "description": "Send data to the outwards software bus",
                    "synopsis": "**chano** kval, kchan\n**chano** aval, kchan",
                    "opcodeName": "chano",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Declare a channel of the named software bus.",
                    "synopsis": " **chn_k** Sname, imode[, itype, idflt, imin, ima, ix, iy,\n      iwidth, iheight, Sattributes]\n **chn_a** Sname, imode\n **chn_S** Sname, imode\n **chn_S** Sname, Smode",
                    "opcodeName": "chn_k",
                    "functionalSynopsis": " = **chn_k:unknown**(Sname, imode[, itype, idflt, imin, ima, ix, iy,)\n = **chn_a:unknown**(Sname, imode)\n = **chn_S:unknown**(Sname, imode)\n = **chn_S:unknown**(Sname, Smode)"
                },
                {
                    "description": "Clears a number of audio output channel of the named software bus.",
                    "synopsis": "**chnclear** Sname1[, Sname2,...]",
                    "opcodeName": "chnclear",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Export a global variable as a channel of the bus.",
                    "synopsis": "gival **chnexport** Sname, imode[, itype, idflt, imin, imax]\ngkval **chnexport** Sname, imode[, itype, idflt, imin, imax]\ngaval **chnexport** Sname, imode\ngSval **chnexport** Sname, imode",
                    "opcodeName": "chnexport",
                    "functionalSynopsis": "gival = **chnexport:unknown**(Sname, imode[, itype, idflt, imin, imax])\ngkval = **chnexport:unknown**(Sname, imode[, itype, idflt, imin, imax])\ngaval = **chnexport:unknown**(Sname, imode)\ngSval = **chnexport:unknown**(Sname, imode)"
                },
                {
                    "description": "Reads data from the software bus.",
                    "synopsis": "ival **chnget** Sname\nkval **chnget** Sname\naval **chnget** Sname\nSval **chnget** Sname\nSval **chngetks** Sname\nival[] **chngeti** Sname[]\nkval[] **chngetk** Sname[]\naval[] **chngeta** Sname[]\nSval[] **chngets** Sname[]",
                    "opcodeName": "chnget",
                    "functionalSynopsis": "ival = **chnget:unknown**(Sname)\nkval = **chnget:k**(Sname)\naval = **chnget:a**(Sname)\nSval = **chnget:unknown**(Sname)\nSval = **chngetks:unknown**(Sname)\nival[] = **chngeti:unknown**(Sname[])\nkval[] = **chngetk:k**(Sname[])\naval[] = **chngeta:a**(Sname[])\nSval[] = **chngets:unknown**(Sname[])"
                },
                {
                    "description": "Writes audio data to the named software bus, mixing to the previous\n      output.",
                    "synopsis": "**chnmix** aval, Sname",
                    "opcodeName": "chnmix",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Query parameters of a channel.",
                    "synopsis": "itype, imode, ictltype, idflt, imin, imax **chnparams** Sname",
                    "opcodeName": "chnparams",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes data to the named software bus.",
                    "synopsis": "**chnset** ival, Sname\n**chnset** kval, Sname\n**chnset** aval, Sname\n**chnset** Sval, Sname\n**chnsetks** Sval, Sname\n**chnseti** ival[], []Sname\n**chnsetk** kval[], []Sname\n**chnseta** aval[], []Sname\n**chnsets** Sval[], []Sname",
                    "opcodeName": "chnset",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the local ksmps value in an instrument or user-defined opcode block",
                    "synopsis": "**setksmps** iksmps",
                    "opcodeName": "setksmps",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Passes variables to a user-defined opcode block,",
                    "synopsis": "xinarg1 [, xinarg2] ... [xinargN] **xin**",
                    "opcodeName": "xin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Retrieves variables from a user-defined opcode block,",
                    "synopsis": "**xout** xoutarg1 [, xoutarg2] ... [, xoutargN]",
                    "opcodeName": "xout",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal I/O:Printing and Display",
            "opcodes": [
                {
                    "description": "Displays the Fourier Transform of an audio or control signal.",
                    "synopsis": "**dispfft** xsig, iprd, iwsiz [, iwtyp] [, idbout] [, iwtflg] [,imin] [,imax]",
                    "opcodeName": "dispfft",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Displays the audio or control signals as an amplitude vs. time graph.",
                    "synopsis": "**display** xsig, iprd [, inprds] [, iwtflg]",
                    "opcodeName": "display",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows text to be displayed from instruments like sliders",
                    "synopsis": "**flashtxt**  iwhich, String",
                    "opcodeName": "flashtxt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Displays the values init (i-rate) variables.",
                    "synopsis": "**print** iarg [, iarg1] [, iarg2] [...]",
                    "opcodeName": "print",
                    "functionalSynopsis": ""
                },
                {
                    "description": "printf-style formatted output",
                    "synopsis": "**printf_i** Sfmt, itrig, [iarg1[, iarg2[, ... ]]]\n**printf** Sfmt, ktrig, [xarg1[, xarg2[, ... ]]]",
                    "opcodeName": "printf_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints one k-rate value at specified intervals.",
                    "synopsis": "**printk** itime, kval [, ispace] [, inamed]",
                    "opcodeName": "printk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints a new value every time a control variable changes.",
                    "synopsis": "**printk2** kvar [, inumspaces] [, inamed]",
                    "opcodeName": "printk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints at k-rate using a printf() style syntax.",
                    "synopsis": "**printks** &quot;string&quot;, itime [, xval1] [, xval2] [...]",
                    "opcodeName": "printks",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints a new value every time a control variable changes using a\n      printf() style syntax.",
                    "synopsis": "**printks2** &quot;string&quot;, kval",
                    "opcodeName": "printks2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints at k-rate using a printf() style syntax, appends a new line",
                    "synopsis": "**println** &quot;string&quot;, [, xval1] [, xval2] [...]",
                    "opcodeName": "println",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints at init-time using a printf() style syntax.",
                    "synopsis": "**prints** &quot;string&quot; [, xval1] [, xval2] [...]",
                    "opcodeName": "prints",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Prints at k-rate using a printf() style syntax.",
                    "synopsis": "**printsk** &quot;string&quot;, [, xval1] [, xval2] [...]",
                    "opcodeName": "printsk",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal I/O:Soundfile Queries",
            "opcodes": [
                {
                    "description": "Returns the number of bits in each sample in a sound file.",
                    "synopsis": "ir **filebit** ifilcod [, iallowraw]",
                    "opcodeName": "filebit",
                    "functionalSynopsis": "ir = **filebit:unknown**(ifilcod [, iallowraw])"
                },
                {
                    "description": "Returns the length of a sound file.",
                    "synopsis": "ir **filelen** ifilcod, [iallowraw]",
                    "opcodeName": "filelen",
                    "functionalSynopsis": "ir = **filelen:unknown**(ifilcod, [iallowraw])"
                },
                {
                    "description": "Returns the number of channels in a sound file.",
                    "synopsis": "ir **filenchnls** ifilcod [, iallowraw]",
                    "opcodeName": "filenchnls",
                    "functionalSynopsis": "ir = **filenchnls:unknown**(ifilcod [, iallowraw])"
                },
                {
                    "description": "Returns the peak absolute value of a sound file.",
                    "synopsis": "ir **filepeak** ifilcod [, ichnl]",
                    "opcodeName": "filepeak",
                    "functionalSynopsis": "ir = **filepeak:unknown**(ifilcod [, ichnl])"
                },
                {
                    "description": "Returns the sample rate of a sound file.",
                    "synopsis": "ir **filesr** ifilcod [, iallowraw]",
                    "opcodeName": "filesr",
                    "functionalSynopsis": "ir = **filesr:unknown**(ifilcod [, iallowraw])"
                },
                {
                    "description": "Checks that a file can be read at initialisation or performance time.",
                    "synopsis": "ir **filevalid** ifilcod\nkr **filevalid** ifilcod",
                    "opcodeName": "filevalid",
                    "functionalSynopsis": "ir = **filevalid:unknown**(ifilcod)\nkr = **filevalid:k**(ifilcod)"
                },
                {
                    "description": "Returns the length of an MP3 sound file.",
                    "synopsis": "ir **mp3len** ifilcod",
                    "opcodeName": "mp3len",
                    "functionalSynopsis": "ir = **mp3len:unknown**(ifilcod)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Amplitude Modifiers",
            "opcodes": [
                {
                    "description": "Adjust one audio signal according to the values of another.",
                    "synopsis": "ares **balance** asig, acomp [, ihp] [, iskip]",
                    "opcodeName": "balance",
                    "functionalSynopsis": "ares = **balance:a**(asig, acomp [, ihp] [, iskip])"
                },
                {
                    "description": "Adjust one audio signal according to the values of another.",
                    "synopsis": "ares **balance2** asig, acomp [, ihp] [, iskip]",
                    "opcodeName": "balance2",
                    "functionalSynopsis": "ares = **balance2:a**(asig, acomp [, ihp] [, iskip])"
                },
                {
                    "description": "Clips a signal to a predefined limit.",
                    "synopsis": "ares **clip** asig, imeth, ilimit [, iarg]",
                    "opcodeName": "clip",
                    "functionalSynopsis": "ares = **clip:a**(asig, imeth, ilimit [, iarg])"
                },
                {
                    "description": "Compress, limit, expand, duck or gate an audio signal.",
                    "synopsis": "ar **compress** aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook",
                    "opcodeName": "compress",
                    "functionalSynopsis": "ar = **compress:a**(aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook)"
                },
                {
                    "description": "Compress, limit, expand, duck or gate an audio signal.",
                    "synopsis": "ar **compress2** aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook",
                    "opcodeName": "compress2",
                    "functionalSynopsis": "ar = **compress2:a**(aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook)"
                },
                {
                    "description": "A dynamic compressor/expander.",
                    "synopsis": "ares **dam** asig, kthreshold, icomp1, icomp2, irtime, iftime",
                    "opcodeName": "dam",
                    "functionalSynopsis": "ares = **dam:a**(asig, kthreshold, icomp1, icomp2, irtime, iftime)"
                },
                {
                    "description": "Adjusts the amplitude audio signal according to a root-mean-square value.",
                    "synopsis": "ares **gain** asig, krms [, ihp] [, iskip]",
                    "opcodeName": "gain",
                    "functionalSynopsis": "ares = **gain:a**(asig, krms [, ihp] [, iskip])"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Convolution and Morphing",
            "opcodes": [
                {
                    "description": "Same as the convolve opcode.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Convolves a signal and an impulse response.",
                    "synopsis": "ar1 [, ar2] [, ar3] [, ar4] **convolve** ain, ifilcod [, ichannel]",
                    "opcodeName": "convolve",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Cross synthesis using FFT's.",
                    "synopsis": "ares **cross2** ain1, ain2, isize, ioverlap, iwin, kbias",
                    "opcodeName": "cross2",
                    "functionalSynopsis": "ares = **cross2:a**(ain1, ain2, isize, ioverlap, iwin, kbias)"
                },
                {
                    "description": "A direct convolution opcode.",
                    "synopsis": "ares **dconv** asig, isize, ifn",
                    "opcodeName": "dconv",
                    "functionalSynopsis": "ares = **dconv:a**(asig, isize, ifn)"
                },
                {
                    "description": "Low latency multichannel convolution, using a function table as impulse\n\tresponse source.",
                    "synopsis": "a1[, a2[, a3[, ... a8]]] **ftconv** ain, ift, iplen[, iskipsamples \\\n      [, iirlen[, iskipinit]]]",
                    "opcodeName": "ftconv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Morphs between multiple ftables as specified in a list.",
                    "synopsis": "**ftmorf** kftndx, iftfn, iresfn",
                    "opcodeName": "ftmorf",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Partitioned convolution with dynamically reloadable impulse response",
                    "synopsis": "ares **liveconv** ain, ift, iplen, kupdate, kclear",
                    "opcodeName": "liveconv",
                    "functionalSynopsis": "ares = **liveconv:a**(ain, ift, iplen, kupdate, kclear)"
                },
                {
                    "description": "Convolution based on a uniformly partitioned overlap-save algorithm",
                    "synopsis": "ar1 [, ar2] [, ar3] [, ar4] **pconvolve** ain, ifilcod [, ipartitionsize, ichannel]",
                    "opcodeName": "pconvolve",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A time-varying convolution (FIR filter) opcode.",
                    "synopsis": "ares **tvconv** asig1, asig2, xfreez1,\n    xfreez2, iparts, ifils",
                    "opcodeName": "tvconv",
                    "functionalSynopsis": "ares = **tvconv:a**(asig1, asig2, xfreez1,)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Delay",
            "opcodes": [
                {
                    "description": "Delays an input signal by some time interval.",
                    "synopsis": "ares **delay** asig, idlt [, iskip]",
                    "opcodeName": "delay",
                    "functionalSynopsis": "ares = **delay:a**(asig, idlt [, iskip])"
                },
                {
                    "description": "Delays an input signal by one sample.",
                    "synopsis": "ares **delay1** asig [, iskip]",
                    "opcodeName": "delay1",
                    "functionalSynopsis": "ares = **delay1:a**(asig [, iskip])"
                },
                {
                    "description": "Delays an input signal by some time interval.",
                    "synopsis": "kr **delayk **  ksig, idel[, imode]\nkr **vdel_k **  ksig, kdel, imdel[, imode]",
                    "opcodeName": "delayk ",
                    "functionalSynopsis": "kr = **delayk:k**(**  ksig, idel[, imode])\nkr = **vdel_k:k**(**  ksig, kdel, imdel[, imode])"
                },
                {
                    "description": "Reads from an automatically established digital delay line.",
                    "synopsis": "ares **delayr** idlt [, iskip]",
                    "opcodeName": "delayr",
                    "functionalSynopsis": "ares = **delayr:a**(idlt [, iskip])"
                },
                {
                    "description": "Writes the audio signal to a digital delay line.",
                    "synopsis": "**delayw** asig",
                    "opcodeName": "delayw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Taps a delay line at variable offset times.",
                    "synopsis": "ares **deltap** kdlt",
                    "opcodeName": "deltap",
                    "functionalSynopsis": "ares = **deltap:a**(kdlt)"
                },
                {
                    "description": "Taps a delay line at variable offset times, uses cubic interpolation.",
                    "synopsis": "ares **deltap3** xdlt",
                    "opcodeName": "deltap3",
                    "functionalSynopsis": "ares = **deltap3:a**(xdlt)"
                },
                {
                    "description": "Taps a delay line at variable offset times, uses interpolation.",
                    "synopsis": "ares **deltapi** xdlt",
                    "opcodeName": "deltapi",
                    "functionalSynopsis": "ares = **deltapi:a**(xdlt)"
                },
                {
                    "description": "Taps a delay line at variable offset times.",
                    "synopsis": "ares **deltapn** xnumsamps",
                    "opcodeName": "deltapn",
                    "functionalSynopsis": "ares = **deltapn:a**(xnumsamps)"
                },
                {
                    "description": "Read from or write to a delay line with interpolation.",
                    "synopsis": "aout **deltapx** adel, iwsize",
                    "opcodeName": "deltapx",
                    "functionalSynopsis": "aout = **deltapx:a**(adel, iwsize)"
                },
                {
                    "description": "Mixes the input signal to a delay line.",
                    "synopsis": "**deltapxw** ain, adel, iwsize",
                    "opcodeName": "deltapxw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Multitap delay line implementation.",
                    "synopsis": "ares **multitap** asig [, itime1, igain1] [, itime2, igain2] [...]",
                    "opcodeName": "multitap",
                    "functionalSynopsis": "ares = **multitap:a**(asig [, itime1, igain1] [, itime2, igain2] [...])"
                },
                {
                    "description": "Short description. Single line for opcode listing.",
                    "synopsis": "outarg1, outarg2 **newopcodename** inarg1, inarg2",
                    "opcodeName": "newopcodename",
                    "functionalSynopsis": ""
                },
                {
                    "description": "An interpolating variable time delay.",
                    "synopsis": "ares **vdelay** asig, adel, imaxdel [, iskip]",
                    "opcodeName": "vdelay",
                    "functionalSynopsis": "ares = **vdelay:a**(asig, adel, imaxdel [, iskip])"
                },
                {
                    "description": "A variable time delay with cubic interpolation.",
                    "synopsis": "ares **vdelay3** asig, adel, imaxdel [, iskip]",
                    "opcodeName": "vdelay3",
                    "functionalSynopsis": "ares = **vdelay3:a**(asig, adel, imaxdel [, iskip])"
                },
                {
                    "description": "A variable delay opcode with high quality interpolation.",
                    "synopsis": "aout **vdelayx** ain, adl, imd, iws [, ist]",
                    "opcodeName": "vdelayx",
                    "functionalSynopsis": "aout = **vdelayx:a**(ain, adl, imd, iws [, ist])"
                },
                {
                    "description": "A 4-channel variable delay opcode with high quality interpolation.",
                    "synopsis": "aout1, aout2, aout3, aout4 **vdelayxq** ain1, ain2, ain3, ain4, adl, imd, iws [, ist]",
                    "opcodeName": "vdelayxq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A stereo variable delay opcode with high quality interpolation.",
                    "synopsis": "aout1, aout2 **vdelayxs** ain1, ain2, adl, imd, iws [, ist]",
                    "opcodeName": "vdelayxs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Variable delay opcodes with high quality interpolation.",
                    "synopsis": "aout **vdelayxw** ain, adl, imd, iws [, ist]",
                    "opcodeName": "vdelayxw",
                    "functionalSynopsis": "aout = **vdelayxw:a**(ain, adl, imd, iws [, ist])"
                },
                {
                    "description": "Variable delay opcodes with high quality interpolation.",
                    "synopsis": "aout1, aout2, aout3, aout4 **vdelayxwq** ain1, ain2, ain3, ain4, adl, \\\n      imd, iws [, ist]",
                    "opcodeName": "vdelayxwq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Variable delay opcodes with high quality interpolation.",
                    "synopsis": "aout1, aout2 **vdelayxws** ain1, ain2, adl, imd, iws [, ist]",
                    "opcodeName": "vdelayxws",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Modifiers:Panning and Spatialization",
            "opcodes": [
                {
                    "description": "Deprecated. Decodes an ambisonic B format signal.",
                    "synopsis": "ao1, ao2 **bformdec** isetup, aw, ax, ay, az [, ar, as, at, au, av \\\n      [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4 **bformdec** isetup, aw, ax, ay, az [, ar, as, at, \\\n      au, av [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5 **bformdec** isetup, aw, ax, ay, az [, ar, as, \\\n      at, au, av [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8 **bformdec** isetup, aw, ax, ay, az \\\n      [, ar, as, at, au, av [, abk, al, am, an, ao, ap, aq]]]",
                    "opcodeName": "bformdec",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Decodes an ambisonic B format signal",
                    "synopsis": "ao1, ao2 **bformdec1** isetup, aw, ax, ay, az [, ar, as, at, au, av \\\n      [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4 **bformdec1** isetup, aw, ax, ay, az [, ar, as, at, \\\n      au, av [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5 **bformdec1** isetup, aw, ax, ay, az [, ar, as, \\\n      at, au, av [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8 **bformdec1** isetup, aw, ax, ay, az \\\n      [, ar, as, at, au, av [, abk, al, am, an, ao, ap,\n    aq]]]\naout[] **bformdec1** isetup, abform[]",
                    "opcodeName": "bformdec1",
                    "functionalSynopsis": "aout[] = **bformdec1:a**(isetup, abform[])"
                },
                {
                    "description": "Decodes an Ambisonics B format signal.",
                    "synopsis": "aout[] **bformdec2** isetup, abform[], [idecoder, idistance, ifreq, \\\n\t\timix, ifilel, ifiler]",
                    "opcodeName": "bformdec2",
                    "functionalSynopsis": "aout[] = **bformdec2:a**(isetup, abform[], [idecoder, idistance, ifreq, \\)"
                },
                {
                    "description": "Deprecated. Codes a signal into the ambisonic B format.",
                    "synopsis": "aw, ax, ay, az **bformenc** asig, kalpha, kbeta, kord0, kord1\naw, ax, ay, az, ar, as, at, au, av **bformenc** asig, kalpha, kbeta, \\\n      kord0, kord1 , kord2\naw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq **bformenc** \\\n      asig, kalpha, kbeta, kord0, kord1, kord2, kord3",
                    "opcodeName": "bformenc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Codes a signal into the ambisonic B format.",
                    "synopsis": "aw, ax, ay, az **bformenc1** asig, kalpha, kbeta\naw, ax, ay, az, ar, as, at, au, av **bformenc1** asig, kalpha, kbeta\naw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq **bformenc1** \\\n      asig, kalpha, kbeta\naarray[] **bformenc1** asig, kalpha, kbeta",
                    "opcodeName": "bformenc1",
                    "functionalSynopsis": "aarray[] = **bformenc1:a**(asig, kalpha, kbeta)"
                },
                {
                    "description": "Generates 3D binaural audio with high-fidelity early reflections in a parametric room using a Phase Truncation algorithm.",
                    "synopsis": "aleft, aright, irt60low, irt60high, imfp **hrtfearly** asrc, ksrcx, ksrcy, ksrcz, klstnrx, klstnry, klstnrz, \\\n      ifilel, ifiler, idefroom [,ifade, isr, iorder, ithreed, kheadrot, iroomx, iroomy, iroomz, iwallhigh, \\\n      iwalllow, iwallgain1, iwallgain2, iwallgain3, ifloorhigh, ifloorlow, ifloorgain1, ifloorgain2, \\\n      ifloorgain3, iceilinghigh, iceilinglow, iceilinggain1, iceilinggain2, iceilinggain3]",
                    "opcodeName": "hrtfearly",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates 3D audio for two speakers.",
                    "synopsis": "aleft, aright **hrtfer** asig, kaz, kelev, <quote>HRTFcompact</quote>",
                    "opcodeName": "hrtfer",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates dynamic 3d binaural audio for headphones using magnitude interpolation and phase truncation.",
                    "synopsis": "aleft, aright **hrtfmove** asrc, kAz, kElev, ifilel, ifiler [, imode, ifade, isr]",
                    "opcodeName": "hrtfmove",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates dynamic 3d binaural audio for headphones using a Woodworth based spherical head model\n      with improved low frequency phase accuracy.",
                    "synopsis": "aleft, aright **hrtfmove2** asrc, kAz, kElev, ifilel, ifiler [,ioverlap, iradius, isr]",
                    "opcodeName": "hrtfmove2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A binaural, dynamic FDN based diffuse-field reverberator. The opcode works independently as an efficient, flexible reverberator.",
                    "synopsis": "aleft, aright, idel **hrtfreverb** asrc, ilowrt60, ihighrt60, ifilel, ifiler [,isr, imfp, iorder]",
                    "opcodeName": "hrtfreverb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates static 3d binaural audio for headphones using a\n      Woodworth based spherical head model with improved low frequency\n      phase accuracy.",
                    "synopsis": "\n      aleft, aright **hrtfstat** asrc, iAz, iElev, ifilel, ifiler [,iradius, isr]\n    ",
                    "opcodeName": "hrtfstat",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes the audio signals of a previous",
                    "synopsis": "a1, a2 **locsend**\na1, a2,  a3, a4 **locsend**",
                    "opcodeName": "locsend",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Takes an input signal and distributes between 2 or 4 channels.",
                    "synopsis": "a1, a2 **locsig** asig, kdegree, kdistance, kreverbsend\na1, a2,  a3, a4 **locsig** asig, kdegree, kdistance, kreverbsend",
                    "opcodeName": "locsig",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distribute an audio signal amongst four channels.",
                    "synopsis": "a1, a2, a3, a4 **pan** asig, kx, ky, ifn [, imode] [, ioffset]",
                    "opcodeName": "pan",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distribute an audio signal across two channels.",
                    "synopsis": "a1, a2 **pan2** asig, xp [, imode]",
                    "opcodeName": "pan2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an input signal among 4 channels using cartesian coordinates.",
                    "synopsis": "a1, a2, a3, a4  **space** asig, ifn, ktime, kreverbsend, kx, ky",
                    "opcodeName": "space",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Positions the input sound in a 3D space and allows moving the sound at k-rate.",
                    "synopsis": "aW, aX, aY, aZ **spat3d** ain, kX, kY, kZ, idist, ift, imode, imdel, iovr [, istor]",
                    "opcodeName": "spat3d",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Positions the input sound in a 3D space with the sound source position set at i-time.",
                    "synopsis": "aW, aX, aY, aZ **spat3di** ain, iX, iY, iZ, idist, ift, imode [, istor]",
                    "opcodeName": "spat3di",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Can be used to render an impulse response for a 3D space at i-time.",
                    "synopsis": "**spat3dt** ioutft, iX, iY, iZ, idist, ift, imode, irlen [, iftnocl]",
                    "opcodeName": "spat3dt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Calculates distance values from xy coordinates.",
                    "synopsis": "k1 **spdist** ifn, ktime, kx, ky",
                    "opcodeName": "spdist",
                    "functionalSynopsis": "k1 = **spdist:k**(ifn, ktime, kx, ky)"
                },
                {
                    "description": "Generates output signals based on a previously defined",
                    "synopsis": "a1, a2, a3, a4 **spsend**",
                    "opcodeName": "spsend",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among many channels.",
                    "synopsis": "ar1[, ar2...] **vbap** asig, kazim [,\n    kelev] [, kspread] [, ilayout]\narray[] **vbap** asig, kazim [,\n    kelev] [, kspread] [, ilayout]",
                    "opcodeName": "vbap",
                    "functionalSynopsis": "array[] = **vbap:a**(asig, kazim [,)"
                },
                {
                    "description": "Distributes an audio signal among 16 channels.",
                    "synopsis": "ar1, ..., ar16 **vbap16** asig, kazim [, kelev] [, kspread]",
                    "opcodeName": "vbap16",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distribute an audio signal among 16 channels with moving virtual sources.",
                    "synopsis": "ar1, ..., ar16 **vbap16move** asig, idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]",
                    "opcodeName": "vbap16move",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among 4 channels.",
                    "synopsis": "ar1, ar2, ar3, ar4 **vbap4** asig, kazim [, kelev] [, kspread]",
                    "opcodeName": "vbap4",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among 4 channels with moving virtual sources.",
                    "synopsis": "ar1, ar2, ar3, ar4 **vbap4move** asig, idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]",
                    "opcodeName": "vbap4move",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among 8 channels.",
                    "synopsis": "ar1, ..., ar8 **vbap8** asig, kazim [, kelev] [, kspread]",
                    "opcodeName": "vbap8",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among 8 channels with moving virtual sources.",
                    "synopsis": "ar1, ..., ar8 **vbap8move** asig, idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]",
                    "opcodeName": "vbap8move",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Calculates the gains for a sound location between multiple channels.",
                    "synopsis": "k1[, k2...] **vbapg** kazim [,kelev] [, kspread] [, ilayout]\nkarray[] **vbapg** kazim [,kelev] [, kspread] [, ilayout]",
                    "opcodeName": "vbapg",
                    "functionalSynopsis": "karray[] = **vbapg:k**(kazim [,kelev] [, kspread] [, ilayout])"
                },
                {
                    "description": "Calculates the gains for a sound location between multiple\n      channels with moving virtual sources.",
                    "synopsis": "kr1[, kr2...] **vbapgmove** idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]\nkarray[] **vbapgmove** idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]",
                    "opcodeName": "vbapgmove",
                    "functionalSynopsis": "karray[] = **vbapgmove:k**(idur, ispread, ifldnum, ifld1 \\)"
                },
                {
                    "description": "Configures VBAP output according to loudspeaker parameters.",
                    "synopsis": "**vbaplsinit** idim, ilsnum [, idir1] [, idir2] [...] [, idir32]\n**vbaplsinit** idim, ilsnum, ilsarray",
                    "opcodeName": "vbaplsinit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Distributes an audio signal among many channels with moving virtual sources.",
                    "synopsis": "ar1[, ar2...] **vbapmove** asig, idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]\naarray[] **vbapmove** asig, idur, ispread, ifldnum, ifld1 \\\n      [, ifld2] [...]",
                    "opcodeName": "vbapmove",
                    "functionalSynopsis": "aarray[] = **vbapmove:a**(asig, idur, ispread, ifldnum, ifld1 \\)"
                },
                {
                    "description": "Writes a multi-channel audio signal to a ZAK array.",
                    "synopsis": "**vbapz** inumchnls, istartndx, asig, kazim [, kelev] [, kspread]",
                    "opcodeName": "vbapz",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes a multi-channel audio signal to a ZAK array with moving virtual sources.",
                    "synopsis": "**vbapzmove** inumchnls, istartndx, asig, idur, ispread, ifldnum, ifld1, \\\n      ifld2, [...]",
                    "opcodeName": "vbapzmove",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Modifiers:Reverberation",
            "opcodes": [
                {
                    "description": "Reverberates an input signal with a flat frequency response.",
                    "synopsis": "ares **alpass** asig, xrvt, ilpt [, iskip] [, insmps]",
                    "opcodeName": "alpass",
                    "functionalSynopsis": "ares = **alpass:a**(asig, xrvt, ilpt [, iskip] [, insmps])"
                },
                {
                    "description": "A physical model reverberator.",
                    "synopsis": "a1, a2 **babo** asig, ksrcx, ksrcy,\n    ksrcz, irx, iry, irz [, idiff] [, ifno]\na1, a2 **babo2** asig, ksrcx, ksrcy, ksrcz, irx, iry, irz [, idiff] [, ifno]",
                    "opcodeName": "babo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reverberates an input signal with a",
                    "synopsis": "ares **comb** asig, krvt, ilpt [, iskip] [, insmps]",
                    "opcodeName": "comb",
                    "functionalSynopsis": "ares = **comb:a**(asig, krvt, ilpt [, iskip] [, insmps])"
                },
                {
                    "description": "Reverberates an input signal with a",
                    "synopsis": "ares **combinv** asig, krvt, ilpt [, iskip] [, insmps]",
                    "opcodeName": "combinv",
                    "functionalSynopsis": "ares = **combinv:a**(asig, krvt, ilpt [, iskip] [, insmps])"
                },
                {
                    "description": "Opcode version of Jezar's Freeverb",
                    "synopsis": "aoutL, aoutR **freeverb** ainL, ainR, kRoomSize, kHFDamp[, iSRate[, iSkip]] ",
                    "opcodeName": "freeverb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Three different nested all-pass filters.",
                    "synopsis": "ares **nestedap** asig, imode, imaxdel, idel1, igain1 [, idel2] [, igain2] \\\n      [, idel3] [, igain3] [, istor]",
                    "opcodeName": "nestedap",
                    "functionalSynopsis": "ares = **nestedap:a**(asig, imode, imaxdel, idel1, igain1 [, idel2] [, igain2] \\)"
                },
                {
                    "description": "A reverberator consisting of 6 parallel comb-lowpass filters.",
                    "synopsis": "ares **nreverb** asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] \\\n      [, inumAlpas] [, ifnAlpas]",
                    "opcodeName": "nreverb",
                    "functionalSynopsis": "ares = **nreverb:a**(asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] \\)"
                },
                {
                    "description": "Models the reverberation of a metal plate.",
                    "synopsis": "a1[, a2, ...] **platerev** itabexcite. itabouts, kbndry, iaspect, istiff, idecay, iloss, aexcite1[, aexcite2, ...]",
                    "opcodeName": "platerev",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reverberates an input signal with a",
                    "synopsis": "ares **reverb** asig, krvt [, iskip]",
                    "opcodeName": "reverb",
                    "functionalSynopsis": "ares = **reverb:a**(asig, krvt [, iskip])"
                },
                {
                    "description": "Same as the nreverb opcode.",
                    "synopsis": "ares **reverb2** asig, ktime, khdif [, iskip] [,inumCombs] \\\n      [, ifnCombs] [, inumAlpas] [, ifnAlpas]",
                    "opcodeName": "reverb2",
                    "functionalSynopsis": "ares = **reverb2:a**(asig, ktime, khdif [, iskip] [,inumCombs] \\)"
                },
                {
                    "description": "8 delay line stereo FDN reverb, based on work by Sean Costello",
                    "synopsis": "aoutL, aoutR **reverbsc** ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]] ",
                    "opcodeName": "reverbsc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Variably reverberates an input signal with a flat frequency response.",
                    "synopsis": "ares **valpass** asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]",
                    "opcodeName": "valpass",
                    "functionalSynopsis": "ares = **valpass:a**(asig, krvt, xlpt, imaxlpt [, iskip] [, insmps])"
                },
                {
                    "description": "Variably reverberates an input signal with a",
                    "synopsis": "ares **vcomb** asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]",
                    "opcodeName": "vcomb",
                    "functionalSynopsis": "ares = **vcomb:a**(asig, krvt, xlpt, imaxlpt [, iskip] [, insmps])"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Sample Level Operators",
            "opcodes": [
                {
                    "description": "Mixes low level noise to a list of a-rate signals",
                    "synopsis": "**denorm** a1[, a2[, a3[, ... ]]]",
                    "opcodeName": "denorm",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Modify a signal by differentiation.",
                    "synopsis": "ares **diff** asig [, iskip]\nkres **diff** ksig [, iskip]",
                    "opcodeName": "diff",
                    "functionalSynopsis": "ares = **diff:a**(asig [, iskip])\nkres = **diff:k**(ksig [, iskip])"
                },
                {
                    "description": "Modify a signal by down-sampling.",
                    "synopsis": "kres **downsamp** asig [, iwlen]",
                    "opcodeName": "downsamp",
                    "functionalSynopsis": "kres = **downsamp:k**(asig [, iwlen])"
                },
                {
                    "description": "Adds artificial foldover to an audio signal.",
                    "synopsis": "ares **fold** asig, kincr",
                    "opcodeName": "fold",
                    "functionalSynopsis": "ares = **fold:a**(asig, kincr)"
                },
                {
                    "description": "Modify a signal by integration.",
                    "synopsis": "ares **integ** asig [, iskip]\nkres **integ** ksig [, iskip]",
                    "opcodeName": "integ",
                    "functionalSynopsis": "ares = **integ:a**(asig [, iskip])\nkres = **integ:k**(ksig [, iskip])"
                },
                {
                    "description": "Converts a control signal to an audio signal using linear interpolation.",
                    "synopsis": "ares **interp** ksig [, iskip] [, imode]\n    [, ivalue]",
                    "opcodeName": "interp",
                    "functionalSynopsis": "ares = **interp:a**(ksig [, iskip] [, imode])"
                },
                {
                    "description": "Calculates the weighted mean value of two input signals.",
                    "synopsis": "ares **ntrpol** asig1, asig2, kpoint [, imin] [, imax]\nires **ntrpol** isig1, isig2, ipoint [, imin] [, imax]\nkres **ntrpol** ksig1, ksig2, kpoint [, imin] [, imax]",
                    "opcodeName": "ntrpol",
                    "functionalSynopsis": "ares = **ntrpol:a**(asig1, asig2, kpoint [, imin] [, imax])\nires = **ntrpol:unknown**(isig1, isig2, ipoint [, imin] [, imax])\nkres = **ntrpol:k**(ksig1, ksig2, kpoint [, imin] [, imax])"
                },
                {
                    "description": "Converts a k-rate parameter to an a-rate value with interpolation.",
                    "synopsis": "**a**(x) (control-rate args only)",
                    "opcodeName": "a",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns an init-type equivalent of a k-rate argument, or directly returns an i-rate argument.",
                    "synopsis": "**i**(x) (control-rate or init-rate arg)\n**i**(karray,index1, ...) (k-array with indices)",
                    "opcodeName": "i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a i-rate parameter to an k-rate value.\n      Or converts an a-rate value to a k-rate value by down-sampling.",
                    "synopsis": "**k**(x) (i-rate args only)\n**k**(x) (a-rate args only)",
                    "opcodeName": "k",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns an S-type equivalent of an init-time or k-rate argument.",
                    "synopsis": "**S**(x) (control-rate or init-rate arg)",
                    "opcodeName": "S",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a sample-and-hold operation on its input.",
                    "synopsis": "ares **samphold** asig, agate [, ival] [, ivstor]\nkres **samphold** ksig, kgate [, ival] [, ivstor]",
                    "opcodeName": "samphold",
                    "functionalSynopsis": "ares = **samphold:a**(asig, agate [, ival] [, ivstor])\nkres = **samphold:k**(ksig, kgate [, ival] [, ivstor])"
                },
                {
                    "description": "Modify a signal by up-sampling.",
                    "synopsis": "ares **upsamp** ksig",
                    "opcodeName": "upsamp",
                    "functionalSynopsis": "ares = **upsamp:a**(ksig)"
                },
                {
                    "description": "Access values of the current buffer of an a-rate variable by indexing.",
                    "synopsis": "kval **vaget** kndx, avar",
                    "opcodeName": "vaget",
                    "functionalSynopsis": "kval = **vaget:k**(kndx, avar)"
                },
                {
                    "description": "Write value of into the current buffer of an a-rate variable by index.",
                    "synopsis": "**vaset** kval, kndx, avar",
                    "opcodeName": "vaset",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Modifiers:Signal Limiters",
            "opcodes": [
                {
                    "description": "Sets the lower and upper limits of the value it processes.",
                    "synopsis": "ares **limit** asig, klow, khigh\nires **limit** isig, ilow, ihigh\nkres **limit** ksig, klow, khigh\nires[] **limit** isig[], ilow, ihigh\nkres[] **limit** ksig[], klow, khigh",
                    "opcodeName": "limit",
                    "functionalSynopsis": "ares = **limit:a**(asig, klow, khigh)\nires = **limit:unknown**(isig, ilow, ihigh)\nkres = **limit:k**(ksig, klow, khigh)\nires[] = **limit:unknown**(isig[], ilow, ihigh)\nkres[] = **limit:k**(ksig[], klow, khigh)"
                },
                {
                    "description": "Reflects the signal that exceeds the low and high thresholds.",
                    "synopsis": "ares **mirror** asig, klow, khigh\nires **mirror** isig, ilow, ihigh\nkres **mirror** ksig, klow, khigh",
                    "opcodeName": "mirror",
                    "functionalSynopsis": "ares = **mirror:a**(asig, klow, khigh)\nires = **mirror:unknown**(isig, ilow, ihigh)\nkres = **mirror:k**(ksig, klow, khigh)"
                },
                {
                    "description": "Wraps-around the signal that exceeds the low and high thresholds.",
                    "synopsis": "ares **wrap** asig, klow, khigh\nires **wrap** isig, ilow, ihigh\nkres **wrap** ksig, klow, khigh",
                    "opcodeName": "wrap",
                    "functionalSynopsis": "ares = **wrap:a**(asig, klow, khigh)\nires = **wrap:unknown**(isig, ilow, ihigh)\nkres = **wrap:k**(ksig, klow, khigh)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Special Effects",
            "opcodes": [
                {
                    "description": "Distort an audio signal via waveshaping and optional clipping.",
                    "synopsis": "ar **distort** asig, kdist, ifn[, ihp, istor]",
                    "opcodeName": "distort",
                    "functionalSynopsis": "ar = **distort:a**(asig, kdist, ifn[, ihp, istor])"
                },
                {
                    "description": "Modified hyperbolic tangent distortion.",
                    "synopsis": "ares **distort1** asig, kpregain, kpostgain, kshape1, kshape2[, imode]",
                    "opcodeName": "distort1",
                    "functionalSynopsis": "ares = **distort1:a**(asig, kpregain, kpostgain, kshape1, kshape2[, imode])"
                },
                {
                    "description": "A user controlled flanger.",
                    "synopsis": "ares **flanger** asig, adel, kfeedback [, imaxd]",
                    "opcodeName": "flanger",
                    "functionalSynopsis": "ares = **flanger:a**(asig, adel, kfeedback [, imaxd])"
                },
                {
                    "description": "Analyze an audio input and generate harmonizing voices in synchrony.",
                    "synopsis": "ares **harmon** asig, kestfrq, kmaxvar, kgenfreq1, kgenfreq2, imode, \\\n      iminfrq, iprd",
                    "opcodeName": "harmon",
                    "functionalSynopsis": "ares = **harmon:a**(asig, kestfrq, kmaxvar, kgenfreq1, kgenfreq2, imode, \\)"
                },
                {
                    "description": "Analyze an audio input and generate harmonizing voices in\n      synchrony with formants preserved.",
                    "synopsis": "ares **harmon2** asig, koct, kfrq1, kfrq2, icpsmode, ilowest[, ipolarity]\nares **harmon3** asig, koct, kfrq1, \\\n    kfrq2, kfrq3, icpsmode, ilowest[, ipolarity]\nares **harmon4** asig, koct, kfrq1, \\\n    kfrq2, kfrq3, kfrq4, icpsmode, ilowest[, ipolarity]",
                    "opcodeName": "harmon2",
                    "functionalSynopsis": "ares = **harmon2:a**(asig, koct, kfrq1, kfrq2, icpsmode, ilowest[, ipolarity])\nares = **harmon3:a**(asig, koct, kfrq1, \\)\nares = **harmon4:a**(asig, koct, kfrq1, \\)"
                },
                {
                    "description": "First-order allpass filters arranged in a series.",
                    "synopsis": "ares **phaser1** asig, kfreq, kord, kfeedback [, iskip]",
                    "opcodeName": "phaser1",
                    "functionalSynopsis": "ares = **phaser1:a**(asig, kfreq, kord, kfeedback [, iskip])"
                },
                {
                    "description": "Second-order allpass filters arranged in a series.",
                    "synopsis": "ares **phaser2** asig, kfreq, kq, kord, kmode, ksep, kfeedback",
                    "opcodeName": "phaser2",
                    "functionalSynopsis": "ares = **phaser2:a**(asig, kfreq, kq, kord, kmode, ksep, kfeedback)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Standard Filters",
            "opcodes": [
                {
                    "description": "A hi-pass filter whose transfer functions are the complements of the",
                    "synopsis": "ares **atone** asig, khp [, iskip]",
                    "opcodeName": "atone",
                    "functionalSynopsis": "ares = **atone:a**(asig, khp [, iskip])"
                },
                {
                    "description": "Emulates a stack of filters using the atone opcode.",
                    "synopsis": "ares **atonex** asig, khp [, inumlayer] [, iskip]\nares **atonex** asig, ahp [, inumlayer] [, iskip]",
                    "opcodeName": "atonex",
                    "functionalSynopsis": "ares = **atonex:a**(asig, khp [, inumlayer] [, iskip])\nares = **atonex:a**(asig, ahp [, inumlayer] [, iskip])"
                },
                {
                    "description": "A sweepable general purpose biquadratic digital filter.",
                    "synopsis": "ares **biquad** asig, kb0, kb1, kb2, ka0, ka1, ka2 [, iskip]",
                    "opcodeName": "biquad",
                    "functionalSynopsis": "ares = **biquad:a**(asig, kb0, kb1, kb2, ka0, ka1, ka2 [, iskip])"
                },
                {
                    "description": "A sweepable general purpose biquadratic digital filter with a-rate parameters.",
                    "synopsis": "ares **biquada** asig, ab0, ab1, ab2, aa0, aa1, aa2 [, iskip]",
                    "opcodeName": "biquada",
                    "functionalSynopsis": "ares = **biquada:a**(asig, ab0, ab1, ab2, aa0, aa1, aa2 [, iskip])"
                },
                {
                    "description": "Runge-Kutte numerical simulation of the Moog analog resonant filter.",
                    "synopsis": "asig **bob** ain, xcf, xres, xsat [, iosamps, istor]",
                    "opcodeName": "bob",
                    "functionalSynopsis": "asig = **bob:a**(ain, xcf, xres, xsat [, iosamps, istor])"
                },
                {
                    "description": "Same as the butterbp opcode.",
                    "synopsis": "ares **butbp** asig, kfreq, kband [, iskip]",
                    "opcodeName": "butbp",
                    "functionalSynopsis": "ares = **butbp:a**(asig, kfreq, kband [, iskip])"
                },
                {
                    "description": "Same as the butterbr opcode.",
                    "synopsis": "ares **butbr** asig, kfreq, kband [, iskip]",
                    "opcodeName": "butbr",
                    "functionalSynopsis": "ares = **butbr:a**(asig, kfreq, kband [, iskip])"
                },
                {
                    "description": "Same as the butterhp opcode.",
                    "synopsis": "ares **buthp** asig, kfreq [, iskip]\nares **buthp** asig, afreq [, iskip]",
                    "opcodeName": "buthp",
                    "functionalSynopsis": "ares = **buthp:a**(asig, kfreq [, iskip])\nares = **buthp:a**(asig, afreq [, iskip])"
                },
                {
                    "description": "Same as the butterlp opcode.",
                    "synopsis": "ares **butlp** asig, kfreq [, iskip]\nares **butlp** asig, afreq [, iskip]",
                    "opcodeName": "butlp",
                    "functionalSynopsis": "ares = **butlp:a**(asig, kfreq [, iskip])\nares = **butlp:a**(asig, afreq [, iskip])"
                },
                {
                    "description": "A band-pass Butterworth filter.",
                    "synopsis": "ares **butterbp** asig, xfreq, xband [, iskip]",
                    "opcodeName": "butterbp",
                    "functionalSynopsis": "ares = **butterbp:a**(asig, xfreq, xband [, iskip])"
                },
                {
                    "description": "A band-reject Butterworth filter.",
                    "synopsis": "ares **butterbr** asig, xfreq, xband [, iskip]",
                    "opcodeName": "butterbr",
                    "functionalSynopsis": "ares = **butterbr:a**(asig, xfreq, xband [, iskip])"
                },
                {
                    "description": "A high-pass Butterworth filter.",
                    "synopsis": "ares **butterhp** asig, kfreq [, iskip]\nares **butterhp** asig, afreq [, iskip]",
                    "opcodeName": "butterhp",
                    "functionalSynopsis": "ares = **butterhp:a**(asig, kfreq [, iskip])\nares = **butterhp:a**(asig, afreq [, iskip])"
                },
                {
                    "description": "A low-pass Butterworth filter.",
                    "synopsis": "ares **butterlp** asig, kfreq [, iskip]\nares **butterlp** asig, afreq [, iskip]",
                    "opcodeName": "butterlp",
                    "functionalSynopsis": "ares = **butterlp:a**(asig, kfreq [, iskip])\nares = **butterlp:a**(asig, afreq [, iskip])"
                },
                {
                    "description": "Implements low-pass and high-pass filters of different styles.",
                    "synopsis": "ares **clfilt** asig, kfreq, itype, inpol [, ikind] [, ipbr] [, isba] [, iskip]",
                    "opcodeName": "clfilt",
                    "functionalSynopsis": "ares = **clfilt:a**(asig, kfreq, itype, inpol [, ikind] [, ipbr] [, isba] [, iskip])"
                },
                {
                    "description": "Zero-delay feedback implementation of 4 pole diode ladder filter.",
                    "synopsis": "asig **diode_ladder** ain, xcf, xk [, inlp, isaturation, istor]",
                    "opcodeName": "diode_ladder",
                    "functionalSynopsis": "asig = **diode_ladder:a**(ain, xcf, xk [, inlp, isaturation, istor])"
                },
                {
                    "description": "A fast and robust method for approximating sound propagation, achieving convincing Doppler shifts without having to solve equations.",
                    "synopsis": "ashifted **doppler** asource, ksourceposition, kmicposition [, isoundspeed, ifiltercutoff]",
                    "opcodeName": "doppler",
                    "functionalSynopsis": "ashifted = **doppler:a**(asource, ksourceposition, kmicposition [, isoundspeed, ifiltercutoff])"
                },
                {
                    "description": "Zero-delay feedback implementation of Korg35 resonant high-pass filter.",
                    "synopsis": "asig **K35_hpf** ain, xcf, xQ [, inlp, isaturation, istor]",
                    "opcodeName": "K35_hpf",
                    "functionalSynopsis": "asig = **K35_hpf:a**(ain, xcf, xQ [, inlp, isaturation, istor])"
                },
                {
                    "description": "Zero-delay feedback implementation of Korg35 resonant low-pass filter.",
                    "synopsis": "asig **K35_lpf** ain, xcf, xQ [, inlp, isaturation, istor]",
                    "opcodeName": "K35_lpf",
                    "functionalSynopsis": "asig = **K35_lpf:a**(ain, xcf, xQ [, inlp, isaturation, istor])"
                },
                {
                    "description": "A median filter, a variant FIR lowpass filter.",
                    "synopsis": "ares **median** asig, ksize, imaxsize [, iskip]",
                    "opcodeName": "median",
                    "functionalSynopsis": "ares = **median:a**(asig, ksize, imaxsize [, iskip])"
                },
                {
                    "description": "A median filter, a variant FIR lowpass filter.",
                    "synopsis": "kres **mediank** kin, ksize, imaxsize [, iskip]",
                    "opcodeName": "mediank",
                    "functionalSynopsis": "kres = **mediank:k**(kin, ksize, imaxsize [, iskip])"
                },
                {
                    "description": "A filter that simulates a mass-spring-damper system",
                    "synopsis": "aout **mode** ain, xfreq, xQ [, iskip]",
                    "opcodeName": "mode",
                    "functionalSynopsis": "aout = **mode:a**(ain, xfreq, xQ [, iskip])"
                },
                {
                    "description": "A first-order recursive low-pass filter with variable frequency response.",
                    "synopsis": "ares **tone** asig, khp [, iskip]",
                    "opcodeName": "tone",
                    "functionalSynopsis": "ares = **tone:a**(asig, khp [, iskip])"
                },
                {
                    "description": "Emulates a stack of filters using the tone opcode.",
                    "synopsis": "ares **tonex**  asig, khp [, inumlayer] [, iskip]\nares **tonex**  asig, ahp [, inumlayer] [, iskip]",
                    "opcodeName": "tonex",
                    "functionalSynopsis": "ares = **tonex:a**( asig, khp [, inumlayer] [, iskip])\nares = **tonex:a**( asig, ahp [, inumlayer] [, iskip])"
                },
                {
                    "description": "Zero-delay feedback implementation of 1 pole filter.",
                    "synopsis": "asig **zdf_1pole** ain, xcf [, kmode, istor]",
                    "opcodeName": "zdf_1pole",
                    "functionalSynopsis": "asig = **zdf_1pole:a**(ain, xcf [, kmode, istor])"
                },
                {
                    "description": "Zero-delay feedback implementation of 1 pole filter with multimode output.",
                    "synopsis": "alp, ahp **zdf_1pole_mode** ain, xcf [, istor]",
                    "opcodeName": "zdf_1pole_mode",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Zero-delay feedback implementation of 2 pole filter.",
                    "synopsis": "asig **zdf_2pole** ain, xcf, xQ [, kmode, istor]",
                    "opcodeName": "zdf_2pole",
                    "functionalSynopsis": "asig = **zdf_2pole:a**(ain, xcf, xQ [, kmode, istor])"
                },
                {
                    "description": "Zero-delay feedback implementation of 2 pole filter with multimode output.",
                    "synopsis": "alp, abp, ahp **zdf_2pole_mode** ain, xcf, Q [, istor]",
                    "opcodeName": "zdf_2pole_mode",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Zero-delay feedback implementation of 4 pole ladder filter.",
                    "synopsis": "asig **zdf_ladder** ain, xcf, xQ [, istor]",
                    "opcodeName": "zdf_ladder",
                    "functionalSynopsis": "asig = **zdf_ladder:a**(ain, xcf, xQ [, istor])"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Standard Filters:Resonant",
            "opcodes": [
                {
                    "description": "A notch filter whose transfer functions are the complements of\n      the reson opcode.",
                    "synopsis": "ares **areson** asig, kcf, kbw [, iscl] [, iskip]\nares **areson** asig, acf, kbw [, iscl] [, iskip]\nares **areson** asig, kcf, abw [, iscl] [, iskip]\nares **areson** asig, acf, abw [, iscl] [, iskip]",
                    "opcodeName": "areson",
                    "functionalSynopsis": "ares = **areson:a**(asig, kcf, kbw [, iscl] [, iskip])\nares = **areson:a**(asig, acf, kbw [, iscl] [, iskip])\nares = **areson:a**(asig, kcf, abw [, iscl] [, iskip])\nares = **areson:a**(asig, acf, abw [, iscl] [, iskip])"
                },
                {
                    "description": "A second-order multi-mode filter.",
                    "synopsis": "ares **bqrez** asig, xfco, xres [, imode] [, iskip]",
                    "opcodeName": "bqrez",
                    "functionalSynopsis": "ares = **bqrez:a**(asig, xfco, xres [, imode] [, iskip])"
                },
                {
                    "description": "A resonant lowpass filter.",
                    "synopsis": "ares **lowpass2** asig, kcf, kq [, iskip]",
                    "opcodeName": "lowpass2",
                    "functionalSynopsis": "ares = **lowpass2:a**(asig, kcf, kq [, iskip])"
                },
                {
                    "description": "Another resonant lowpass filter.",
                    "synopsis": "ares **lowres** asig, xcutoff, xresonance [, iskip]",
                    "opcodeName": "lowres",
                    "functionalSynopsis": "ares = **lowres:a**(asig, xcutoff, xresonance [, iskip])"
                },
                {
                    "description": "Simulates layers of serially connected resonant lowpass filters.",
                    "synopsis": "ares **lowresx** asig, xcutoff, xresonance [, inumlayer] [, iskip]",
                    "opcodeName": "lowresx",
                    "functionalSynopsis": "ares = **lowresx:a**(asig, xcutoff, xresonance [, inumlayer] [, iskip])"
                },
                {
                    "description": "A 3-pole sweepable resonant lowpass filter.",
                    "synopsis": "ares **lpf18** asig, xfco, xres, xdist [, iskip]",
                    "opcodeName": "lpf18",
                    "functionalSynopsis": "ares = **lpf18:a**(asig, xfco, xres, xdist [, iskip])"
                },
                {
                    "description": "Moog ladder lowpass filter.",
                    "synopsis": "asig **moogladder** ain, kcf, kres[, istor]\nasig **moogladder** ain, acf, kres[, istor]\nasig **moogladder** ain, kcf, ares[, istor]\nasig **moogladder** ain, acf, ares[, istor]",
                    "opcodeName": "moogladder",
                    "functionalSynopsis": "asig = **moogladder:a**(ain, kcf, kres[, istor])\nasig = **moogladder:a**(ain, acf, kres[, istor])\nasig = **moogladder:a**(ain, kcf, ares[, istor])\nasig = **moogladder:a**(ain, acf, ares[, istor])"
                },
                {
                    "description": "Moog ladder lowpass filter.",
                    "synopsis": "asig **moogladder2** ain, kcf, kres[, istor]\nasig **moogladder2** ain, acf, kres[, istor]\nasig **moogladder2** ain, kcf, ares[, istor]\nasig **moogladder2** ain, acf, ares[, istor]",
                    "opcodeName": "moogladder2",
                    "functionalSynopsis": "asig = **moogladder2:a**(ain, kcf, kres[, istor])\nasig = **moogladder2:a**(ain, acf, kres[, istor])\nasig = **moogladder2:a**(ain, kcf, ares[, istor])\nasig = **moogladder2:a**(ain, acf, ares[, istor])"
                },
                {
                    "description": "A digital emulation of the Moog diode ladder filter configuration.",
                    "synopsis": "ares **moogvcf** asig, xfco, xres [,iscale, iskip]",
                    "opcodeName": "moogvcf",
                    "functionalSynopsis": "ares = **moogvcf:a**(asig, xfco, xres [,iscale, iskip])"
                },
                {
                    "description": "A digital emulation of the Moog diode ladder filter configuration.",
                    "synopsis": "ares **moogvcf2** asig, xfco, xres [,iscale, iskip]",
                    "opcodeName": "moogvcf2",
                    "functionalSynopsis": "ares = **moogvcf2:a**(asig, xfco, xres [,iscale, iskip])"
                },
                {
                    "description": "Moog voltage-controlled highpass filter emulation.",
                    "synopsis": "asig **mvchpf** ain, xcf[, istor]",
                    "opcodeName": "mvchpf",
                    "functionalSynopsis": "asig = **mvchpf:a**(ain, xcf[, istor])"
                },
                {
                    "description": "Moog voltage-controlled lowpass filter emulation.",
                    "synopsis": "asig **mvclpf1** ain, xcf, xres[,istor]",
                    "opcodeName": "mvclpf1",
                    "functionalSynopsis": "asig = **mvclpf1:a**(ain, xcf, xres[,istor])"
                },
                {
                    "description": "Moog voltage-controlled lowpass filter emulation.",
                    "synopsis": "asig **mvclpf2** ain, xcf, xres[, istor]",
                    "opcodeName": "mvclpf2",
                    "functionalSynopsis": "asig = **mvclpf2:a**(ain, xcf, xres[, istor])"
                },
                {
                    "description": "Moog voltage-controlled lowpass filter emulation.",
                    "synopsis": "asig **mvclpf3** ain, xcf, xres[, istor]",
                    "opcodeName": "mvclpf3",
                    "functionalSynopsis": "asig = **mvclpf3:a**(ain, xcf, xres[, istor])"
                },
                {
                    "description": "Moog voltage-controlled lowpass filter emulation.",
                    "synopsis": "asig1,asig2,asig3,asig4 **mvclpf4** ain, xcf, xres[, istor]",
                    "opcodeName": "mvclpf4",
                    "functionalSynopsis": "asig1,asig2,asig3,asig4 = **mvclpf4:a**(ain, xcf, xres[, istor])"
                },
                {
                    "description": "A second-order resonant filter.",
                    "synopsis": "ares **reson** asig, xcf, xbw [, iscl] [, iskip]",
                    "opcodeName": "reson",
                    "functionalSynopsis": "ares = **reson:a**(asig, xcf, xbw [, iscl] [, iskip])"
                },
                {
                    "description": "A bandpass filter with variable frequency response.",
                    "synopsis": "ares **resonr** asig, xcf, xbw [, iscl] [, iskip]",
                    "opcodeName": "resonr",
                    "functionalSynopsis": "ares = **resonr:a**(asig, xcf, xbw [, iscl] [, iskip])"
                },
                {
                    "description": "Emulates a stack of filters using the reson opcode.",
                    "synopsis": "ares **resonx** asig, xcf, xbw [, inumlayer] [, iscl] [, iskip]",
                    "opcodeName": "resonx",
                    "functionalSynopsis": "ares = **resonx:a**(asig, xcf, xbw [, inumlayer] [, iscl] [, iskip])"
                },
                {
                    "description": "A bank of second-order bandpass filters, connected in parallel.",
                    "synopsis": "ares **resony** asig, kbf, kbw, inum, ksep [, isepmode] [, iscl] [, iskip]",
                    "opcodeName": "resony",
                    "functionalSynopsis": "ares = **resony:a**(asig, kbf, kbw, inum, ksep [, isepmode] [, iscl] [, iskip])"
                },
                {
                    "description": "A bandpass filter with variable frequency response.",
                    "synopsis": "ares **resonz** asig, xcf, xbw [, iscl] [, iskip]",
                    "opcodeName": "resonz",
                    "functionalSynopsis": "ares = **resonz:a**(asig, xcf, xbw [, iscl] [, iskip])"
                },
                {
                    "description": "A resonant low-pass filter.",
                    "synopsis": "ares **rezzy** asig, xfco, xres [, imode, iskip]",
                    "opcodeName": "rezzy",
                    "functionalSynopsis": "ares = **rezzy:a**(asig, xfco, xres [, imode, iskip])"
                },
                {
                    "description": "Sallen-Key filter.",
                    "synopsis": "asig **skf** asig, xcf, xK[, ihp, istor]",
                    "opcodeName": "skf",
                    "functionalSynopsis": "asig = **skf:a**(asig, xcf, xK[, ihp, istor])"
                },
                {
                    "description": "Steiner-Parker filter.",
                    "synopsis": "asig **spf** alp,ahp,abp, xcf, xR[, istor]",
                    "opcodeName": "spf",
                    "functionalSynopsis": "asig = **spf:a**(alp,ahp,abp, xcf, xR[, istor])"
                },
                {
                    "description": "State-variable filter.",
                    "synopsis": "ahp,alp,abp,abr **statevar** ain, xcf, xq [, iosamps, istor]",
                    "opcodeName": "statevar",
                    "functionalSynopsis": "ahp,alp,abp,abr = **statevar:a**(ain, xcf, xq [, iosamps, istor])"
                },
                {
                    "description": "A resonant second order filter, with simultaneous lowpass, highpass and bandpass outputs.",
                    "synopsis": "alow, ahigh, aband **svfilter**  asig, kcf, kq [, iscl] [, iskip]",
                    "opcodeName": "svfilter",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Non-linear state variable filter",
                    "synopsis": "ahp,alp,abp,abr **svn** asig, xcf, xQ,\n    kdrive[, ifn,inm,imx, istor]",
                    "opcodeName": "svn",
                    "functionalSynopsis": "ahp,alp,abp,abr = **svn:a**(asig, xcf, xQ,)"
                },
                {
                    "description": "Models some of the filter characteristics of a Roland TB303 voltage-controlled filter.",
                    "synopsis": "ares **tbvcf** asig, xfco, xres, kdist, kasym [, iskip]",
                    "opcodeName": "tbvcf",
                    "functionalSynopsis": "ares = **tbvcf:a**(asig, xfco, xres, kdist, kasym [, iskip])"
                },
                {
                    "description": "Resonant 4pole linear lowpass filter",
                    "synopsis": "asig **vclpf** ain, xcf, xres[, istor]",
                    "opcodeName": "vclpf",
                    "functionalSynopsis": "asig = **vclpf:a**(ain, xcf, xres[, istor])"
                },
                {
                    "description": "A bank of filters in which the cutoff frequency can be separated under user control.",
                    "synopsis": "ares **vlowres** asig, kfco, kres, iord, ksep",
                    "opcodeName": "vlowres",
                    "functionalSynopsis": "ares = **vlowres:a**(asig, kfco, kres, iord, ksep)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Standard Filters:Control",
            "opcodes": [
                {
                    "description": "A notch filter whose transfer functions are the complements of the reson opcode.",
                    "synopsis": "kres **aresonk** ksig, kcf, kbw [, iscl] [, iskip]",
                    "opcodeName": "aresonk",
                    "functionalSynopsis": "kres = **aresonk:k**(ksig, kcf, kbw [, iscl] [, iskip])"
                },
                {
                    "description": "A hi-pass filter whose transfer functions are the complements of the",
                    "synopsis": "kres **atonek** ksig, khp [, iskip]",
                    "opcodeName": "atonek",
                    "functionalSynopsis": "kres = **atonek:k**(ksig, khp [, iskip])"
                },
                {
                    "description": "Exponential Lag",
                    "synopsis": "aout **lag** ain, klagtime [, initialvalue]\nkout **lag** kin, klagtime [, initialvalue]",
                    "opcodeName": "lag",
                    "functionalSynopsis": "aout = **lag:a**(ain, klagtime [, initialvalue])\nkout = **lag:k**(kin, klagtime [, initialvalue])"
                },
                {
                    "description": "Exponential Lag",
                    "synopsis": "aout **lagud** ain, klagup, klagdown [, initialvalue]\nkout **lagud** kin, klagup, klagdown [, initialvalue]",
                    "opcodeName": "lagud",
                    "functionalSynopsis": "aout = **lagud:a**(ain, klagup, klagdown [, initialvalue])\nkout = **lagud:k**(kin, klagup, klagdown [, initialvalue])"
                },
                {
                    "description": "Generate glissandos starting from a control signal.",
                    "synopsis": "kres **lineto** ksig, ktime",
                    "opcodeName": "lineto",
                    "functionalSynopsis": "kres = **lineto:k**(ksig, ktime)"
                },
                {
                    "description": "Applies portamento to a step-valued control signal.",
                    "synopsis": "kres **port** ksig, ihtim [, isig]",
                    "opcodeName": "port",
                    "functionalSynopsis": "kres = **port:k**(ksig, ihtim [, isig])"
                },
                {
                    "description": "Applies portamento to a step-valued control signal.",
                    "synopsis": "kres **portk** ksig, khtim [, isig]",
                    "opcodeName": "portk",
                    "functionalSynopsis": "kres = **portk:k**(ksig, khtim [, isig])"
                },
                {
                    "description": "A second-order resonant filter.",
                    "synopsis": "kres **resonk** ksig, kcf, kbw [, iscl] [, iskip]",
                    "opcodeName": "resonk",
                    "functionalSynopsis": "kres = **resonk:k**(ksig, kcf, kbw [, iscl] [, iskip])"
                },
                {
                    "description": "Control signal resonant filter stack.",
                    "synopsis": "kres **resonxk** ksig, kcf, kbw[, inumlayer, iscl, istor]",
                    "opcodeName": "resonxk",
                    "functionalSynopsis": "kres = **resonxk:k**(ksig, kcf, kbw[, inumlayer, iscl, istor])"
                },
                {
                    "description": "Exponential Lag (DEPRECATED)",
                    "synopsis": "aout **sc_lag** ain, klagtime [, initialvalue]\nkout **sc_lag** kin, klagtime [, initialvalue]",
                    "opcodeName": "sc_lag",
                    "functionalSynopsis": "aout = **sc_lag:a**(ain, klagtime [, initialvalue])\nkout = **sc_lag:k**(kin, klagtime [, initialvalue])"
                },
                {
                    "description": "Exponential Lag (Deprecated)",
                    "synopsis": "aout **sc_lagud** ain, klagup, klagdown [, initialvalue]\nkout **sc_lagud** kin, klagup, klagdown [, initialvalue]",
                    "opcodeName": "sc_lagud",
                    "functionalSynopsis": "aout = **sc_lagud:a**(ain, klagup, klagdown [, initialvalue])\nkout = **sc_lagud:k**(kin, klagup, klagdown [, initialvalue])"
                },
                {
                    "description": "Timed trigger (Replaced by trighold)",
                    "synopsis": "aout **sc_trig** ain, kdur\nkout **sc_trig** kin, kdur",
                    "opcodeName": "sc_trig",
                    "functionalSynopsis": "aout = **sc_trig:a**(ain, kdur)\nkout = **sc_trig:k**(kin, kdur)"
                },
                {
                    "description": "Generate glissandos starting from a control signal.",
                    "synopsis": "kres **tlineto** ksig, ktime, ktrig",
                    "opcodeName": "tlineto",
                    "functionalSynopsis": "kres = **tlineto:k**(ksig, ktime, ktrig)"
                },
                {
                    "description": "A first-order recursive low-pass filter with variable frequency response.",
                    "synopsis": "kres **tonek** ksig, khp [, iskip]",
                    "opcodeName": "tonek",
                    "functionalSynopsis": "kres = **tonek:k**(ksig, khp [, iskip])"
                },
                {
                    "description": "Timed trigger, holds a value for a given time",
                    "synopsis": "aout **trighold** ain, kdur\nkout **trighold** kin, kdur",
                    "opcodeName": "trighold",
                    "functionalSynopsis": "aout = **trighold:a**(ain, kdur)\nkout = **trighold:k**(kin, kdur)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Specialized Filters",
            "opcodes": [
                {
                    "description": "A DC blocking filter.",
                    "synopsis": "ares **dcblock** ain [, igain]",
                    "opcodeName": "dcblock",
                    "functionalSynopsis": "ares = **dcblock:a**(ain [, igain])"
                },
                {
                    "description": "A DC blocking filter.",
                    "synopsis": "ares **dcblock2** ain [, iorder] [, iskip]",
                    "opcodeName": "dcblock2",
                    "functionalSynopsis": "ares = **dcblock2:a**(ain [, iorder] [, iskip])"
                },
                {
                    "description": "Equalizer filter",
                    "synopsis": "asig **eqfil** ain, kcf, kbw, kgain[, istor]",
                    "opcodeName": "eqfil",
                    "functionalSynopsis": "asig = **eqfil:a**(ain, kcf, kbw, kgain[, istor])"
                },
                {
                    "description": "A non-linear filter system to excite the signal.",
                    "synopsis": "ares **exciter** asig, kfreq, kceil, kharmonics, kblend",
                    "opcodeName": "exciter",
                    "functionalSynopsis": "ares = **exciter:a**(asig, kfreq, kceil, kharmonics, kblend)"
                },
                {
                    "description": "Performs filtering using a transposed form-II digital filter lattice with no time-varying control.",
                    "synopsis": "ares **filter2** asig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN\nkres **filter2** ksig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN",
                    "opcodeName": "filter2",
                    "functionalSynopsis": "ares = **filter2:a**(asig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN)\nkres = **filter2:k**(ksig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN)"
                },
                {
                    "description": "AM/FM analysis from quadrature signal.",
                    "synopsis": "am, af **fmanal** are, aim",
                    "opcodeName": "fmanal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Formant filter.",
                    "synopsis": "asig **fofilter** ain, xcf, xris, xdec[, istor]",
                    "opcodeName": "fofilter",
                    "functionalSynopsis": "asig = **fofilter:a**(ain, xcf, xris, xdec[, istor])"
                },
                {
                    "description": "Apply a gammatone filter to an audio signal.",
                    "synopsis": "aout **gtf** ain, kfreq, idecay[, iorder, iphase]",
                    "opcodeName": "gtf",
                    "functionalSynopsis": "aout = **gtf:a**(ain, kfreq, idecay[, iorder, iphase])"
                },
                {
                    "description": "A Hilbert transformer.",
                    "synopsis": "ar1, ar2 **hilbert** asig",
                    "opcodeName": "hilbert",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A Hilbert transformer.",
                    "synopsis": "ar1, ar2 **hilbert2** asig, ifftsize, ihopsize",
                    "opcodeName": "hilbert2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A filter with pronounced resonance and controllable decay time.",
                    "synopsis": "aout **mvmfilter** ain, xfreq, xTau [, iskip]",
                    "opcodeName": "mvmfilter",
                    "functionalSynopsis": "aout = **mvmfilter:a**(ain, xfreq, xTau [, iskip])"
                },
                {
                    "description": "A filter with a non-linear effect.",
                    "synopsis": "ares **nlfilt** ain, ka, kb, kd, kC, kL",
                    "opcodeName": "nlfilt",
                    "functionalSynopsis": "ares = **nlfilt:a**(ain, ka, kb, kd, kC, kL)"
                },
                {
                    "description": "A filter with a non-linear effect and blowup protection.",
                    "synopsis": "ares **nlfilt2** ain, ka, kb, kd, kC, kL",
                    "opcodeName": "nlfilt2",
                    "functionalSynopsis": "ares = **nlfilt2:a**(ain, ka, kb, kd, kC, kL)"
                },
                {
                    "description": "Implementation of Zoelzer's parametric equalizer filters.",
                    "synopsis": "ares **pareq** asig, kc, kv, kq [, imode] [, iskip]",
                    "opcodeName": "pareq",
                    "functionalSynopsis": "ares = **pareq:a**(asig, kc, kv, kq [, imode] [, iskip])"
                },
                {
                    "description": "Parametric equalizer and filter opcode with 7 filter types, based\n      on algorithm by Robert Bristow-Johnson.",
                    "synopsis": "ar **rbjeq** asig, kfco, klvl, kQ, kS[, imode]",
                    "opcodeName": "rbjeq",
                    "functionalSynopsis": "ar = **rbjeq:a**(asig, kfco, klvl, kQ, kS[, imode])"
                },
                {
                    "description": "Performs filtering using a transposed form-II digital filter lattice with radial pole-shearing and angular pole-warping.",
                    "synopsis": "ares **zfilter2** asig, kdamp, kfreq, iM, iN, ib0, ib1, ..., ibM, \\\n      ia1,ia2, ..., iaN",
                    "opcodeName": "zfilter2",
                    "functionalSynopsis": "ares = **zfilter2:a**(asig, kdamp, kfreq, iM, iN, ib0, ib1, ..., ibM, \\)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Waveguides",
            "opcodes": [
                {
                    "description": "A simple waveguide model consisting of one delay-line and one first-order lowpass filter.",
                    "synopsis": "ares **wguide1** asig, xfreq, kcutoff, kfeedback",
                    "opcodeName": "wguide1",
                    "functionalSynopsis": "ares = **wguide1:a**(asig, xfreq, kcutoff, kfeedback)"
                },
                {
                    "description": "A model of beaten plate consisting of two parallel delay-lines and two first-order lowpass filters.",
                    "synopsis": "ares **wguide2** asig, xfreq1, xfreq2, kcutoff1, kcutoff2, \\\n      kfeedback1, kfeedback2",
                    "opcodeName": "wguide2",
                    "functionalSynopsis": "ares = **wguide2:a**(asig, xfreq1, xfreq2, kcutoff1, kcutoff2, \\)"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Waveshaping",
            "opcodes": [
                {
                    "description": "Efficiently evaluates the sum of Chebyshev polynomials of arbitrary order.",
                    "synopsis": "aout **chebyshevpoly** ain, k0 [, k1 [, k2 [...]]]",
                    "opcodeName": "chebyshevpoly",
                    "functionalSynopsis": "aout = **chebyshevpoly:a**(ain, k0 [, k1 [, k2 [...]]])"
                },
                {
                    "description": "Performs linear clipping on an audio signal or a phasor.",
                    "synopsis": "aout **pdclip** ain, kWidth, kCenter [, ibipolar [, ifullscale]]",
                    "opcodeName": "pdclip",
                    "functionalSynopsis": "aout = **pdclip:a**(ain, kWidth, kCenter [, ibipolar [, ifullscale]])"
                },
                {
                    "description": "Distorts a phasor for reading the two halves of a table at different rates.",
                    "synopsis": "aout **pdhalf** ain, kShapeAmount [, ibipolar [, ifullscale]]",
                    "opcodeName": "pdhalf",
                    "functionalSynopsis": "aout = **pdhalf:a**(ain, kShapeAmount [, ibipolar [, ifullscale]])"
                },
                {
                    "description": "Distorts a phasor for reading two unequal portions of a table in equal periods.",
                    "synopsis": "aout **pdhalfy** ain, kShapeAmount [, ibipolar [, ifullscale]]",
                    "opcodeName": "pdhalfy",
                    "functionalSynopsis": "aout = **pdhalfy:a**(ain, kShapeAmount [, ibipolar [, ifullscale]])"
                },
                {
                    "description": "Waveshapes a signal by raising it to a variable exponent.",
                    "synopsis": "aout **powershape** ain, kShapeAmount [, ifullscale]",
                    "opcodeName": "powershape",
                    "functionalSynopsis": "aout = **powershape:a**(ain, kShapeAmount [, ifullscale])"
                }
            ]
        },
        {
            "category": "Signal Modifiers:Comparators and Accumulators",
            "opcodes": [
                {
                    "description": "Compares audio signals or arrays",
                    "synopsis": "aout **cmp** a1, S_operator, a2\naout **cmp** a1, S_operator, kb\nkOut[] **cmp** kA[], S_operator, kb\nkOut[] **cmp** kA[], S_operator, kB[]\nkOut[] **cmp** k1, S_operator1, kIn[], S_operator2, k2",
                    "opcodeName": "cmp",
                    "functionalSynopsis": "aout = **cmp:a**(a1, S_operator, a2)\naout = **cmp:a**(a1, S_operator, kb)\nkOut[] = **cmp:k**(kA[], S_operator, kb)\nkOut[] = **cmp:k**(kA[], S_operator, kB[])\nkOut[] = **cmp:k**(k1, S_operator1, kIn[], S_operator2, k2)"
                },
                {
                    "description": "Produces a signal that is the maximum of any number of input signals.",
                    "synopsis": "amax **max** ain1, ain2 [, ain3] [, ain4] [...]\nkmax **max** kin1, kin2 [, kin3] [, kin4] [...]\nimax **max** iin1, iin2 [, iin3] [, iin4] [...]",
                    "opcodeName": "max",
                    "functionalSynopsis": "amax = **max:a**(ain1, ain2 [, ain3] [, ain4] [...])\nkmax = **max:k**(kin1, kin2 [, kin3] [, kin4] [...])\nimax = **max:unknown**(iin1, iin2 [, iin3] [, iin4] [...])"
                },
                {
                    "description": "Local maximum (or minimum) value of an incoming asig signal",
                    "synopsis": "knumkout **max_k** asig, ktrig, itype",
                    "opcodeName": "max_k",
                    "functionalSynopsis": "knumkout = **max_k:k**(asig, ktrig, itype)"
                },
                {
                    "description": "Produces a signal that is the maximum of the absolute values of any number of input signals.",
                    "synopsis": "amax **maxabs** ain1, ain2 [, ain3] [, ain4] [...]\nkmax **maxabs** kin1, kin2 [, kin3] [, kin4] [...]",
                    "opcodeName": "maxabs",
                    "functionalSynopsis": "amax = **maxabs:a**(ain1, ain2 [, ain3] [, ain4] [...])\nkmax = **maxabs:k**(kin1, kin2 [, kin3] [, kin4] [...])"
                },
                {
                    "description": "Accumulates the maximum of the absolute values of audio signals.",
                    "synopsis": "**maxabsaccum** aAccumulator, aInput",
                    "opcodeName": "maxabsaccum",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Accumulates the maximum value of audio signals.",
                    "synopsis": "**maxaccum** aAccumulator, aInput",
                    "opcodeName": "maxaccum",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Produces a signal that is the minimum of any number of input signals.",
                    "synopsis": "amin **min** ain1, ain2 [, ain3] [, ain4] [...]\nkmin **min** kin1, kin2 [, kin3] [, kin4] [...]\nimin **min** iin1, iin2 [, iin3] [, iin4] [...]",
                    "opcodeName": "min",
                    "functionalSynopsis": "amin = **min:a**(ain1, ain2 [, ain3] [, ain4] [...])\nkmin = **min:k**(kin1, kin2 [, kin3] [, kin4] [...])\nimin = **min:unknown**(iin1, iin2 [, iin3] [, iin4] [...])"
                },
                {
                    "description": "Produces a signal that is the minimum of the absolute values of any number of input signals.",
                    "synopsis": "amin **minabs** ain1, ain2 [, ain3] [, ain4] [...]\nkmin **minabs** kin1, kin2 [, kin3] [, kin4] [...]",
                    "opcodeName": "minabs",
                    "functionalSynopsis": "amin = **minabs:a**(ain1, ain2 [, ain3] [, ain4] [...])\nkmin = **minabs:k**(kin1, kin2 [, kin3] [, kin4] [...])"
                },
                {
                    "description": "Accumulates the minimum of the absolute values of audio signals.",
                    "synopsis": "**minabsaccum** aAccumulator, aInput",
                    "opcodeName": "minabsaccum",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Accumulates the minimum value of audio signals.",
                    "synopsis": "**minaccum** aAccumulator, aInput",
                    "opcodeName": "minaccum",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Clock Control",
            "opcodes": [
                {
                    "description": "Stops one of a number of internal clocks.",
                    "synopsis": "**clockoff** inum",
                    "opcodeName": "clockoff",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Starts one of a number of internal clocks.",
                    "synopsis": "**clockon** inum",
                    "opcodeName": "clockon",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Conditional Values",
            "opcodes": [
                {
                    "description": "Compares two values for equality.",
                    "synopsis": "(a **==** b **?** v1 **:** v2)",
                    "opcodeName": "==",
                    "functionalSynopsis": "(a = **==:unknown**(b **?** v1 **:** v2))"
                },
                {
                    "description": "Determines if one value is greater than or equal to another.",
                    "synopsis": "(a **&gt;=** b **?** v1 **:** v2)",
                    "opcodeName": "&gt;=",
                    "functionalSynopsis": "(a = **&gt;=:unknown**(b **?** v1 **:** v2))"
                },
                {
                    "description": "Determines if one value is greater than another.",
                    "synopsis": "(a **&gt;**  b **?** v1 **:** v2)",
                    "opcodeName": "&gt;",
                    "functionalSynopsis": "(a = **&gt;:unknown**( b **?** v1 **:** v2))"
                },
                {
                    "description": "Determines if one value is less than or equal to another.",
                    "synopsis": "(a **&lt;=** b **?** v1 **:** v2)",
                    "opcodeName": "&lt;=",
                    "functionalSynopsis": "(a = **&lt;=:unknown**(b **?** v1 **:** v2))"
                },
                {
                    "description": "Determines if one value is less than another.",
                    "synopsis": "(a **&lt;**  b **?** v1 **:** v2)",
                    "opcodeName": "&lt;",
                    "functionalSynopsis": "(a = **&lt;:unknown**( b **?** v1 **:** v2))"
                },
                {
                    "description": "Determines if one value is not equal to another.",
                    "synopsis": "(a **!=** b **?** v1 **:** v2)",
                    "opcodeName": "!=",
                    "functionalSynopsis": "(a = **!=:unknown**(b **?** v1 **:** v2))"
                }
            ]
        },
        {
            "category": "Instrument Control:Compilation",
            "opcodes": [
                {
                    "description": "compiles a new orchestra from an ASCII file",
                    "synopsis": "ires **compilecsd** Sfilename",
                    "opcodeName": "compilecsd",
                    "functionalSynopsis": "ires = **compilecsd:unknown**(Sfilename)"
                },
                {
                    "description": "compiles a new orchestra from an ASCII file",
                    "synopsis": "ires **compileorc** Sfilename",
                    "opcodeName": "compileorc",
                    "functionalSynopsis": "ires = **compileorc:unknown**(Sfilename)"
                },
                {
                    "description": "compiles a new orchestra passed in as an ASCII string",
                    "synopsis": "ires **compilestr** Sorch",
                    "opcodeName": "compilestr",
                    "functionalSynopsis": "ires = **compilestr:unknown**(Sorch)"
                },
                {
                    "description": "Evalstrs evaluates a string containing Csound code, returning a value.",
                    "synopsis": "ires **evalstr** Scode \nkres **evalstr** Scode, ktrig ",
                    "opcodeName": "evalstr",
                    "functionalSynopsis": "ires = **evalstr:unknown**(Scode )\nkres = **evalstr:k**(Scode, ktrig )"
                },
                {
                    "description": "Returns a value from an instrument.",
                    "synopsis": "**return** ival ",
                    "opcodeName": "return",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Duration Control",
            "opcodes": [
                {
                    "description": "Creates a held note.",
                    "synopsis": "**ihold**",
                    "opcodeName": "ihold",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Enables an instrument to turn itself off or to turn an instance of another instrument off.",
                    "synopsis": "**turnoff**\n**turnoff** inst\n**turnoff** knst",
                    "opcodeName": "turnoff",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Turn off instance(s) of other instruments at performance time.",
                    "synopsis": "**turnoff2** kinsno, kmode, krelease\n        \n**turnoff2_i** insno, imode, irelease\n    ",
                    "opcodeName": "turnoff2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Turn off instance(s) of other instruments at performance time in\n      the queue of scheduled events.",
                    "synopsis": "**turnoff3** kinsno\n    ",
                    "opcodeName": "turnoff3",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Activate an instrument for an indefinite time.",
                    "synopsis": "**turnon** insnum [, itime]",
                    "opcodeName": "turnon",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Invocation",
            "opcodes": [
                {
                    "description": "Generates a score event from an instrument.",
                    "synopsis": "**event** &quot;scorechar&quot;, kinsnum, kdelay, kdur, [, kp4] [, kp5] [, ...]\n**event** &quot;scorechar&quot;, &quot;insname&quot;, kdelay, kdur, [, kp4] [, kp5] [, ...]",
                    "opcodeName": "event",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates a score event from an instrument.",
                    "synopsis": "**event_i** &quot;scorechar&quot;, iinsnum, idelay, idur, [, ip4] [, ip5] [, ...]\n**event_i** &quot;scorechar&quot;, &quot;insname&quot;, idelay, idur, [, ip4] [, ip5] [, ...]",
                    "opcodeName": "event_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Mutes/unmutes new instances of a given instrument.",
                    "synopsis": "**mute** insnum [, iswitch]\n**mute** &quot;insname&quot; [, iswitch]",
                    "opcodeName": "mute",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Schedules a new instrument instance, storing the instance handle in a variable.",
                    "synopsis": "iHandle **nstance** insnum, iwhen, idur [, ip4] [, ip5] [...]\niHandle **nstance** &quot;insname&quot;, iwhen, idur [, ip4] [, ip5] [...]",
                    "opcodeName": "nstance",
                    "functionalSynopsis": "iHandle = **nstance:unknown**(insnum, iwhen, idur [, ip4] [, ip5] [...])\niHandle = **nstance:unknown**(&quot;insname&quot;, iwhen, idur [, ip4] [, ip5] [...])"
                },
                {
                    "description": "Read, preprocess and schedule a score from an input string.",
                    "synopsis": "**readscore** Sin ",
                    "opcodeName": "readscore",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Removes the definition of an instrument.",
                    "synopsis": "**remove** insnum",
                    "opcodeName": "remove",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Adds a new score event generated by a k-rate trigger.",
                    "synopsis": "**schedkwhen** ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur \\\n      [, ip4] [, ip5] [...]\n**schedkwhen** ktrigger, kmintim, kmaxnum, &quot;insname&quot;, kwhen, kdur \\\n      [, ip4] [, ip5] [...]",
                    "opcodeName": "schedkwhen",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Similar to schedkwhen but uses a named instrument at init-time.",
                    "synopsis": "**schedkwhennamed** ktrigger, kmintim, kmaxnum, &quot;name&quot;, kwhen, kdur \\\n      [, ip4] [, ip5] [...]",
                    "opcodeName": "schedkwhennamed",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Adds a new score event.",
                    "synopsis": "**schedule** insnum, iwhen, idur [, ip4] [, ip5] [...]\n**schedule** &quot;insname&quot;, iwhen,\n    idur [, ip4] [, ip5] [...]\n**schedule** iPar[]",
                    "opcodeName": "schedule",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Adds a new score event.",
                    "synopsis": "**schedulek** knsnum, kwhen, kdur [, kp4] [, kp5] [...]\n**schedulek** &quot;insname&quot;, kwhen,\n    kdur [, kp4] [, kp5] [...]\n**schedule** kPar[]",
                    "opcodeName": "schedulek",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Adds a new score event.",
                    "synopsis": "**schedwhen** ktrigger, kinsnum, kwhen, kdur [, ip4] [, ip5] [...]\n**schedwhen** ktrigger, &quot;insname&quot;, kwhen, kdur [, ip4] [, ip5] [...]",
                    "opcodeName": "schedwhen",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Issues one or more score line events from an instrument.",
                    "synopsis": "**scoreline** Sin, ktrig",
                    "opcodeName": "scoreline",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Issues one or more score line events from an instrument at i-time.",
                    "synopsis": "**scoreline_i** Sin",
                    "opcodeName": "scoreline_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Program Flow Control",
            "opcodes": [
                {
                    "description": "Conditionally transfer control on every pass.",
                    "synopsis": "**cggoto** condition, label",
                    "opcodeName": "cggoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Conditionally transfer control during the i-time pass.",
                    "synopsis": "**cigoto** condition, label",
                    "opcodeName": "cigoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Conditionally transfer control during the p-time passes.",
                    "synopsis": "**ckgoto** condition, label",
                    "opcodeName": "ckgoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfers control on every pass when a condition is not true.",
                    "synopsis": "**cngoto** condition, label",
                    "opcodeName": "cngoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Executes a block of code when an &quot;if...then&quot; condition is false.",
                    "synopsis": "**else**",
                    "opcodeName": "else",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Defines another &quot;if...then&quot; condition when a &quot;if...then&quot; condition is false.",
                    "synopsis": "**elseif** xa R xb **then**",
                    "opcodeName": "elseif",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Closes a block of code that begins with an &quot;if...then&quot; statement.",
                    "synopsis": "**endif**",
                    "opcodeName": "endif",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfer control on every pass.",
                    "synopsis": "**goto** label",
                    "opcodeName": "goto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Branches conditionally at initialization or during performance time.",
                    "synopsis": "**if** ia R ib **igoto** label\n**if** ka R kb **kgoto** label\n**if** xa R xb **goto** label\n**if** xa R xb **then**",
                    "opcodeName": "if",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfer control during the i-time pass.",
                    "synopsis": "**igoto** label",
                    "opcodeName": "igoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfer control during the performance-time passes.",
                    "synopsis": "**kgoto** label",
                    "opcodeName": "kgoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Looping constructions.",
                    "synopsis": "**loop_ge**  indx, idecr, imin, label\n**loop_ge**  kndx, kdecr, kmin, label",
                    "opcodeName": "loop_ge",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Looping constructions.",
                    "synopsis": "**loop_gt**  indx, idecr, imin, label\n**loop_gt**  kndx, kdecr, kmin, label",
                    "opcodeName": "loop_gt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Looping constructions.",
                    "synopsis": "**loop_le**  indx, incr, imax, label\n**loop_le**  kndx, kncr, kmax, label",
                    "opcodeName": "loop_le",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Looping constructions.",
                    "synopsis": "**loop_lt**  indx, incr, imax, label\n**loop_lt**  kndx, kncr, kmax, label",
                    "opcodeName": "loop_lt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfer control at i-time when a new note is being tied onto a previously held note",
                    "synopsis": "**tigoto** label",
                    "opcodeName": "tigoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Conditional branch during p-time depending on elapsed note time.",
                    "synopsis": "**timout** istrt, idur, label",
                    "opcodeName": "timout",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A syntactic looping construction.",
                    "synopsis": "**until**  condition **do**\n    ... **od**",
                    "opcodeName": "until",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A syntactic looping construction.",
                    "synopsis": "**while**  condition **do**\n    ... **od**",
                    "opcodeName": "while",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Realtime Performance Control",
            "opcodes": [
                {
                    "description": "Returns the number of active instances of an instrument.",
                    "synopsis": "ir **active** insnum [,iopt [,inorel]]\nir **active** Sinsname [,iopt [,inorel]]\nkres **active** kinsnum [,iopt [,inorel]]",
                    "opcodeName": "active",
                    "functionalSynopsis": "ir = **active:unknown**(insnum [,iopt [,inorel]])\nir = **active:unknown**(Sinsname [,iopt [,inorel]])\nkres = **active:k**(kinsnum [,iopt [,inorel]])"
                },
                {
                    "description": "Reports the usage of cpu either total or per core.",
                    "synopsis": "ktot[,kcpu1, kcpu2,...]**cpumeter** ifreq",
                    "opcodeName": "cpumeter",
                    "functionalSynopsis": "ktot[,kcpu1, = **kcpu2,...]cpumeter:k**(ifreq)"
                },
                {
                    "description": "Control allocation of cpu resources on a per-instrument basis, to optimize realtime output.",
                    "synopsis": "**cpuprc** insnum, ipercent\n**cpuprc** Sinsname, ipercent",
                    "opcodeName": "cpuprc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Exit Csound as fast as possible, with no cleaning up.",
                    "synopsis": "**exitnow** [ivalue]",
                    "opcodeName": "exitnow",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Start/stop jack_transport and can optionally relocate the playback head.",
                    "synopsis": "**jacktransport** icommand [, ilocation]",
                    "opcodeName": "jacktransport",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Limits the number of allocations of an instrument.",
                    "synopsis": "**maxalloc** insnum, icount\n**maxalloc** Sinsname, icount",
                    "opcodeName": "maxalloc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates space for instruments but does not run them.",
                    "synopsis": "**prealloc** insnum, icount\n**prealloc** &quot;insname&quot;, icount",
                    "opcodeName": "prealloc",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Initialization and Reinitialization",
            "opcodes": [
                {
                    "description": "Performs a simple assignment.",
                    "synopsis": "ares **=** xarg\nires **=** iarg\nkres **=** karg\nires, ... **=** iarg, ...\nkres, ... **=** karg, ...\ntable [ kval] **=** karg",
                    "opcodeName": "=",
                    "functionalSynopsis": "ares = **=:a**(xarg)\nires = **=:unknown**(iarg)\nkres = **=:k**(karg)"
                },
                {
                    "description": "Puts the value of the i-time expression into a k-, a-rate or t- variable.",
                    "synopsis": "ares **init** iarg\nires **init** iarg\nkres **init** iarg\nares, ...  **init** iarg, ...\nires, ... **init** iarg, ...\nkres, ... **init** iarg, ...\ntab **init** isize[, ival]",
                    "opcodeName": "init",
                    "functionalSynopsis": "ares = **init:a**(iarg)\nires = **init:unknown**(iarg)\nkres = **init:k**(iarg)\ntab = **init:unknown**(isize[, ival])"
                },
                {
                    "description": "Returns the number of a named instrument.",
                    "synopsis": "insno **nstrnum** &quot;name&quot;",
                    "opcodeName": "nstrnum",
                    "functionalSynopsis": "insno = **nstrnum:unknown**(&quot;name&quot;)"
                },
                {
                    "description": "Returns the string of a named instr from its number.",
                    "synopsis": "Sname **nstrstr** insno\nSname **nstrstr** knsno",
                    "opcodeName": "nstrstr",
                    "functionalSynopsis": "Sname = **nstrstr:unknown**(insno)\nSname = **nstrstr:unknown**(knsno)"
                },
                {
                    "description": "Show the value in a given p-field.",
                    "synopsis": "**p**(x) ",
                    "opcodeName": "p",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Assigns a range of p-fields to ivariables.",
                    "synopsis": " ivar1, ... **passign** [istart][, iend\n iarray **passign** [istart][, iend\n karray **passign** [istart][, iend",
                    "opcodeName": "passign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs add and assignment.",
                    "synopsis": "ares **+=** xarg\nires **+=** iarg\nkres **+=** karg\ntable [ kval] **+=** karg",
                    "opcodeName": "+=",
                    "functionalSynopsis": "ares = **+=:a**(xarg)\nires = **+=:unknown**(iarg)\nkres = **+=:k**(karg)"
                },
                {
                    "description": "Defines and initializes numeric arrays at orchestra load time.",
                    "synopsis": "**pset** icon1 [, icon2] [...]",
                    "opcodeName": "pset",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Suspends a performance while a special initialization pass is executed.",
                    "synopsis": "**reinit** label",
                    "opcodeName": "reinit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Transfers control during a reinit pass.",
                    "synopsis": "**rigoto** label",
                    "opcodeName": "rigoto",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Terminates a reinit pass.",
                    "synopsis": "**rireturn**",
                    "opcodeName": "rireturn",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Puts the value of the instrument's internal",
                    "synopsis": "ir **tival**",
                    "opcodeName": "tival",
                    "functionalSynopsis": "ir = **tival:unknown**()"
                }
            ]
        },
        {
            "category": "Instrument Control:Sensing and Control",
            "opcodes": [
                {
                    "description": "Sense on-screen controls.",
                    "synopsis": "kres **button** knum",
                    "opcodeName": "button",
                    "functionalSynopsis": "kres = **button:k**(knum)"
                },
                {
                    "description": "k-rate signal change detector.",
                    "synopsis": "ktrig **changed** kvar1 [, kvar2,..., kvarN]",
                    "opcodeName": "changed",
                    "functionalSynopsis": "ktrig = **changed:k**(kvar1 [, kvar2,..., kvarN])"
                },
                {
                    "description": "k-rate signal change detector.",
                    "synopsis": "ktrig **changed2** kvar1 [, kvar2,..., kvarN]\nktrig **changed2** karr[]\nktrig **changed2** aarr[]",
                    "opcodeName": "changed2",
                    "functionalSynopsis": "ktrig = **changed2:k**(kvar1 [, kvar2,..., kvarN])\nktrig = **changed2:k**(karr[])\nktrig = **changed2:k**(aarr[])"
                },
                {
                    "description": "Sense on-screen controls.",
                    "synopsis": "kres **checkbox** knum",
                    "opcodeName": "checkbox",
                    "functionalSynopsis": "kres = **checkbox:k**(knum)"
                },
                {
                    "description": "Delete a counter.",
                    "synopsis": "kval **cntDelete** icnt",
                    "opcodeName": "cntDelete",
                    "functionalSynopsis": "kval = **cntDelete:k**(icnt)"
                },
                {
                    "description": "Delete a counter.",
                    "synopsis": "ival **cntDelete_i** icnt",
                    "opcodeName": "cntDelete_i",
                    "functionalSynopsis": "ival = **cntDelete_i:unknown**(icnt)"
                },
                {
                    "description": "Create a counter object.",
                    "synopsis": "icnt **cntCreate** [imax, imin, inc]",
                    "opcodeName": "cntCreate",
                    "functionalSynopsis": "icnt = **cntCreate:unknown**([imax, imin, inc])"
                },
                {
                    "description": "Get the number of times a counter has cycled.",
                    "synopsis": "kval **cntCycles** icnt",
                    "opcodeName": "cntCycles",
                    "functionalSynopsis": "kval = **cntCycles:k**(icnt)"
                },
                {
                    "description": "Read current value of a counter object.",
                    "synopsis": "kval **cntRead**icnt",
                    "opcodeName": "cntRead",
                    "functionalSynopsis": "kval = **cntReadicnt:k**()"
                },
                {
                    "description": "Resets a counter object.",
                    "synopsis": "**cntReset**icnt",
                    "opcodeName": "cntReset",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gives the range and increment of a counter.",
                    "synopsis": "kmax, kmin, kinc **cntState**icnt",
                    "opcodeName": "cntState",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Configurable slider controls for realtime user input.",
                    "synopsis": "kres **control** knum",
                    "opcodeName": "control",
                    "functionalSynopsis": "kres = **control:k**(knum)"
                },
                {
                    "description": "Get the next value from a counter.",
                    "synopsis": "kval **count** icnt",
                    "opcodeName": "count",
                    "functionalSynopsis": "kval = **count:k**(icnt)"
                },
                {
                    "description": "Get the next value from a counter.",
                    "synopsis": "ival **count_i** icnt",
                    "opcodeName": "count_i",
                    "functionalSynopsis": "ival = **count_i:unknown**(icnt)"
                },
                {
                    "description": "Envelope follower unit generator.",
                    "synopsis": "ares **follow** asig, idt",
                    "opcodeName": "follow",
                    "functionalSynopsis": "ares = **follow:a**(asig, idt)"
                },
                {
                    "description": "Another controllable envelope extractor.",
                    "synopsis": "ares **follow2** asig, katt, krel",
                    "opcodeName": "follow2",
                    "functionalSynopsis": "ares = **follow2:a**(asig, katt, krel)"
                },
                {
                    "description": "Return Csound settings.",
                    "synopsis": "Svalue **getcfg** iopt",
                    "opcodeName": "getcfg",
                    "functionalSynopsis": "Svalue = **getcfg:unknown**(iopt)"
                },
                {
                    "description": "Reads data from a joystick controller.",
                    "synopsis": "kres **joystick** kdevice ktab",
                    "opcodeName": "joystick",
                    "functionalSynopsis": "kres = **joystick:k**(kdevice ktab)"
                },
                {
                    "description": "Trigger Metronome",
                    "synopsis": "ktrig  **metro**  kfreq [, initphase]",
                    "opcodeName": "metro",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Trigger Metronome with Swing and Accents",
                    "synopsis": "ktrig  **metro2**  kfreq, kswing [, iamp, initphase]",
                    "opcodeName": "metro2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Trigger Metronome with optional gate",
                    "synopsis": "ktrig  **metrobpm**  kfreq [, initphase] [, kgate]",
                    "opcodeName": "metrobpm",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the playback status of MIDI file input.",
                    "synopsis": "ksig  **midifilestatus**",
                    "opcodeName": "midifilestatus",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the current tempo at k-rate, of either the MIDI file (if\n      available) or the score.",
                    "synopsis": "ksig  **miditempo**",
                    "opcodeName": "miditempo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads data from a P5 Glove controller.",
                    "synopsis": "**p5gconnect**",
                    "opcodeName": "p5gconnect",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads data fields from an external P5 Glove.",
                    "synopsis": "kres **p5gdata** kcontrol",
                    "opcodeName": "p5gdata",
                    "functionalSynopsis": "kres = **p5gdata:k**(kcontrol)"
                },
                {
                    "description": "Returns the number of pfields belonging to a note event.",
                    "synopsis": "icount **pcount**",
                    "opcodeName": "pcount",
                    "functionalSynopsis": "icount = **pcount:unknown**()"
                },
                {
                    "description": "Maintains the output equal to the highest absolute value received.",
                    "synopsis": "kres **peak** asig\nkres **peak** ksig",
                    "opcodeName": "peak",
                    "functionalSynopsis": "kres = **peak:k**(asig)\nkres = **peak:k**(ksig)"
                },
                {
                    "description": "Returns the value of a specified pfield.",
                    "synopsis": "ivalue **pindex** ipfieldIndex",
                    "opcodeName": "pindex",
                    "functionalSynopsis": "ivalue = **pindex:unknown**(ipfieldIndex)"
                },
                {
                    "description": "Tracks the pitch of a signal.",
                    "synopsis": "koct, kamp **pitch** asig, iupdte, ilo, ihi, idbthresh [, ifrqs] [, iconf] \\\n      [, istrt] [, iocts] [, iq] [, inptls] [, irolloff] [, iskip]",
                    "opcodeName": "pitch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Follows the pitch of a signal based on the AMDF method.",
                    "synopsis": "kcps, krms **pitchamdf** asig, imincps, imaxcps [, icps] [, imedi] \\\n      [, idowns] [, iexcps] [, irmsmedi]",
                    "opcodeName": "pitchamdf",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Tracks the pitch of a signal.",
                    "synopsis": "acps, alock **plltrack** asig, kd [, kloopf, kloopq, klf, khf, kthresh]",
                    "opcodeName": "plltrack",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Tracks the pitch of a signal.",
                    "synopsis": "kcps, kamp **ptrack** asig, ihopsize[,ipeaks]",
                    "opcodeName": "ptrack",
                    "functionalSynopsis": ""
                },
                {
                    "description": "returns a value stored in the instance of an instrument.",
                    "synopsis": "ival **readscratch**[index]",
                    "opcodeName": "readscratch",
                    "functionalSynopsis": "ival = **readscratch[index]:unknown**()"
                },
                {
                    "description": "Rewinds the playback position of the current score performance.",
                    "synopsis": " **rewindscore**",
                    "opcodeName": "rewindscore",
                    "functionalSynopsis": " = **rewindscore:unknown**()"
                },
                {
                    "description": "Determines the root-mean-square amplitude of an audio signal.",
                    "synopsis": "kres **rms** asig [, ihp] [, iskip]",
                    "opcodeName": "rms",
                    "functionalSynopsis": "kres = **rms:k**(asig [, ihp] [, iskip])"
                },
                {
                    "description": "Same as the sensekey opcode.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the ASCII code of a key that has been pressed.",
                    "synopsis": "kres[, kkeydown] **sensekey**",
                    "opcodeName": "sensekey",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates a trigger signal according to the values stored in a table.",
                    "synopsis": "ktrig_out **seqtime** ktime_unit, kstart, kloop, kinitndx, kfn_times",
                    "opcodeName": "seqtime",
                    "functionalSynopsis": "ktrig_out = **seqtime:k**(ktime_unit, kstart, kloop, kinitndx, kfn_times)"
                },
                {
                    "description": "Generates a trigger signal according to the values stored in a table.",
                    "synopsis": "ktrig_out **seqtime2** ktrig_in, ktime_unit, kstart, kloop, kinitndx, kfn_times",
                    "opcodeName": "seqtime2",
                    "functionalSynopsis": "ktrig_out = **seqtime2:k**(ktrig_in, ktime_unit, kstart, kloop, kinitndx, kfn_times)"
                },
                {
                    "description": "Emulate a hardware sequencer",
                    "synopsis": "kres  **sequ**  irhythm[], iinstr[], idata[], kbpm, klen [, kmode] [, kstep] [, kreset] [, kverbose]\n    \nkres  **sequ**  irhythm[], iinstr[],\n    idata[][], kbpm, klen [, kmode] [, kstep] [, kreset] [, kverbose]\n    ",
                    "opcodeName": "sequ",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Configurable slider controls for realtime user input.",
                    "synopsis": "**setctrl** inum, ival, itype",
                    "opcodeName": "setctrl",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the playback position of the current score performance to a given position.",
                    "synopsis": " **setscorepos** ipos",
                    "opcodeName": "setscorepos",
                    "functionalSynopsis": " = **setscorepos:unknown**(ipos)"
                },
                {
                    "description": "Split a trigger signal",
                    "synopsis": "**splitrig** ktrig, kndx, imaxtics, ifn, kout1 [,kout2,...,koutN]",
                    "opcodeName": "splitrig",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Estimate the tempo of beat patterns in a control signal.",
                    "synopsis": "ktemp **tempest** kin, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, \\\n      istartempo, ifn [, idisprd] [, itweek]",
                    "opcodeName": "tempest",
                    "functionalSynopsis": "ktemp = **tempest:k**(kin, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, \\)"
                },
                {
                    "description": "Apply tempo control to an uninterpreted score.",
                    "synopsis": "**tempo** ktempo, istartempo",
                    "opcodeName": "tempo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads the current value of the tempo.",
                    "synopsis": "kres **tempoval**",
                    "opcodeName": "tempoval",
                    "functionalSynopsis": "kres = **tempoval:k**()"
                },
                {
                    "description": "Time Variant Sequencer",
                    "synopsis": "ktrig  **timedseq**  ktimpnt, ifn, kp1 [,kp2, kp3, ...,kpN]",
                    "opcodeName": "timedseq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Informs when a krate signal crosses a threshold.",
                    "synopsis": "kout **trigger** ksig, kthreshold, kmode",
                    "opcodeName": "trigger",
                    "functionalSynopsis": "kout = **trigger:k**(ksig, kthreshold, kmode)"
                },
                {
                    "description": "Accepts a trigger signal as input and outputs a group of values.",
                    "synopsis": "**trigseq** ktrig_in, kstart, kloop, kinitndx, kfn_values, kout1 [, kout2] [...]",
                    "opcodeName": "trigseq",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Envelope follower unit generator.",
                    "synopsis": "ares **vactrol** asig [iup, idown]",
                    "opcodeName": "vactrol",
                    "functionalSynopsis": "ares = **vactrol:a**(asig [iup, idown])"
                },
                {
                    "description": "Reads data from a number of external Nintendo Wiimote controllers.",
                    "synopsis": "ires **wiiconnect** [itimeout, imaxnum]",
                    "opcodeName": "wiiconnect",
                    "functionalSynopsis": "ires = **wiiconnect:unknown**([itimeout, imaxnum])"
                },
                {
                    "description": "Reads data fields from a number of external Nintendo Wiimote controllers.",
                    "synopsis": "kres **wiidata** kcontrol[, knum]",
                    "opcodeName": "wiidata",
                    "functionalSynopsis": "kres = **wiidata:k**(kcontrol[, knum])"
                },
                {
                    "description": "Sets scaling and range limits for certain Wiimote fields.",
                    "synopsis": " **wiirange** icontrol, iminimum, imaximum[, inum]",
                    "opcodeName": "wiirange",
                    "functionalSynopsis": " = **wiirange:unknown**(icontrol, iminimum, imaximum[, inum])"
                },
                {
                    "description": "Sends data to one of a number of external Nintendo Wiimote controllers.",
                    "synopsis": "kres **wiisend** kcontrol, kvalue[, knum]",
                    "opcodeName": "wiisend",
                    "functionalSynopsis": "kres = **wiisend:k**(kcontrol, kvalue[, knum])"
                },
                {
                    "description": "writes a value into the scratchpad of the instance of an instrument.",
                    "synopsis": "**writescratch**ival[, index]",
                    "opcodeName": "writescratch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sense the cursor position in an output window",
                    "synopsis": "kx, ky **xyin** iprd, ixmin, ixmax, iymin, iymax [, ixinit] [, iyinit]",
                    "opcodeName": "xyin",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Stacks",
            "opcodes": [
                {
                    "description": "Pops values from the global stack.  Deprecated.",
                    "synopsis": "xval1, [xval2, ... , xval31] **pop**\nival1, [ival2, ... , ival31] **pop**",
                    "opcodeName": "pop",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Pops an f-sig frame from the global stack.  Deprecated.",
                    "synopsis": "fsig **pop_f**",
                    "opcodeName": "pop_f",
                    "functionalSynopsis": "fsig = **pop_f:unknown**()"
                },
                {
                    "description": "Pushes a value into the global stack.  Deprecated.",
                    "synopsis": "**push**  xval1, [xval2, ... , xval31]\n**push**  ival1, [ival2, ... , ival31]",
                    "opcodeName": "push",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Pushes an f-sig frame into the global stack.  Deprecated.",
                    "synopsis": "**push_f**  fsig",
                    "opcodeName": "push_f",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initializes the stack.  Deprecated.",
                    "synopsis": "**stack**  iStackSize",
                    "opcodeName": "stack",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Subinstrument Control",
            "opcodes": [
                {
                    "description": "Creates and runs a numbered instrument instance.",
                    "synopsis": "a1, [...] [, a8] **subinstr** instrnum [, p4] [, p5] [...]\na1, [...] [, a8] **subinstr** &quot;insname&quot; [, p4] [, p5] [...]",
                    "opcodeName": "subinstr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates and runs a numbered instrument instance at init-time.",
                    "synopsis": "**subinstrinit** instrnum [, p4] [, p5] [...]\n**subinstrinit** &quot;insname&quot; [, p4] [, p5] [...]",
                    "opcodeName": "subinstrinit",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Instrument Control:Time Reading",
            "opcodes": [
                {
                    "description": "Returns the number seconds since a base date.",
                    "synopsis": "ir[, inano] **date**\nkr[, knano] **date**",
                    "opcodeName": "date",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns as a string the date and time specified.",
                    "synopsis": "Sir **dates** [ itime]",
                    "opcodeName": "dates",
                    "functionalSynopsis": "Sir = **dates:unknown**([ itime])"
                },
                {
                    "description": "Read absolute time in k-rate cycles.",
                    "synopsis": "ires **elapsedcycles**\nkres **elapsedcycles**",
                    "opcodeName": "elapsedcycles",
                    "functionalSynopsis": "ires = **elapsedcycles:unknown**()\nkres = **elapsedcycles:k**()"
                },
                {
                    "description": "Read absolute time in seconds.",
                    "synopsis": "ires **elapsedtime**\nkres **elapsedtime**",
                    "opcodeName": "elapsedtime",
                    "functionalSynopsis": "ires = **elapsedtime:unknown**()\nkres = **elapsedtime:k**()"
                },
                {
                    "description": "Read absolute time in k-rate cycles.",
                    "synopsis": "kres **eventcycles**",
                    "opcodeName": "eventcycles",
                    "functionalSynopsis": "kres = **eventcycles:k**()"
                },
                {
                    "description": "Read absolute time in seconds.",
                    "synopsis": "kres **eventtime**",
                    "opcodeName": "eventtime",
                    "functionalSynopsis": "kres = **eventtime:k**()"
                },
                {
                    "description": "Reads the value of an internal clock.",
                    "synopsis": "ir **readclock** inum",
                    "opcodeName": "readclock",
                    "functionalSynopsis": "ir = **readclock:unknown**(inum)"
                },
                {
                    "description": "Read the real time clock from the operating system.",
                    "synopsis": "ires **rtclock**\nkres **rtclock**",
                    "opcodeName": "rtclock",
                    "functionalSynopsis": "ires = **rtclock:unknown**()\nkres = **rtclock:k**()"
                },
                {
                    "description": "Read absolute time in k-rate cycles.",
                    "synopsis": "kres **timeinstk**",
                    "opcodeName": "timeinstk",
                    "functionalSynopsis": "kres = **timeinstk:k**()"
                },
                {
                    "description": "Read absolute time in seconds.",
                    "synopsis": "kres **timeinsts**",
                    "opcodeName": "timeinsts",
                    "functionalSynopsis": "kres = **timeinsts:k**()"
                },
                {
                    "description": "Read absolute time in k-rate cycles.",
                    "synopsis": "ires **timek**\nkres **timek**",
                    "opcodeName": "timek",
                    "functionalSynopsis": "ires = **timek:unknown**()\nkres = **timek:k**()"
                },
                {
                    "description": "Read absolute time in seconds.",
                    "synopsis": "ires **times**\nkres **times**",
                    "opcodeName": "times",
                    "functionalSynopsis": "ires = **times:unknown**()\nkres = **times:k**()"
                }
            ]
        },
        {
            "category": "Jacko Opcodes",
            "opcodes": [
                {
                    "description": "Receives an audio signal from a Jack port.",
                    "synopsis": "asignal **JackoAudioIn **ScsoundPortName",
                    "opcodeName": "JackoAudioIn ",
                    "functionalSynopsis": "asignal = **JackoAudioIn:a**(**ScsoundPortName)"
                },
                {
                    "description": "Creates an audio connection from a Jack port to Csound.",
                    "synopsis": "**JackoAudioInConnect **SexternalPortName, ScsoundPortName",
                    "opcodeName": "JackoAudioInConnect ",
                    "functionalSynopsis": "**JackoAudioInConnect = **SexternalPortName,:unknown**(ScsoundPortName)"
                },
                {
                    "description": "Sends an audio signal to a Jack port.",
                    "synopsis": "**JackoAudioOut ** ScsoundPortName, asignal",
                    "opcodeName": "JackoAudioOut ",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates an audio connection from Csound to a Jack port.",
                    "synopsis": "**JackoAudioOutConnect **ScsoundPortName, SexternalPortName",
                    "opcodeName": "JackoAudioOutConnect ",
                    "functionalSynopsis": "**JackoAudioOutConnect = **ScsoundPortName,:unknown**(SexternalPortName)"
                },
                {
                    "description": "Turns Jack's freewheeling mode on or off.",
                    "synopsis": "**JackoFreewheel **[ienabled]",
                    "opcodeName": "JackoFreewheel ",
                    "functionalSynopsis": "**JackoFreewheel = **[ienabled]:unknown**()"
                },
                {
                    "description": "Prints information about the Jack system.",
                    "synopsis": "**JackoInfo **",
                    "opcodeName": "JackoInfo ",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initializes Csound as a Jack client.",
                    "synopsis": "**JackoInit **ServerName, SclientName",
                    "opcodeName": "JackoInit ",
                    "functionalSynopsis": "**JackoInit = **ServerName,:unknown**(SclientName)"
                },
                {
                    "description": "Creates a MIDI  connection from a Jack port to Csound.",
                    "synopsis": "**JackoMidiInConnect **SexternalPortName, ScsoundPortName",
                    "opcodeName": "JackoMidiInConnect ",
                    "functionalSynopsis": "**JackoMidiInConnect = **SexternalPortName,:unknown**(ScsoundPortName)"
                },
                {
                    "description": "Sends a MIDI channel message to a Jack port.",
                    "synopsis": "**JackoMidiOut ** ScsoundPortName, kstatus, kchannel, kdata1[, kdata2]",
                    "opcodeName": "JackoMidiOut ",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a MIDI connection from Csound to a Jack port.",
                    "synopsis": "**JackoMidiOutConnect **ScsoundPortName, SexternalPortName",
                    "opcodeName": "JackoMidiOutConnect ",
                    "functionalSynopsis": "**JackoMidiOutConnect = **ScsoundPortName,:unknown**(SexternalPortName)"
                },
                {
                    "description": "Sends a MIDI channel message to a Jack port.",
                    "synopsis": "**JackoNoteOut ** ScsoundPortName, kchannel, kdata1[, kdata2]",
                    "opcodeName": "JackoNoteOut ",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Control the Jack transport.",
                    "synopsis": "**JackoTransport ** kcommand, [kposition]",
                    "opcodeName": "JackoTransport ",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Serial I/O",
            "opcodes": [
                {
                    "description": "Read data from an arduino port using the Csound-Arduino protocol.",
                    "synopsis": "kval **arduinoRead** iPort, iStream[, iSmooth]",
                    "opcodeName": "arduinoRead",
                    "functionalSynopsis": "kval = **arduinoRead:k**(iPort, iStream[, iSmooth])"
                },
                {
                    "description": "Read data from an arduino port using the Csound-Arduino protocol.",
                    "synopsis": "kval **arduinoReadF** iPort, iStream1,\n      iStream2, iStream3",
                    "opcodeName": "arduinoReadF",
                    "functionalSynopsis": "kval = **arduinoReadF:k**(iPort, iStream1,)"
                },
                {
                    "description": "Open a serial port for use with the Arduino protocol.",
                    "synopsis": "iPort **arduinoStart** SPortName [, ibaudRate]",
                    "opcodeName": "arduinoStart",
                    "functionalSynopsis": "iPort = **arduinoStart:unknown**(SPortName [, ibaudRate])"
                },
                {
                    "description": "Close a serial port using Arduino protocol.",
                    "synopsis": " **arduinoStop** iPort",
                    "opcodeName": "arduinoStop",
                    "functionalSynopsis": " = **arduinoStop:unknown**(iPort)"
                },
                {
                    "description": "Open a serial port.",
                    "synopsis": "iPort **serialBegin** SPortName [, ibaudRate]",
                    "opcodeName": "serialBegin",
                    "functionalSynopsis": "iPort = **serialBegin:unknown**(SPortName [, ibaudRate])"
                },
                {
                    "description": "Close a serial port.",
                    "synopsis": " **serialEnd** iPort",
                    "opcodeName": "serialEnd",
                    "functionalSynopsis": " = **serialEnd:unknown**(iPort)"
                },
                {
                    "description": "Flush data from a serial port.",
                    "synopsis": " **serialFlush** iPort",
                    "opcodeName": "serialFlush",
                    "functionalSynopsis": " = **serialFlush:unknown**(iPort)"
                },
                {
                    "description": "Print data from a serial port.",
                    "synopsis": " **serialPrint** iPort",
                    "opcodeName": "serialPrint",
                    "functionalSynopsis": " = **serialPrint:unknown**(iPort)"
                },
                {
                    "description": "Read data from a serial port.",
                    "synopsis": "kByte **serialRead** iPort",
                    "opcodeName": "serialRead",
                    "functionalSynopsis": "kByte = **serialRead:k**(iPort)"
                },
                {
                    "description": "Write data to a serial port.",
                    "synopsis": " **serialWrite** iPort, iByte\n **serialWrite** iPort, kByte\n **serialWrite** iPort, SBytes",
                    "opcodeName": "serialWrite",
                    "functionalSynopsis": " = **serialWrite:unknown**(iPort, iByte)\n = **serialWrite:unknown**(iPort, kByte)\n = **serialWrite:unknown**(iPort, SBytes)"
                },
                {
                    "description": "Write data to a serial port.",
                    "synopsis": " **serialWrite_i** iPort, iByte\n **serialWrite_i** iPort, SBytes",
                    "opcodeName": "serialWrite_i",
                    "functionalSynopsis": " = **serialWrite_i:unknown**(iPort, iByte)\n = **serialWrite_i:unknown**(iPort, SBytes)"
                }
            ]
        },
        {
            "category": "Table Control",
            "opcodes": [
                {
                    "description": "Deletes function table.",
                    "synopsis": "**ftfree** ifno, iwhen",
                    "opcodeName": "ftfree",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generate a score function table from within the orchestra.",
                    "synopsis": "gir **ftgen** ifn, itime, isize, igen, iarga [, iargb ] [...]\ngir **ftgen** ifn, itime, isize, igen, iarray",
                    "opcodeName": "ftgen",
                    "functionalSynopsis": "gir = **ftgen:unknown**(ifn, itime, isize, igen, iarga [, iargb ] [...])\ngir = **ftgen:unknown**(ifn, itime, isize, igen, iarray)"
                },
                {
                    "description": "Generate a score function table from within the orchestra, which is deleted at the end of the note.",
                    "synopsis": "ifno **ftgentmp** ip1, ip2dummy, isize, igen, iarga, iargb, ...",
                    "opcodeName": "ftgentmp",
                    "functionalSynopsis": "ifno = **ftgentmp:unknown**(ip1, ip2dummy, isize, igen, iarga, iargb, ...)"
                },
                {
                    "description": "Fill a string variable with the arguments used to create a function table at k-rate.",
                    "synopsis": "Sdst **getftargs** iftno, ktrig",
                    "opcodeName": "getftargs",
                    "functionalSynopsis": "Sdst = **getftargs:unknown**(iftno, ktrig)"
                },
                {
                    "description": "Loads a sound file into memory for use by",
                    "synopsis": "**sndload** Sfname[, ifmt[, ichns[, isr[, ibas[, iamp[, istrt   \\\n      [, ilpmod[, ilps[, ilpe]]]]]]]]]",
                    "opcodeName": "sndload",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Table Control:Table Queries",
            "opcodes": [
                {
                    "description": "Deprecated.",
                    "synopsis": "karray[] **array** ival1, ival2,.....ivaln",
                    "opcodeName": "array",
                    "functionalSynopsis": "karray[] = **array:k**(ival1, ival2,.....ivaln)"
                },
                {
                    "description": "Generate a vector with initial values.",
                    "synopsis": "karray[] **fillarray** ival1, ival2,.....ivaln\nkarray **fillarray** ival1, ival2,.....ivaln\nkarray **fillarray** kval1, kval2,.....kvaln",
                    "opcodeName": "fillarray",
                    "functionalSynopsis": "karray[] = **fillarray:k**(ival1, ival2,.....ivaln)\nkarray = **fillarray:k**(ival1, ival2,.....ivaln)\nkarray = **fillarray:k**(kval1, kval2,.....kvaln)"
                },
                {
                    "description": "Returns the number of channels in a stored function table.",
                    "synopsis": "**ftchnls**(x) (init-rate args only)",
                    "opcodeName": "ftchnls",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the base frequency of a stored function table in Hz.",
                    "synopsis": "**ftcps**(x) (init-rate args only)",
                    "opcodeName": "ftcps",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Query if a given table exists",
                    "synopsis": "iexists **ftexists** ifn \nkexists **ftexists** kfn / ifn",
                    "opcodeName": "ftexists",
                    "functionalSynopsis": "iexists = **ftexists:unknown**(ifn )\nkexists = **ftexists:k**(kfn / ifn)"
                },
                {
                    "description": "Returns the size of a stored function table.",
                    "synopsis": "**ftlen**(x) (init-rate args only)",
                    "opcodeName": "ftlen",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the loop segment start-time of a stored function table number.",
                    "synopsis": "**ftlptim**(x) (init-rate args only)",
                    "opcodeName": "ftlptim",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the sampling-rate of a stored function table.",
                    "synopsis": "**ftsr**(x) (init-rate args only)",
                    "opcodeName": "ftsr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generate a vector with an arithmetic sequence.",
                    "synopsis": "karray **genarray** kstart, kens[, inc]\niarray **genarray** istart, iens[, inc]",
                    "opcodeName": "genarray",
                    "functionalSynopsis": "karray = **genarray:k**(kstart, kens[, inc])\niarray = **genarray:unknown**(istart, iens[, inc])"
                },
                {
                    "description": "Generate a vector with an arithmetic sequence.",
                    "synopsis": "karray **genarray_i** istart, iend [,inc]",
                    "opcodeName": "genarray_i",
                    "functionalSynopsis": "karray = **genarray_i:k**(istart, iend [,inc])"
                },
                {
                    "description": "Evaluates the size or shape length of an array.",
                    "synopsis": "ir **lenarray** karray[, iwhich]\nkr **lenarray** karray[, iwhich]",
                    "opcodeName": "lenarray",
                    "functionalSynopsis": "ir = **lenarray:unknown**(karray[, iwhich])\nkr = **lenarray:k**(karray[, iwhich])"
                },
                {
                    "description": "Apply a function to every element of a vector.",
                    "synopsis": "karray **maparray** kinarray, String\nkarray **maparray_i** kinarray, String",
                    "opcodeName": "maparray",
                    "functionalSynopsis": "karray = **maparray:k**(kinarray, String)\nkarray = **maparray_i:k**(kinarray, String)"
                },
                {
                    "description": "Returns the number of samples loaded into a stored function table number.",
                    "synopsis": "**nsamp**(x) (init-rate args only)",
                    "opcodeName": "nsamp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Take a slice of a vector.",
                    "synopsis": "karray **slicearray** kinarray, istart, iend [,istride]",
                    "opcodeName": "slicearray",
                    "functionalSynopsis": "karray = **slicearray:k**(kinarray, istart, iend [,istride])"
                },
                {
                    "description": "Interrogates a function table for length.",
                    "synopsis": "ires **tableng** ifn\nkres **tableng** kfn",
                    "opcodeName": "tableng",
                    "functionalSynopsis": "ires = **tableng:unknown**(ifn)\nkres = **tableng:k**(kfn)"
                },
                {
                    "description": "Adding values in a range of a table.",
                    "synopsis": "kr **tabsum** ifn[[, kmin] [, kmax]]",
                    "opcodeName": "tabsum",
                    "functionalSynopsis": "kr = **tabsum:k**(ifn[[, kmin] [, kmax]])"
                },
                {
                    "description": "Table Read Access inside expressions.",
                    "synopsis": "**tb0_init** ifn\n**tb1_init** ifn\n**tb2_init** ifn\n**tb3_init** ifn\n**tb4_init** ifn\n**tb5_init** ifn\n**tb6_init** ifn\n**tb7_init** ifn\n**tb8_init** ifn\n**tb9_init** ifn\n**tb10_init** ifn\n**tb11_init** ifn\n**tb12_init** ifn\n**tb13_init** ifn\n**tb14_init** ifn\n**tb15_init** ifn\niout = **tb0**(iIndex)\nkout = **tb0**(kIndex)\niout = **tb1**(iIndex)\nkout = **tb1**(kIndex)\niout = **tb2**(iIndex)\nkout = **tb2**(kIndex)\niout = **tb3**(iIndex)\nkout = **tb3**(kIndex)\niout = **tb4**(iIndex)\nkout = **tb4**(kIndex)\niout = **tb5**(iIndex)\nkout = **tb5**(kIndex)\niout = **tb6**(iIndex)\nkout = **tb6**(kIndex)\niout = **tb7**(iIndex)\nkout = **tb7**(kIndex)\niout = **tb8**(iIndex)\nkout = **tb8**(kIndex)\niout = **tb9**(iIndex)\nkout = **tb9**(kIndex)\niout = **tb10**(iIndex)\nkout = **tb10**(kIndex)\niout = **tb11**(iIndex)\nkout = **tb11**(kIndex)\niout = **tb12**(iIndex)\nkout = **tb12**(kIndex)\niout = **tb13**(iIndex)\nkout = **tb13**(kIndex)\niout = **tb14**(iIndex)\nkout = **tb14**(kIndex)\niout = **tb15**(iIndex)\nkout = **tb15**(kIndex)",
                    "opcodeName": "tb0_init",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Table Control:Dynamic Selection",
            "opcodes": [
                {
                    "description": "Provides k-rate control over table numbers.",
                    "synopsis": "ares **tableikt** xndx, kfn [, ixmode] [, ixoff] [, iwrap]\nkres **tableikt** kndx, kfn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "tableikt",
                    "functionalSynopsis": "ares = **tableikt:a**(xndx, kfn [, ixmode] [, ixoff] [, iwrap])\nkres = **tableikt:k**(kndx, kfn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Provides k-rate control over table numbers.",
                    "synopsis": "ares **tablekt** xndx, kfn [, ixmode] [, ixoff] [, iwrap]\nkres **tablekt** kndx, kfn [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "tablekt",
                    "functionalSynopsis": "ares = **tablekt:a**(xndx, kfn [, ixmode] [, ixoff] [, iwrap])\nkres = **tablekt:k**(kndx, kfn [, ixmode] [, ixoff] [, iwrap])"
                },
                {
                    "description": "Reads function tables with linear, cubic, or sinc interpolation.",
                    "synopsis": "ares **tablexkt** xndx, kfn, kwarp, iwsize [, ixmode] [, ixoff] [, iwrap]",
                    "opcodeName": "tablexkt",
                    "functionalSynopsis": "ares = **tablexkt:a**(xndx, kfn, kwarp, iwsize [, ixmode] [, ixoff] [, iwrap])"
                }
            ]
        },
        {
            "category": "Table Control:Read/Write Operations",
            "opcodes": [
                {
                    "description": "Write a previously-allocated table to an audio file.",
                    "synopsis": "ians **ftaudio** ifn, &quot;filename&quot;, iformat[, ibeg, iend]\nkans **ftaudio** ktrig, kfn, &quot;filename&quot;, kformat [, isync, kbeg, kend]",
                    "opcodeName": "ftaudio",
                    "functionalSynopsis": "ians = **ftaudio:unknown**(ifn, &quot;filename&quot;, iformat[, ibeg, iend])\nkans = **ftaudio:k**(ktrig, kfn, &quot;filename&quot;, kformat [, isync, kbeg, kend])"
                },
                {
                    "description": "Load a set of previously-allocated tables from a file.",
                    "synopsis": "**ftload** Sfilename, iflag, ifn1 [, ifn2] [...]",
                    "opcodeName": "ftload",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Load a set of previously-allocated tables from a file.",
                    "synopsis": "**ftloadk** Sfilename, ktrig, iflag, ifn1 [, ifn2] [...]",
                    "opcodeName": "ftloadk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Print the contents of a table (for debugging)",
                    "synopsis": "**ftprint** ifn [, ktrig, kstart, kend, kstep, inumcols ]",
                    "opcodeName": "ftprint",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a directory for sound files.",
                    "synopsis": "iNumberOfFile **ftsamplebank** SDirectory, iFirstTableNumber, iSkipTime, iFormat, iChannel,\nkNumberOfFile **ftsamplebank** SDirectory, kFirstTableNumber, kTrigger, kSkipTime, kFormat, kChannel,",
                    "opcodeName": "ftsamplebank",
                    "functionalSynopsis": "iNumberOfFile = **ftsamplebank:unknown**(SDirectory, iFirstTableNumber, iSkipTime, iFormat, iChannel,)\nkNumberOfFile = **ftsamplebank:k**(SDirectory, kFirstTableNumber, kTrigger, kSkipTime, kFormat, kChannel,)"
                },
                {
                    "description": "Save a set of previously-allocated tables to a file.",
                    "synopsis": "**ftsave** &quot;filename&quot;, iflag, ifn1 [, ifn2] [...]",
                    "opcodeName": "ftsave",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Save a set of previously-allocated tables to a file.",
                    "synopsis": "**ftsavek** &quot;filename&quot;, ktrig, iflag, ifn1 [, ifn2] [...]",
                    "opcodeName": "ftsavek",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets multiple elements of a table to a given value",
                    "synopsis": "**ftset** ktablenum, kvalue [, kstart=0, kend=0, kstep=1 ]\n**ftset** itablenum, ivalue [, istart=0, iend=0, istep=1 ]",
                    "opcodeName": "ftset",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Copy a slice from an f-table to another f-table at performance",
                    "synopsis": "**ftslice** ifnsource, ifndest [, kstart, kend, kstep ]\n**ftslice** kfnsource, kfndest [, kstart, kend, kstep ]",
                    "opcodeName": "ftslice",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Copy a slice from an f-table to another f-table at init",
                    "synopsis": "**ftslicei** ifnsource, ifndest [, istart, iend, istep ]",
                    "opcodeName": "ftslicei",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Change the contents of existing function tables of any length.",
                    "synopsis": "**ptablew** asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]\n**ptablew** isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]\n**ptablew** ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]",
                    "opcodeName": "ptablew",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Simple, fast table copy opcode.",
                    "synopsis": "**tablecopy** kdft, ksft",
                    "opcodeName": "tablecopy",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Filters a source table and writes result into a destination table.",
                    "synopsis": "knumpassed **tablefilter** kouttable, kintatble, kmode, kparam",
                    "opcodeName": "tablefilter",
                    "functionalSynopsis": "knumpassed = **tablefilter:k**(kouttable, kintatble, kmode, kparam)"
                },
                {
                    "description": "Filters a source table and writes result into a destination table.",
                    "synopsis": "inumpassed **tablefilteri** iouttable, iintatble, imode, iparam",
                    "opcodeName": "tablefilteri",
                    "functionalSynopsis": "inumpassed = **tablefilteri:unknown**(iouttable, iintatble, imode, iparam)"
                },
                {
                    "description": "Writes a table's guard point.",
                    "synopsis": "**tablegpw** kfn",
                    "opcodeName": "tablegpw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Simple, fast table copy opcode.",
                    "synopsis": "**tableicopy** idft, isft",
                    "opcodeName": "tableicopy",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes a table's guard point.",
                    "synopsis": "**tableigpw** ifn",
                    "opcodeName": "tableigpw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Mixes two tables.",
                    "synopsis": "**tableimix** idft, idoff, ilen, is1ft, is1off, is1g, is2ft, is2off, is2g",
                    "opcodeName": "tableimix",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Mixes two tables.",
                    "synopsis": "**tablemix** kdft, kdoff, klen, ks1ft, ks1off, ks1g, ks2ft, ks2off, ks2g",
                    "opcodeName": "tablemix",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads tables in sequential locations.",
                    "synopsis": "ares **tablera** kfn, kstart, koff",
                    "opcodeName": "tablera",
                    "functionalSynopsis": "ares = **tablera:a**(kfn, kstart, koff)"
                },
                {
                    "description": "Change the contents of existing function tables.",
                    "synopsis": "**tablew** asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]\n**tablew** isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]\n**tablew** ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]",
                    "opcodeName": "tablew",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes tables in sequential locations.",
                    "synopsis": "kstart **tablewa** kfn, asig, koff",
                    "opcodeName": "tablewa",
                    "functionalSynopsis": "kstart = **tablewa:k**(kfn, asig, koff)"
                },
                {
                    "description": "Change the contents of existing function tables.",
                    "synopsis": "**tablewkt** asig, andx, kfn [, ixmode] [, ixoff] [, iwgmode]\n**tablewkt** ksig, kndx, kfn [, ixmode] [, ixoff] [, iwgmode]",
                    "opcodeName": "tablewkt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allow morphing between a set of tables.",
                    "synopsis": "kout **tabmorph** kindex, kweightpoint, ktabnum1, ktabnum2, \\\n      ifn1, ifn2 [, ifn3, ifn4, ...,ifnN]",
                    "opcodeName": "tabmorph",
                    "functionalSynopsis": "kout = **tabmorph:k**(kindex, kweightpoint, ktabnum1, ktabnum2, \\)"
                },
                {
                    "description": "Allow morphing between a set of tables at audio rate with interpolation.",
                    "synopsis": "aout **tabmorpha** aindex, aweightpoint, atabnum1, atabnum2, \\\n      ifn1, ifn2 [, ifn3, ifn4, ... ifnN]",
                    "opcodeName": "tabmorpha",
                    "functionalSynopsis": "aout = **tabmorpha:a**(aindex, aweightpoint, atabnum1, atabnum2, \\)"
                },
                {
                    "description": "Allow morphing between a set of tables at audio rate with interpolation.",
                    "synopsis": "aout **tabmorphak** aindex, kweightpoint, ktabnum1, ktabnum2, \\\n      ifn1, ifn2 [, ifn3, ifn4, ... ifnN]",
                    "opcodeName": "tabmorphak",
                    "functionalSynopsis": "aout = **tabmorphak:a**(aindex, kweightpoint, ktabnum1, ktabnum2, \\)"
                },
                {
                    "description": "Allow morphing between a set of tables with interpolation.",
                    "synopsis": "kout **tabmorphi** kindex, kweightpoint, ktabnum1, ktabnum2, \\\n      ifn1, ifn2 [, ifn3, ifn4, ..., ifnN]",
                    "opcodeName": "tabmorphi",
                    "functionalSynopsis": "kout = **tabmorphi:k**(kindex, kweightpoint, ktabnum1, ktabnum2, \\)"
                },
                {
                    "description": "Playing-back control signals.",
                    "synopsis": "**tabplay**  ktrig, knumtics, kfn, kout1 [,kout2,..., koutN]",
                    "opcodeName": "tabplay",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Recording of control signals.",
                    "synopsis": "**tabrec**   ktrig_start, ktrig_stop, knumtics, kfn, kin1 [,kin2,...,kinN]",
                    "opcodeName": "tabrec",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "FLTK:Containers",
            "opcodes": [
                {
                    "description": "A FLTK container opcode that groups child widgets.",
                    "synopsis": "**FLgroup** &quot;label&quot;, iwidth, iheight, ix, iy [, iborder] [, image]",
                    "opcodeName": "FLgroup",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of FLTK child widgets.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of FLTK child widgets.",
                    "synopsis": "**FLgroupEnd**",
                    "opcodeName": "FLgroupEnd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Provides the functionality of compressing and aligning FLTK widgets.",
                    "synopsis": "**FLpack** iwidth, iheight, ix, iy, itype, ispace, iborder",
                    "opcodeName": "FLpack",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of compressed or aligned FLTK widgets.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of compressed or aligned FLTK widgets.",
                    "synopsis": "**FLpackEnd**",
                    "opcodeName": "FLpackEnd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a window that contains FLTK widgets.",
                    "synopsis": "**FLpanel** &quot;label&quot;, iwidth, iheight [, ix] [, iy] [, iborder] [, ikbdcapture] [, iclose]",
                    "opcodeName": "FLpanel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of FLTK widgets contained inside of a window (panel).",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a group of FLTK widgets contained inside of a window (panel).",
                    "synopsis": "**FLpanelEnd**",
                    "opcodeName": "FLpanelEnd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that adds scroll bars to an area.",
                    "synopsis": "**FLscroll** iwidth, iheight [, ix] [, iy]",
                    "opcodeName": "FLscroll",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that marks the end of an area with scrollbars.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that marks the end of an area with scrollbars.",
                    "synopsis": "**FLscrollEnd**",
                    "opcodeName": "FLscrollEnd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a tabbed FLTK interface.",
                    "synopsis": "**FLtabs** iwidth, iheight, ix, iy",
                    "opcodeName": "FLtabs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a tabbed FLTK interface.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Marks the end of a tabbed FLTK interface.",
                    "synopsis": "**FLtabsEnd**",
                    "opcodeName": "FLtabsEnd",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "FLTK:Valuators",
            "opcodes": [
                {
                    "description": "A FLTK widget opcode that creates a counter.",
                    "synopsis": "kout, ihandle **FLcount** &quot;label&quot;, imin, imax, istep1, istep2, itype, \\\n      iwidth, iheight, ix, iy, iopcode [, kp1] [, kp2] [, kp3] [...] [, kpN]",
                    "opcodeName": "FLcount",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that acts like a joystick.",
                    "synopsis": "koutx, kouty, ihandlex, ihandley **FLjoy** &quot;label&quot;, iminx, imaxx, iminy, \\\n      imaxy, iexpx, iexpy, idispx, idispy, iwidth, iheight, ix, iy",
                    "opcodeName": "FLjoy",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget opcode that creates a knob.",
                    "synopsis": "kout, ihandle **FLknob** &quot;label&quot;, imin, imax, iexp, itype, idisp, iwidth, \\\n      ix, iy [, icursorsize]",
                    "opcodeName": "FLknob",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget that creates a transversal knob.",
                    "synopsis": "kout, ihandle **FLroller** &quot;label&quot;, imin, imax, istep, iexp, itype, idisp, \\\n      iwidth, iheight, ix, iy",
                    "opcodeName": "FLroller",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Puts a slider into the corresponding FLTK container.",
                    "synopsis": "kout, ihandle **FLslider** &quot;label&quot;, imin, imax, iexp, itype, idisp, iwidth, \\\n      iheight, ix, iy",
                    "opcodeName": "FLslider",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget opcode that creates a textbox.",
                    "synopsis": "kout, ihandle **FLtext** &quot;label&quot;, imin, imax, istep, itype, iwidth, \\\n      iheight, ix, iy",
                    "opcodeName": "FLtext",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "FLTK:Other",
            "opcodes": [
                {
                    "description": "A FLTK widget that displays text inside of a box.",
                    "synopsis": "ihandle **FLbox** &quot;label&quot;, itype, ifont, isize, iwidth, iheight, ix, iy [, image]\nihandle **FLbox** istr, itype, ifont, isize, iwidth, iheight, ix, iy [, image]",
                    "opcodeName": "FLbox",
                    "functionalSynopsis": "ihandle = **FLbox:unknown**(&quot;label&quot;, itype, ifont, isize, iwidth, iheight, ix, iy [, image])\nihandle = **FLbox:unknown**(istr, itype, ifont, isize, iwidth, iheight, ix, iy [, image])"
                },
                {
                    "description": "A FLTK widget opcode that creates a bank of buttons.",
                    "synopsis": "kout, ihandle **FLbutBank** itype, inumx, inumy, iwidth, iheight, ix, iy, \\\n      iopcode [, kp1] [, kp2] [, kp3] [, kp4] [, kp5] [....] [, kpN]",
                    "opcodeName": "FLbutBank",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget opcode that creates a button.",
                    "synopsis": "kout, ihandle **FLbutton** &quot;label&quot;, ion, ioff, itype, iwidth, iheight, ix, \\\n      iy, iopcode [, kp1] [, kp2] [, kp3] [, kp4] [, kp5] [....] [, kpN]",
                    "opcodeName": "FLbutton",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget opcode that creates a button that will close the panel\n      window it is a part of.",
                    "synopsis": "ihandle **FLcloseButton** &quot;label&quot;, iwidth, iheight, ix, iy",
                    "opcodeName": "FLcloseButton",
                    "functionalSynopsis": "ihandle = **FLcloseButton:unknown**(&quot;label&quot;, iwidth, iheight, ix, iy)"
                },
                {
                    "description": "A FLTK widget opcode that creates a button that executes a command.",
                    "synopsis": "ihandle **FLexecButton** &quot;command&quot;, iwidth, iheight, ix, iy",
                    "opcodeName": "FLexecButton",
                    "functionalSynopsis": "ihandle = **FLexecButton:unknown**(&quot;command&quot;, iwidth, iheight, ix, iy)"
                },
                {
                    "description": "Retrieves a previously stored FLTK snapshot.",
                    "synopsis": "inumsnap **FLgetsnap** index [, igroup]",
                    "opcodeName": "FLgetsnap",
                    "functionalSynopsis": "inumsnap = **FLgetsnap:unknown**(index [, igroup])"
                },
                {
                    "description": "Displays a box with a grid useful for visualizing two-dimensional Hyper Vectorial Synthesis.",
                    "synopsis": "ihandle **FLhvsBox** inumlinesX, inumlinesY, iwidth, iheight, ix, iy",
                    "opcodeName": "FLhvsBox",
                    "functionalSynopsis": "ihandle = **FLhvsBox:unknown**(inumlinesX, inumlinesY, iwidth, iheight, ix, iy)"
                },
                {
                    "description": "Sets the cursor position of a previously-declared FLhvsBox widget.",
                    "synopsis": "**FLhvsBox** kx, ky, ihandle",
                    "opcodeName": "FLhvsBox",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reports keys pressed (on alphanumeric keyboard) when an FLTK panel has focus.",
                    "synopsis": "kascii **FLkeyIn** [ifn]",
                    "opcodeName": "FLkeyIn",
                    "functionalSynopsis": "kascii = **FLkeyIn:k**([ifn])"
                },
                {
                    "description": "Loads all snapshots into the memory bank of the current orchestra.",
                    "synopsis": "**FLloadsnap** &quot;filename&quot; [, igroup]",
                    "opcodeName": "FLloadsnap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the mouse position and the state of the three mouse buttons.",
                    "synopsis": "kx, ky, kb1, kb2, kb3 **FLmouse** [imode]",
                    "opcodeName": "FLmouse",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that prints a k-rate value at specified intervals.",
                    "synopsis": "**FLprintk** itime, kval, idisp",
                    "opcodeName": "FLprintk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that prints a new value every time a control-rate variable changes.",
                    "synopsis": "**FLprintk2** kval, idisp",
                    "opcodeName": "FLprintk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Starts the FLTK widget thread.",
                    "synopsis": "**FLrun**",
                    "opcodeName": "FLrun",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Saves all snapshots currently created into a file.",
                    "synopsis": "**FLsavesnap** &quot;filename&quot; [, igroup]",
                    "opcodeName": "FLsavesnap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Stores the current status of all FLTK valuators into a snapshot location.",
                    "synopsis": "inumsnap, inumval **FLsetsnap** index [, ifn, igroup]",
                    "opcodeName": "FLsetsnap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Determines the snapshot group for FL valuators.",
                    "synopsis": "**FLsetSnapGroup** igroup",
                    "opcodeName": "FLsetSnapGroup",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the value of a FLTK valuator at control-rate.",
                    "synopsis": "**FLsetVal** ktrig, kvalue, ihandle",
                    "opcodeName": "FLsetVal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the value of a FLTK valuator to a number provided by the user.",
                    "synopsis": "**FLsetVal_i** ivalue, ihandle",
                    "opcodeName": "FLsetVal_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget containing a bank of horizontal sliders.",
                    "synopsis": "**FLslidBnk** &quot;names&quot;, inumsliders [, ioutable] [, iwidth] [, iheight] [, ix] \\\n      [, iy] [, itypetable] [, iexptable] [, istart_index] [, iminmaxtable]",
                    "opcodeName": "FLslidBnk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget containing a bank of horizontal sliders.",
                    "synopsis": "**FLslidBnk2** &quot;names&quot;, inumsliders, ioutable, iconfigtable [,iwidth, iheight, ix, iy, istart_index] \n**FLslidBnk2** istring, inumsliders, ioutable, iconfigtable [,iwidth, iheight, ix, iy, istart_index] ",
                    "opcodeName": "FLslidBnk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "modify the values of a slider bank.",
                    "synopsis": "**FLslidBnk2Set** ihandle, ifn [, istartIndex, istartSlid, inumSlid]",
                    "opcodeName": "FLslidBnk2Set",
                    "functionalSynopsis": ""
                },
                {
                    "description": "modify the values of a slider bank.",
                    "synopsis": "**FLslidBnk2Setk**  ktrig, ihandle, ifn [, istartIndex, istartSlid, inumSlid]",
                    "opcodeName": "FLslidBnk2Setk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "gets the handle of last slider bank created.",
                    "synopsis": "ihandle **FLslidBnkGetHandle**",
                    "opcodeName": "FLslidBnkGetHandle",
                    "functionalSynopsis": "ihandle = **FLslidBnkGetHandle:unknown**()"
                },
                {
                    "description": "modify the values of a slider bank.",
                    "synopsis": "**FLslidBnkSet** ihandle, ifn [, istartIndex, istartSlid, inumSlid]",
                    "opcodeName": "FLslidBnkSet",
                    "functionalSynopsis": ""
                },
                {
                    "description": "modify the values of a slider bank.",
                    "synopsis": "**FLslidBnkSetk**  ktrig, ihandle, ifn [, istartIndex, istartSlid, inumSlid]",
                    "opcodeName": "FLslidBnkSetk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Same as the FLrun opcode.",
                    "synopsis": "**FLupdate**",
                    "opcodeName": "FLupdate",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Shows the current value of a FLTK valuator.",
                    "synopsis": "ihandle **FLvalue** &quot;label&quot;, iwidth, iheight, ix, iy",
                    "opcodeName": "FLvalue",
                    "functionalSynopsis": "ihandle = **FLvalue:unknown**(&quot;label&quot;, iwidth, iheight, ix, iy)"
                },
                {
                    "description": "An FLTK widget opcode that creates a virtual keyboard widget.",
                    "synopsis": "**FLvkeybd** &quot;keyboard.map&quot;, iwidth, iheight, ix, iy",
                    "opcodeName": "FLvkeybd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget containing a bank of vertical sliders.",
                    "synopsis": "**FLvslidBnk** &quot;names&quot;, inumsliders [, ioutable] [, iwidth] [, iheight] [, ix] \\\n      [, iy] [, itypetable] [, iexptable] [, istart_index] [, iminmaxtable]",
                    "opcodeName": "FLvslidBnk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK widget containing a bank of vertical sliders.",
                    "synopsis": "**FLvslidBnk2** &quot;names&quot;, inumsliders, ioutable, iconfigtable [,iwidth, iheight, ix, iy, istart_index]",
                    "opcodeName": "FLvslidBnk2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Senses the mouse cursor position in a user-defined area inside an FLpanel.",
                    "synopsis": "koutx, kouty, kinside  **FLxyin** ioutx_min, ioutx_max, iouty_min, iouty_max, \\\n      iwindx_min, iwindx_max, iwindy_min, iwindy_max [, iexpx, iexpy, ioutx, iouty]",
                    "opcodeName": "FLxyin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows one-dimensional HVS (Hyper-Vectorial Synthesis).",
                    "synopsis": "**vphaseseg** kphase, ioutab, ielems, itab1,idist1,itab2 \\\n      [,idist2,itab3, ... ,idistN-1,itabN]",
                    "opcodeName": "vphaseseg",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "FLTK:Appearance",
            "opcodes": [
                {
                    "description": "A FLTK opcode that sets the primary colors.",
                    "synopsis": "**FLcolor** ired, igreen, iblue [, ired2, igreen2, iblue2]",
                    "opcodeName": "FLcolor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that sets the secondary (selection) color.",
                    "synopsis": "**FLcolor2** ired, igreen, iblue",
                    "opcodeName": "FLcolor2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Hides the target FLTK widget.",
                    "synopsis": "**FLhide** ihandle",
                    "opcodeName": "FLhide",
                    "functionalSynopsis": ""
                },
                {
                    "description": "A FLTK opcode that modifies the appearance of a text label.",
                    "synopsis": "**FLlabel** isize, ifont, ialign, ired, igreen, iblue",
                    "opcodeName": "FLlabel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the text alignment of a label of a FLTK widget.",
                    "synopsis": "**FLsetAlign** ialign, ihandle",
                    "opcodeName": "FLsetAlign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the appearance of a box surrounding a FLTK widget.",
                    "synopsis": "**FLsetBox** itype, ihandle",
                    "opcodeName": "FLsetBox",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the primary color of a FLTK widget.",
                    "synopsis": "**FLsetColor** ired, igreen, iblue, ihandle",
                    "opcodeName": "FLsetColor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the secondary (or selection) color of a FLTK widget.",
                    "synopsis": "**FLsetColor2** ired, igreen, iblue, ihandle",
                    "opcodeName": "FLsetColor2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the font type of a FLTK widget.",
                    "synopsis": "**FLsetFont** ifont, ihandle",
                    "opcodeName": "FLsetFont",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the position of a FLTK widget.",
                    "synopsis": "**FLsetPosition** ix, iy, ihandle",
                    "opcodeName": "FLsetPosition",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Resizes a FLTK widget.",
                    "synopsis": "**FLsetSize** iwidth, iheight, ihandle",
                    "opcodeName": "FLsetSize",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the label of a FLTK widget.",
                    "synopsis": "**FLsetText** &quot;itext&quot;, ihandle\n**FLsetText** istr, ihandle",
                    "opcodeName": "FLsetText",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the color of the text label of a FLTK widget.",
                    "synopsis": "**FLsetTextColor** ired, iblue, igreen, ihandle",
                    "opcodeName": "FLsetTextColor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the size of the text label of a FLTK widget.",
                    "synopsis": "**FLsetTextSize** isize, ihandle",
                    "opcodeName": "FLsetTextSize",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets some font attributes of the text label of a FLTK widget.",
                    "synopsis": "**FLsetTextType** itype, ihandle",
                    "opcodeName": "FLsetTextType",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Restores the visibility of a previously hidden FLTK widget.",
                    "synopsis": "**FLshow** ihandle",
                    "opcodeName": "FLshow",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Arithmetic and Logic Operations",
            "opcodes": [
                {
                    "description": "Addition operator",
                    "synopsis": "a + b  (no rate restriction)",
                    "opcodeName": "+",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Division operator.",
                    "synopsis": "a / b  (no rate restriction)",
                    "opcodeName": "/",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Modulus operator.",
                    "synopsis": "a % b  (no rate restriction)",
                    "opcodeName": "%",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Multiplication operator.",
                    "synopsis": "a * b  (no rate restriction)",
                    "opcodeName": "*",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Logical AND operator.",
                    "synopsis": "a **&amp;&amp;** b  (logical AND; not audio-rate)",
                    "opcodeName": "&amp;&amp;",
                    "functionalSynopsis": "a = **&amp;&amp;:a**(b  (logical AND; not audio-rate))"
                },
                {
                    "description": "Bitwise AND operator.",
                    "synopsis": "a **&amp;** b  (bitwise AND)",
                    "opcodeName": "&amp;",
                    "functionalSynopsis": "a = **&amp;:a**(b  (bitwise AND))"
                },
                {
                    "description": "Bitwise NOT operator.",
                    "synopsis": "**~** a  (bitwise NOT)",
                    "opcodeName": "~",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Bitwise OR operator.",
                    "synopsis": "a | b  (bitwise OR)",
                    "opcodeName": "|",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Bitshift left operator.",
                    "synopsis": "a **&lt;&lt;** b  (bitshift left)",
                    "opcodeName": "&lt;&lt;",
                    "functionalSynopsis": "a = **&lt;&lt;:a**(b  (bitshift left))"
                },
                {
                    "description": "Bitshift right operator.",
                    "synopsis": "a **&gt;&gt;** b  (bitshift left)",
                    "opcodeName": "&gt;&gt;",
                    "functionalSynopsis": "a = **&gt;&gt;:a**(b  (bitshift left))"
                },
                {
                    "description": "Bitwise NON EQUIVALENCE operator.",
                    "synopsis": "a **#** b  (bitwise NON EQUIVALENCE)",
                    "opcodeName": "#",
                    "functionalSynopsis": "a = **#:a**(b  (bitwise NON EQUIVALENCE))"
                },
                {
                    "description": "Logical NOT operator.",
                    "synopsis": "**!** a  (logical NOT; not audio-rate)",
                    "opcodeName": "!",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Logical OR operator.",
                    "synopsis": "a || b  (logical OR; not audio-rate)",
                    "opcodeName": "||",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "a ^ b  (b not audio-rate)",
                    "opcodeName": "^",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Subtraction operator.",
                    "synopsis": "<command/>a  (no rate restriction)\na <command/> b  (no rate restriction)",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Arrays",
            "opcodes": [
                {
                    "description": "Cubic root function.",
                    "synopsis": "ires[] **cbrt** iarg\nkres[] **cbrt** karg",
                    "opcodeName": "cbrt",
                    "functionalSynopsis": "ires[] = **cbrt:unknown**(iarg)\nkres[] = **cbrt:k**(karg)"
                },
                {
                    "description": "Maximum value function.",
                    "synopsis": "ires[] **fmax** iarg1[], iarg2[] \nkres[] **fmax** karg1[], karg2[]\nires[] **fmax** iarg1[], iarg2 \nkres[] **fmax** karg[], karg2 ",
                    "opcodeName": "fmax",
                    "functionalSynopsis": "ires[] = **fmax:unknown**(iarg1[], iarg2[] )\nkres[] = **fmax:k**(karg1[], karg2[])\nires[] = **fmax:unknown**(iarg1[], iarg2 )\nkres[] = **fmax:k**(karg[], karg2 )"
                },
                {
                    "description": "Minimum value function.",
                    "synopsis": "ires[] **fmin** iarg1[], iarg2[] \nkres[] **fmin** karg1[], karg2[]\nires[] **fmin** iarg1[], iarg2 \nkres[] **fmin** karg[], karg2 ",
                    "opcodeName": "fmin",
                    "functionalSynopsis": "ires[] = **fmin:unknown**(iarg1[], iarg2[] )\nkres[] = **fmin:k**(karg1[], karg2[])\nires[] = **fmin:unknown**(iarg1[], iarg2 )\nkres[] = **fmin:k**(karg[], karg2 )"
                },
                {
                    "description": "Compute the floating point remainder operation.",
                    "synopsis": "ires[] **fmod** iarg1[], iarg2[] \nkres[] **fmod** karg1[], karg2[]\nires[] **fmod** iarg1[], iarg2 \nkres[] **fmod** karg[], karg2 ",
                    "opcodeName": "fmod",
                    "functionalSynopsis": "ires[] = **fmod:unknown**(iarg1[], iarg2[] )\nkres[] = **fmod:k**(karg1[], karg2[])\nires[] = **fmod:unknown**(iarg1[], iarg2 )\nkres[] = **fmod:k**(karg[], karg2 )"
                },
                {
                    "description": "Euclidean distance function.",
                    "synopsis": "ires[] **hypot** iarg1[], iarg2[] \nkres[] **hypot** karg1[], karg2[]",
                    "opcodeName": "hypot",
                    "functionalSynopsis": "ires[] = **hypot:unknown**(iarg1[], iarg2[] )\nkres[] = **hypot:k**(karg1[], karg2[])"
                },
                {
                    "description": "Limiting function",
                    "synopsis": "ires[] **limit1** iarg\nkres[] **limit1** karg",
                    "opcodeName": "limit1",
                    "functionalSynopsis": "ires[] = **limit1:unknown**(iarg)\nkres[] = **limit1:k**(karg)"
                }
            ]
        },
        {
            "category": "Mathematical Operations:Comparators and Accumulators",
            "opcodes": [
                {
                    "description": "Zeroes a list of audio signals.",
                    "synopsis": "**clear** avar1 [, avar2] [, avar3] [...]\n**clear** avar[]",
                    "opcodeName": "clear",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Accumulates audio signals.",
                    "synopsis": "**vincr** accum, aincr",
                    "opcodeName": "vincr",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Mathematical Functions",
            "opcodes": [
                {
                    "description": "Returns an absolute value.",
                    "synopsis": "**abs**(x) (no rate\n    restriction)\n**abs**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "abs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the smallest integer not less than",
                    "synopsis": "**ceil**(x) (init-, control-, or audio-rate arg allowed)\n**ceil**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "ceil",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns e raised to the x-th power.",
                    "synopsis": "**exp**(x) (no rate\n    restriction)\n**exp**(k/i[]) (k- or i-arrays)",
                    "opcodeName": "exp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the largest integer not greater than",
                    "synopsis": "**floor**(x) (init-, control-, or audio-rate arg allowed)\n**floor**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "floor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the fractional part of a decimal number.",
                    "synopsis": "**frac**(x) (init-rate or control-rate args; also works at audio rate in Csound5)\n**frac**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "frac",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Extracts an integer from a decimal number.",
                    "synopsis": "**int**(x)  (init-rate or control-rate; also works at audio rate in Csound5)",
                    "opcodeName": "int",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns a natural log of a number, or an array (with optional arbitrary base).",
                    "synopsis": "**log**(x) (no rate\n    restriction)\n**log**(k/i[]) (k- or i-arrays )\nkout[]**log** kin[],ibas",
                    "opcodeName": "log",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns a base 10 log.",
                    "synopsis": "**log10**(x) (no rate restriction)\n**log10**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "log10",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns a base 2 log.",
                    "synopsis": "**log2**(x) (no rate\n    restriction)\n**log2**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "log2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a logarithmic base two calculation.",
                    "synopsis": "**logbtwo**(x)  (init-rate or control-rate args only)",
                    "opcodeName": "logbtwo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a  power-of-two calculation.",
                    "synopsis": "**powoftwo**(x)  (init-rate or control-rate args only)",
                    "opcodeName": "powoftwo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Questions whether the argument is a infinite number",
                    "synopsis": "**qinf**(x) (no rate restriction)",
                    "opcodeName": "qinf",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Questions whether the argument is not a number",
                    "synopsis": "**qnan**(x) (no rate restriction)",
                    "opcodeName": "qnan",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the integer value nearest to",
                    "synopsis": "**round**(x) (init-, control-, or audio-rate arg allowed)\n**round**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "round",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns a square root value.",
                    "synopsis": "**sqrt**(x) (no rate restriction)\n**sqrt**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "sqrt",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Trigonometric Functions",
            "opcodes": [
                {
                    "description": "Performs a cosine function.",
                    "synopsis": "**cos**(x) (no rate\n    restriction)\n**cos**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "cos",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a hyperbolic cosine function.",
                    "synopsis": "**cosh**(x) (no rate\n    restriction)\n**cosh**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "cosh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a arccosine function.",
                    "synopsis": "**cosinv**(x) (no rate\n    restriction)\n**cosinv**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "cosinv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a signum function.",
                    "synopsis": "**signum**(x) (no rate restriction)",
                    "opcodeName": "signum",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a sine function.",
                    "synopsis": "**sin**(x) (no rate restriction)\n**sin**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "sin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a hyperbolic sine function.",
                    "synopsis": "**sinh**(x) (no rate\n    restriction)\n**sinh**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "sinh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs an arcsine function.",
                    "synopsis": "**sininv**(x) (no rate\n    restriction)\n**sininv**(k/i[]) (k- or i-arrays)",
                    "opcodeName": "sininv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a tangent function.",
                    "synopsis": "**tan**(x) (no rate\n    restriction)\n**tan**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "tan",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs a hyperbolic tangent function.",
                    "synopsis": "**tanh**(x) (no rate\n    restriction)\n**tanh**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "tanh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs an arctangent function.",
                    "synopsis": "**taninv**(x) (no rate\n    restriction)\n**taninv**(k/i[]) (k- or i-arrays )",
                    "opcodeName": "taninv",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Amplitude Functions",
            "opcodes": [
                {
                    "description": "Returns the amplitude equivalent of the decibel value x.",
                    "synopsis": "**ampdb**(x)  (no rate restriction)",
                    "opcodeName": "ampdb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the amplitude equivalent (in 16-bit signed integer scale) of the full scale decibel (dB FS) value",
                    "synopsis": "**ampdbfs**(x)  (no rate restriction)",
                    "opcodeName": "ampdbfs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the amplitude equivalent for a given decibel amount.",
                    "synopsis": "**db**(x)",
                    "opcodeName": "db",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the decibel equivalent of the raw amplitude",
                    "synopsis": "**dbamp**(x)  (init-rate or control-rate args only)",
                    "opcodeName": "dbamp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the decibel equivalent of the raw amplitude",
                    "synopsis": "**dbfsamp**(x)  (init-rate or control-rate args only)",
                    "opcodeName": "dbfsamp",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Random Functions",
            "opcodes": [
                {
                    "description": "Returns a random number in a bi-polar range.",
                    "synopsis": "**birnd**(x) (init- or control-rate only)",
                    "opcodeName": "birnd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns a random number in a unipolar range at the rate given by the input argument.",
                    "synopsis": "**rnd**(x) (init- or control-rate only)",
                    "opcodeName": "rnd",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mathematical Operations:Opcode Equivalents of Functions",
            "opcodes": [
                {
                    "description": "Safely divides two numbers.",
                    "synopsis": "ares **divz** xa, xb, ksubst\nires **divz** ia, ib, isubst\nkres **divz** ka, kb, ksubst\n...**divz**(ka, kb, ksubst)... (no rate restriction)",
                    "opcodeName": "divz",
                    "functionalSynopsis": "ares = **divz:a**(xa, xb, ksubst)\nires = **divz:unknown**(ia, ib, isubst)\nkres = **divz:k**(ka, kb, ksubst)"
                },
                {
                    "description": "Multiplies and accumulates a- and k-rate signals.",
                    "synopsis": "ares **mac** ksig1, asig1 [, ksig2] [, asig2] [, ksig3] [, asig3] [...]",
                    "opcodeName": "mac",
                    "functionalSynopsis": "ares = **mac:a**(ksig1, asig1 [, ksig2] [, asig2] [, ksig3] [, asig3] [...])"
                },
                {
                    "description": "Multiply and accumulate a-rate signals only.",
                    "synopsis": "ares **maca** asig1 , asig2 [, asig3] [, asig4] [, asig5] [...]",
                    "opcodeName": "maca",
                    "functionalSynopsis": "ares = **maca:a**(asig1 , asig2 [, asig3] [, asig4] [, asig5] [...])"
                },
                {
                    "description": "Efficiently evaluates a polynomial of arbitrary order.",
                    "synopsis": "aout **polynomial** ain, k0 [, k1 [, k2 [...]]]",
                    "opcodeName": "polynomial",
                    "functionalSynopsis": "aout = **polynomial:a**(ain, k0 [, k1 [, k2 [...]]])"
                },
                {
                    "description": "Computes one argument to the power of another argument.",
                    "synopsis": "ares **pow** aarg, kpow [, inorm]\nires **pow** iarg, ipow [, inorm]\nkres **pow** karg, kpow [, inorm]\nires[] **pow** iarg[], ipow[] \nkres[] **pow** karg[], kpow[]\nires[] **pow** iarg[], ipow \nkres[] **pow** karg[], kpow ",
                    "opcodeName": "pow",
                    "functionalSynopsis": "ares = **pow:a**(aarg, kpow [, inorm])\nires = **pow:unknown**(iarg, ipow [, inorm])\nkres = **pow:k**(karg, kpow [, inorm])\nires[] = **pow:unknown**(iarg[], ipow[] )\nkres[] = **pow:k**(karg[], kpow[])\nires[] = **pow:unknown**(iarg[], ipow )\nkres[] = **pow:k**(karg[], kpow )"
                },
                {
                    "description": "Multiplies any number of a-rate signals.",
                    "synopsis": "ares **product** asig1, asig2 [, asig3] [...]",
                    "opcodeName": "product",
                    "functionalSynopsis": "ares = **product:a**(asig1, asig2 [, asig3] [...])"
                },
                {
                    "description": "Sums any number of a-rate signals, or array elements.",
                    "synopsis": "ares **sum** asig1 [, asig2] [, asig3] [...]\nkres **sum** karr\nires **sum** iarr",
                    "opcodeName": "sum",
                    "functionalSynopsis": "ares = **sum:a**(asig1 [, asig2] [, asig3] [...])\nkres = **sum:k**(karr)\nires = **sum:unknown**(iarr)"
                },
                {
                    "description": "Returns an arctangent.",
                    "synopsis": "ares **taninv2** ay, ax\nires **taninv2** iy, ix\nkres **taninv2** ky, kx\n...**taninv2**(ky, kx)... (no rate restriction)",
                    "opcodeName": "taninv2",
                    "functionalSynopsis": "ares = **taninv2:a**(ay, ax)\nires = **taninv2:unknown**(iy, ix)\nkres = **taninv2:k**(ky, kx)"
                }
            ]
        },
        {
            "category": "Pitch Converters:Functions",
            "opcodes": [
                {
                    "description": "Calculates a factor to raise/lower a frequency by a given amount of cents.",
                    "synopsis": "**cent**(x) ",
                    "opcodeName": "cent",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a Midi note number value to cycles-per-second.",
                    "synopsis": "**cpsmidinn** (MidiNoteNumber)  (init- or control-rate args only)",
                    "opcodeName": "cpsmidinn",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts an octave-point-decimal value to cycles-per-second.",
                    "synopsis": "**cpsoct** (oct)  (no rate restriction)",
                    "opcodeName": "cpsoct",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a pitch-class value to cycles-per-second.",
                    "synopsis": "**cpspch** (pch)  (init- or control-rate args only)",
                    "opcodeName": "cpspch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Convert frequency to midi",
                    "synopsis": "imidi **ftom** ifreq [,irnd]\nkmidi **ftom** kfreq [,irnd]\nimidis[] **ftom** ifreqs[] [,irnd]\nkmidis[] **ftom** kfreqs[] [,irnd]",
                    "opcodeName": "ftom",
                    "functionalSynopsis": "imidi = **ftom:unknown**(ifreq [,irnd])\nkmidi = **ftom:k**(kfreq [,irnd])\nimidis[] = **ftom:unknown**(ifreqs[] [,irnd])\nkmidis[] = **ftom:k**(kfreqs[] [,irnd])"
                },
                {
                    "description": "Convert a midi to frequency",
                    "synopsis": "ifreq **mtof** imidi\nkfreq **mtof** kmidi\nifreqs[] **mtof** imidis[]\nkfreqs[] **mtof** kmidis[]",
                    "opcodeName": "mtof",
                    "functionalSynopsis": "ifreq = **mtof:unknown**(imidi)\nkfreq = **mtof:k**(kmidi)\nifreqs[] = **mtof:unknown**(imidis[])\nkfreqs[] = **mtof:k**(kmidis[])"
                },
                {
                    "description": "Convert midi note number to string note name",
                    "synopsis": "Snote **mton** kmidi\nSnote **mton** imidi",
                    "opcodeName": "mton",
                    "functionalSynopsis": "Snote = **mton:unknown**(kmidi)\nSnote = **mton:unknown**(imidi)"
                },
                {
                    "description": "Convert note name to frequency",
                    "synopsis": "kfreq **ntof** Snote\nifreq **ntof** Snote",
                    "opcodeName": "ntof",
                    "functionalSynopsis": "kfreq = **ntof:k**(Snote)\nifreq = **ntof:unknown**(Snote)"
                },
                {
                    "description": "Convert note name to midi note number",
                    "synopsis": "kmidi **ntom** Snote\nimidi **ntom** Snote",
                    "opcodeName": "ntom",
                    "functionalSynopsis": "kmidi = **ntom:k**(Snote)\nimidi = **ntom:unknown**(Snote)"
                },
                {
                    "description": "Calculates a factor to raise/lower a frequency by a given amount of octaves.",
                    "synopsis": "**octave**(x)",
                    "opcodeName": "octave",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a cycles-per-second value to octave-point-decimal.",
                    "synopsis": "**octcps** (cps)  (init- or control-rate args only)",
                    "opcodeName": "octcps",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a Midi note number value to octave-point-decimal.",
                    "synopsis": "**octmidinn** (MidiNoteNumber)  (init- or control-rate args only)",
                    "opcodeName": "octmidinn",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a pitch-class value to octave-point-decimal.",
                    "synopsis": "**octpch** (pch)  (init- or control-rate args only)",
                    "opcodeName": "octpch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a Midi note number value to octave point pitch-class units.",
                    "synopsis": "**pchmidinn** (MidiNoteNumber)  (init- or control-rate args only)",
                    "opcodeName": "pchmidinn",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts an octave-point-decimal value to pitch-class.",
                    "synopsis": "**pchoct** (oct)  (init- or control-rate args only)",
                    "opcodeName": "pchoct",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Convert pch to midi note number",
                    "synopsis": "imidi **pchtom** ipch\nkmidi **pchtom** kpch",
                    "opcodeName": "pchtom",
                    "functionalSynopsis": "imidi = **pchtom:unknown**(ipch)\nkmidi = **pchtom:k**(kpch)"
                },
                {
                    "description": "Calculates a factor to raise/lower a frequency by a given amount of semitones.",
                    "synopsis": "**semitone**(x)",
                    "opcodeName": "semitone",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Pitch Converters:Tuning Opcodes",
            "opcodes": [
                {
                    "description": "Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of the octave.",
                    "synopsis": "icps **cps2pch** ipch, iequal",
                    "opcodeName": "cps2pch",
                    "functionalSynopsis": "icps = **cps2pch:unknown**(ipch, iequal)"
                },
                {
                    "description": "Returns micro-tuning values at k-rate.",
                    "synopsis": "kcps **cpstun** ktrig, kindex, kfn",
                    "opcodeName": "cpstun",
                    "functionalSynopsis": "kcps = **cpstun:k**(ktrig, kindex, kfn)"
                },
                {
                    "description": "Returns micro-tuning values at init-rate.",
                    "synopsis": "icps **cpstuni** index, ifn",
                    "opcodeName": "cpstuni",
                    "functionalSynopsis": "icps = **cpstuni:unknown**(index, ifn)"
                },
                {
                    "description": "Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of any interval.",
                    "synopsis": "icps **cpsxpch** ipch, iequal, irepeat, ibase",
                    "opcodeName": "cpsxpch",
                    "functionalSynopsis": "icps = **cpsxpch:unknown**(ipch, iequal, irepeat, ibase)"
                }
            ]
        },
        {
            "category": "Real-time MIDI:Input",
            "opcodes": [
                {
                    "description": "Get the current after-touch value for this channel.",
                    "synopsis": "kaft **aftouch** [imin] [, imax]",
                    "opcodeName": "aftouch",
                    "functionalSynopsis": "kaft = **aftouch:k**([imin] [, imax])"
                },
                {
                    "description": "Get the current value of a MIDI channel controller.",
                    "synopsis": "ival **chanctrl** ichnl, ictlno [, ilow] [, ihigh]\nkval **chanctrl** ichnl, ictlno [, ilow] [, ihigh]",
                    "opcodeName": "chanctrl",
                    "functionalSynopsis": "ival = **chanctrl:unknown**(ichnl, ictlno [, ilow] [, ihigh])\nkval = **chanctrl:k**(ichnl, ictlno [, ilow] [, ihigh])"
                },
                {
                    "description": "Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **ctrl14** ichan, ictlno1, ictlno2, imin, imax [, ifn]\nkdest **ctrl14** ichan, ictlno1, ictlno2, kmin, kmax [, ifn]",
                    "opcodeName": "ctrl14",
                    "functionalSynopsis": "idest = **ctrl14:unknown**(ichan, ictlno1, ictlno2, imin, imax [, ifn])\nkdest = **ctrl14:k**(ichan, ictlno1, ictlno2, kmin, kmax [, ifn])"
                },
                {
                    "description": "Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **ctrl21** ichan, ictlno1, ictlno2, ictlno3, imin, imax [, ifn]\nkdest **ctrl21** ichan, ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]",
                    "opcodeName": "ctrl21",
                    "functionalSynopsis": "idest = **ctrl21:unknown**(ichan, ictlno1, ictlno2, ictlno3, imin, imax [, ifn])\nkdest = **ctrl21:k**(ichan, ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn])"
                },
                {
                    "description": "Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **ctrl7** ichan, ictlno, imin, imax [, ifn]\nkdest **ctrl7** ichan, ictlno, kmin, kmax [, ifn]\nadest **ctrl7** ichan, ictlno, kmin, kmax [, ifn] [, icutoff]",
                    "opcodeName": "ctrl7",
                    "functionalSynopsis": "idest = **ctrl7:unknown**(ichan, ictlno, imin, imax [, ifn])\nkdest = **ctrl7:k**(ichan, ictlno, kmin, kmax [, ifn])\nadest = **ctrl7:a**(ichan, ictlno, kmin, kmax [, ifn] [, icutoff])"
                },
                {
                    "description": "Sets the initial values for a set of MIDI controllers.",
                    "synopsis": "**ctrlinit** ichnl, ictlno1, ival1 [, ictlno2] [, ival2] [, ictlno3] \\\n      [, ival3] [,...ival32]",
                    "opcodeName": "ctrlinit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Defines a preset for MIDI controllers.",
                    "synopsis": "kpreset **ctrlpreset** ktag, kchnl, kctlno1, [kctlno2] [, kctlno3] ...",
                    "opcodeName": "ctrlpreset",
                    "functionalSynopsis": "kpreset = **ctrlpreset:k**(ktag, kchnl, kctlno1, [kctlno2] [, kctlno3] ...)"
                },
                {
                    "description": "Print the saved values of MIDI controllers.",
                    "synopsis": " **ctrlprint** kcont[][, Sfile]",
                    "opcodeName": "ctrlprint",
                    "functionalSynopsis": " = **ctrlprint:unknown**(kcont[][, Sfile])"
                },
                {
                    "description": "Prints the current collection of presets for MIDI controllers.",
                    "synopsis": " **ctrlprintpresets** [Sfilenam]",
                    "opcodeName": "ctrlprintpresets",
                    "functionalSynopsis": " = **ctrlprintpresets:unknown**([Sfilenam])"
                },
                {
                    "description": "Recovers the current values of MIDI controllers.",
                    "synopsis": "kconnt[] **ctrlsave** ichnl, ictlno1, [ictlno2] [, ictlno3] ...",
                    "opcodeName": "ctrlsave",
                    "functionalSynopsis": "kconnt[] = **ctrlsave:k**(ichnl, ictlno1, [ictlno2] [, ictlno3] ...)"
                },
                {
                    "description": "Loads a preset of values for MIDI controllers.",
                    "synopsis": " **ctrlselect** kpre",
                    "opcodeName": "ctrlselect",
                    "functionalSynopsis": " = **ctrlselect:unknown**(kpre)"
                },
                {
                    "description": "Initializes the controllers used to create a 14-bit MIDI value.",
                    "synopsis": "**initc14** ichan, ictlno1, ictlno2, ivalue",
                    "opcodeName": "initc14",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initializes the controllers used to create a 21-bit MIDI value.",
                    "synopsis": "**initc21** ichan, ictlno1, ictlno2, ictlno3, ivalue",
                    "opcodeName": "initc21",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initializes the controller used to create a 7-bit MIDI value.",
                    "synopsis": "**initc7** ichan, ictlno, ivalue",
                    "opcodeName": "initc7",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Assigns a MIDI channel number to a Csound instrument.",
                    "synopsis": "**massign** ichnl, insnum[, ireset]\n**massign** ichnl, &quot;insname&quot;[, ireset]",
                    "opcodeName": "massign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **midic14** ictlno1, ictlno2, imin, imax [, ifn]\nkdest **midic14** ictlno1, ictlno2, kmin, kmax [, ifn]",
                    "opcodeName": "midic14",
                    "functionalSynopsis": "idest = **midic14:unknown**(ictlno1, ictlno2, imin, imax [, ifn])\nkdest = **midic14:k**(ictlno1, ictlno2, kmin, kmax [, ifn])"
                },
                {
                    "description": "Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **midic21** ictlno1, ictlno2, ictlno3, imin, imax [, ifn]\nkdest **midic21** ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]",
                    "opcodeName": "midic21",
                    "functionalSynopsis": "idest = **midic21:unknown**(ictlno1, ictlno2, ictlno3, imin, imax [, ifn])\nkdest = **midic21:k**(ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn])"
                },
                {
                    "description": "Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range.",
                    "synopsis": "idest **midic7** ictlno, imin, imax [, ifn]\nkdest **midic7** ictlno, kmin, kmax [, ifn]",
                    "opcodeName": "midic7",
                    "functionalSynopsis": "idest = **midic7:unknown**(ictlno, imin, imax [, ifn])\nkdest = **midic7:k**(ictlno, kmin, kmax [, ifn])"
                },
                {
                    "description": "Get the current value (0-127) of a specified MIDI controller.",
                    "synopsis": "ival **midictrl** inum [, imin] [, imax]\nkval **midictrl** inum [, imin] [, imax]",
                    "opcodeName": "midictrl",
                    "functionalSynopsis": "ival = **midictrl:unknown**(inum [, imin] [, imax])\nkval = **midictrl:k**(inum [, imin] [, imax])"
                },
                {
                    "description": "Get a note number from a MIDI event.",
                    "synopsis": "ival **notnum**",
                    "opcodeName": "notnum",
                    "functionalSynopsis": "ival = **notnum:unknown**()"
                },
                {
                    "description": "Get the current pitch-bend value for this channel.",
                    "synopsis": "ibend **pchbend** [imin] [, imax]\nkbend **pchbend** [imin] [, imax]",
                    "opcodeName": "pchbend",
                    "functionalSynopsis": "ibend = **pchbend:unknown**([imin] [, imax])\nkbend = **pchbend:k**([imin] [, imax])"
                },
                {
                    "description": "Assigns an instrument number to a specified MIDI program.",
                    "synopsis": "**pgmassign** ipgm, inst[, ichn]\n**pgmassign** ipgm, &quot;insname&quot;[, ichn]",
                    "opcodeName": "pgmassign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the polyphonic after-touch pressure of the selected note number.",
                    "synopsis": "ires **polyaft** inote [, ilow] [, ihigh]\nkres **polyaft** inote [, ilow] [, ihigh]",
                    "opcodeName": "polyaft",
                    "functionalSynopsis": "ires = **polyaft:unknown**(inote [, ilow] [, ihigh])\nkres = **polyaft:k**(inote [, ilow] [, ihigh])"
                },
                {
                    "description": "Get the velocity from a MIDI event.",
                    "synopsis": "ival **veloc** [ilow] [, ihigh]",
                    "opcodeName": "veloc",
                    "functionalSynopsis": "ival = **veloc:unknown**([ilow] [, ihigh])"
                }
            ]
        },
        {
            "category": "Real-time MIDI:Output",
            "opcodes": [
                {
                    "description": "Sends a Non-Registered Parameter Number to the MIDI OUT port.",
                    "synopsis": "**nrpn** kchan, kparmnum, kparmvalue",
                    "opcodeName": "nrpn",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI aftertouch messages at i-rate.",
                    "synopsis": "**outiat** ichn, ivalue, imin, imax",
                    "opcodeName": "outiat",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI controller output at i-rate.",
                    "synopsis": "**outic** ichn, inum, ivalue, imin, imax",
                    "opcodeName": "outic",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends 14-bit MIDI controller output at i-rate.",
                    "synopsis": "**outic14** ichn, imsb, ilsb, ivalue, imin, imax",
                    "opcodeName": "outic14",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends polyphonic MIDI aftertouch messages at i-rate.",
                    "synopsis": "**outipat** ichn, inotenum, ivalue, imin, imax",
                    "opcodeName": "outipat",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI pitch-bend messages at i-rate.",
                    "synopsis": "**outipb** ichn, ivalue, imin, imax",
                    "opcodeName": "outipb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI program change messages at i-rate",
                    "synopsis": "**outipc** ichn, iprog, imin, imax",
                    "opcodeName": "outipc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI aftertouch messages at k-rate.",
                    "synopsis": "**outkat** kchn, kvalue, kmin, kmax",
                    "opcodeName": "outkat",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI controller messages at k-rate.",
                    "synopsis": "**outkc** kchn, knum, kvalue, kmin, kmax",
                    "opcodeName": "outkc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends 14-bit MIDI controller output at k-rate.",
                    "synopsis": "**outkc14** kchn, kmsb, klsb, kvalue, kmin, kmax",
                    "opcodeName": "outkc14",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends polyphonic MIDI aftertouch messages at k-rate.",
                    "synopsis": "**outkpat** kchn, knotenum, kvalue, kmin, kmax",
                    "opcodeName": "outkpat",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI pitch-bend messages at k-rate.",
                    "synopsis": "**outkpb** kchn, kvalue, kmin, kmax",
                    "opcodeName": "outkpb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends MIDI program change messages at k-rate.",
                    "synopsis": "**outkpc** kchn, kprog, kmin, kmax",
                    "opcodeName": "outkpc",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:Converters",
            "opcodes": [
                {
                    "description": "Get the velocity of the current MIDI event.",
                    "synopsis": "iamp **ampmidi** iscal [, ifn]",
                    "opcodeName": "ampmidi",
                    "functionalSynopsis": "iamp = **ampmidi:unknown**(iscal [, ifn])"
                },
                {
                    "description": "Maps an input MIDI velocity number to an output gain factor with a\n        maximum value of 1, modifying the output gain by a dynamic range and a\n        shaping exponent.",
                    "synopsis": "igain **ampmidicurve** ivelocity, idynamicrange, iexponent\nkgain **ampmidicurve** kvelocity, kdynamicrange, kexponent",
                    "opcodeName": "ampmidicurve",
                    "functionalSynopsis": "igain = **ampmidicurve:unknown**(ivelocity, idynamicrange, iexponent)\nkgain = **ampmidicurve:k**(kvelocity, kdynamicrange, kexponent)"
                },
                {
                    "description": "Musically map MIDI velocity to peak amplitude within a specified dynamic range in decibels.",
                    "synopsis": "iamplitude **ampmidid** ivelocity, idecibels\nkamplitude **ampmidid** kvelocity, idecibels",
                    "opcodeName": "ampmidid",
                    "functionalSynopsis": "iamplitude = **ampmidid:unknown**(ivelocity, idecibels)\nkamplitude = **ampmidid:k**(kvelocity, idecibels)"
                },
                {
                    "description": "Get the note number of the current MIDI event, expressed in cycles-per-second.",
                    "synopsis": "icps **cpsmidi**",
                    "opcodeName": "cpsmidi",
                    "functionalSynopsis": "icps = **cpsmidi:unknown**()"
                },
                {
                    "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in cycles-per-second.",
                    "synopsis": "icps **cpsmidib** [irange]\nkcps **cpsmidib** [irange]",
                    "opcodeName": "cpsmidib",
                    "functionalSynopsis": "icps = **cpsmidib:unknown**([irange])\nkcps = **cpsmidib:k**([irange])"
                },
                {
                    "description": "Get a MIDI note number (allows customized micro-tuning scales).",
                    "synopsis": "icps **cpstmid** ifn",
                    "opcodeName": "cpstmid",
                    "functionalSynopsis": "icps = **cpstmid:unknown**(ifn)"
                },
                {
                    "description": "Get the note number, in octave-point-decimal units, of the current MIDI event.",
                    "synopsis": "ioct **octmidi**",
                    "opcodeName": "octmidi",
                    "functionalSynopsis": "ioct = **octmidi:unknown**()"
                },
                {
                    "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in octave-point-decimal.",
                    "synopsis": "ioct **octmidib** [irange]\nkoct **octmidib** [irange]",
                    "opcodeName": "octmidib",
                    "functionalSynopsis": "ioct = **octmidib:unknown**([irange])\nkoct = **octmidib:k**([irange])"
                },
                {
                    "description": "Get the note number of the current MIDI event, expressed in pitch-class units.",
                    "synopsis": "ipch **pchmidi**",
                    "opcodeName": "pchmidi",
                    "functionalSynopsis": "ipch = **pchmidi:unknown**()"
                },
                {
                    "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in pitch-class units.",
                    "synopsis": "ipch **pchmidib** [irange]\nkpch **pchmidib** [irange]",
                    "opcodeName": "pchmidib",
                    "functionalSynopsis": "ipch = **pchmidib:unknown**([irange])\nkpch = **pchmidib:k**([irange])"
                }
            ]
        },
        {
            "category": "Real-time MIDI:Generic I/O",
            "opcodes": [
                {
                    "description": "Returns a generic MIDI message received by the MIDI IN port.",
                    "synopsis": "kstatus, kchan, kdata1, kdata2 **midiin**",
                    "opcodeName": "midiin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a generic MIDI message to the MIDI OUT port.",
                    "synopsis": "**midiout** kstatus, kchan, kdata1, kdata2",
                    "opcodeName": "midiout",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a generic MIDI message to the MIDI OUT port.",
                    "synopsis": "**midiout_i** istatus, ichan, idata1, idata2",
                    "opcodeName": "midiout_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:Event Extenders",
            "opcodes": [
                {
                    "description": "Indicates whether an event is in its last performance cycle.",
                    "synopsis": "kflag **lastcycle**",
                    "opcodeName": "lastcycle",
                    "functionalSynopsis": "kflag = **lastcycle:k**()"
                },
                {
                    "description": "Indicates whether a note is in its",
                    "synopsis": "kflag **release**",
                    "opcodeName": "release",
                    "functionalSynopsis": "kflag = **release:k**()"
                },
                {
                    "description": "Extend the duration of real-time generated events.",
                    "synopsis": "**xtratim** iextradur",
                    "opcodeName": "xtratim",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:Note Output",
            "opcodes": [
                {
                    "description": "Generates arpeggios based on currently held MIDI notes.",
                    "synopsis": "kMidiNoteNum, kTrigger **midiarp** kRate[, kMode]",
                    "opcodeName": "midiarp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generates MIDI note messages at k-rate.",
                    "synopsis": "**midion** kchn, knum, kvel",
                    "opcodeName": "midion",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends noteon and noteoff messages to the MIDI OUT port.",
                    "synopsis": "**midion2** kchn, knum, kvel, ktrig",
                    "opcodeName": "midion2",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a stream of the MIDI notes.",
                    "synopsis": "**moscil** kchn, knum, kvel, kdur, kpause",
                    "opcodeName": "moscil",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Send a noteoff message to the MIDI OUT port.",
                    "synopsis": "**noteoff** ichn, inum, ivel",
                    "opcodeName": "noteoff",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Send a noteon message to the MIDI OUT port.",
                    "synopsis": "**noteon** ichn, inum, ivel",
                    "opcodeName": "noteon",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity.",
                    "synopsis": "**noteondur** ichn, inum, ivel, idur",
                    "opcodeName": "noteondur",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity.",
                    "synopsis": "**noteondur2** ichn, inum, ivel, idur",
                    "opcodeName": "noteondur2",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:MIDI/Score Interoperability",
            "opcodes": [
                {
                    "description": "Gets a MIDI channel's aftertouch value.",
                    "synopsis": "**midichannelaftertouch** xchannelaftertouch [, ilow] [, ihigh]",
                    "opcodeName": "midichannelaftertouch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the MIDI channel number from which the note was activated.",
                    "synopsis": "ichn **midichn**",
                    "opcodeName": "midichn",
                    "functionalSynopsis": "ichn = **midichn:unknown**()"
                },
                {
                    "description": "Gets a MIDI control change value.",
                    "synopsis": "**midicontrolchange** xcontroller, xcontrollervalue [, ilow] [, ihigh]",
                    "opcodeName": "midicontrolchange",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Changes values, depending on MIDI activation.",
                    "synopsis": "**mididefault** xdefault, xvalue",
                    "opcodeName": "mididefault",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI noteoff value.",
                    "synopsis": "**midinoteoff** xkey, xvelocity",
                    "opcodeName": "midinoteoff",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI note number as a cycles-per-second frequency.",
                    "synopsis": "**midinoteoncps** xcps, xvelocity",
                    "opcodeName": "midinoteoncps",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI note number value.",
                    "synopsis": "**midinoteonkey** xkey, xvelocity",
                    "opcodeName": "midinoteonkey",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI note number value as octave-point-decimal value.",
                    "synopsis": "**midinoteonoct** xoct, xvelocity",
                    "opcodeName": "midinoteonoct",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI note number as a pitch-class value.",
                    "synopsis": "**midinoteonpch** xpch, xvelocity",
                    "opcodeName": "midinoteonpch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI pitchbend value.",
                    "synopsis": "**midipitchbend** xpitchbend [, ilow] [, ihigh]",
                    "opcodeName": "midipitchbend",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI polyphonic aftertouch value.",
                    "synopsis": "**midipolyaftertouch** xpolyaftertouch, xkey [, ilow] [, ihigh]",
                    "opcodeName": "midipolyaftertouch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a MIDI program change value.",
                    "synopsis": "**midiprogramchange** xprogram",
                    "opcodeName": "midiprogramchange",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:System Realtime",
            "opcodes": [
                {
                    "description": "Sends a MIDI CLOCK message.",
                    "synopsis": "**mclock** ifreq",
                    "opcodeName": "mclock",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Send system real-time messages to the MIDI OUT port.",
                    "synopsis": "**mrtmsg** imsgtype",
                    "opcodeName": "mrtmsg",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Real-time MIDI:Slider Banks",
            "opcodes": [
                {
                    "description": "Creates a bank of 16 different 14-bit MIDI control message numbers.",
                    "synopsis": "i1,...,i16 **s16b14** ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n      initvalue1, ifn1,..., ictlno_msb16, ictlno_lsb16, imin16, imax16, initvalue16, ifn16\nk1,...,k16 **s16b14** ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n      initvalue1, ifn1,..., ictlno_msb16, ictlno_lsb16, imin16, imax16, initvalue16, ifn16",
                    "opcodeName": "s16b14",
                    "functionalSynopsis": "i1,...,i16 = **s16b14:unknown**(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\)\nk1,...,k16 = **s16b14:k**(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 32 different 14-bit MIDI control message numbers.",
                    "synopsis": "i1,...,i32 **s32b14** ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n      initvalue1, ifn1,..., ictlno_msb32, ictlno_lsb32, imin32, imax32, initvalue32, ifn32\nk1,...,k32 **s32b14** ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n      initvalue1, ifn1,..., ictlno_msb32, ictlno_lsb32, imin32, imax32, initvalue32, ifn32",
                    "opcodeName": "s32b14",
                    "functionalSynopsis": "i1,...,i32 = **s32b14:unknown**(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\)\nk1,...,k32 = **s32b14:k**(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 16 different MIDI control message numbers.",
                    "synopsis": "i1,...,i16 **slider16** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum16, imin16, imax16, init16, ifn16\nk1,...,k16 **slider16** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum16, imin16, imax16, init16, ifn16",
                    "opcodeName": "slider16",
                    "functionalSynopsis": "i1,...,i16 = **slider16:unknown**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)\nk1,...,k16 = **slider16:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)"
                },
                {
                    "description": "Creates a bank of 16 different MIDI control message numbers, filtered before output.",
                    "synopsis": "k1,...,k16 **slider16f** ichan, ictlnum1, imin1, imax1, init1, ifn1, \\\n      icutoff1,..., ictlnum16, imin16, imax16, init16, ifn16, icutoff16",
                    "opcodeName": "slider16f",
                    "functionalSynopsis": "k1,...,k16 = **slider16f:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1, \\)"
                },
                {
                    "description": "Stores a bank of 16 different MIDI control messages to a table.",
                    "synopsis": "kflag **slider16table** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1, .... , ictlnum16, imin16, imax16, init16, ifn16",
                    "opcodeName": "slider16table",
                    "functionalSynopsis": "kflag = **slider16table:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Stores a bank of 16 different MIDI control messages to a table, filtered before output.",
                    "synopsis": "kflag **slider16tablef** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1, icutoff1, .... , ictlnum16, imin16, imax16, init16, ifn16, icutoff16",
                    "opcodeName": "slider16tablef",
                    "functionalSynopsis": "kflag = **slider16tablef:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 32 different MIDI control message numbers.",
                    "synopsis": "i1,...,i32 **slider32** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum32, imin32, imax32, init32, ifn32\nk1,...,k32 **slider32** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum32, imin32, imax32, init32, ifn32",
                    "opcodeName": "slider32",
                    "functionalSynopsis": "i1,...,i32 = **slider32:unknown**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)\nk1,...,k32 = **slider32:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)"
                },
                {
                    "description": "Creates a bank of 32 different MIDI control message numbers, filtered before output.",
                    "synopsis": "k1,...,k32 **slider32f** ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n      ..., ictlnum32, imin32, imax32, init32, ifn32, icutoff32",
                    "opcodeName": "slider32f",
                    "functionalSynopsis": "k1,...,k32 = **slider32f:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\)"
                },
                {
                    "description": "Stores a bank of 32 different MIDI control messages to a table.",
                    "synopsis": "kflag **slider32table** ichan, ioutTable, ioffset, ictlnum1, imin1, \\\n      imax1, init1, ifn1, .... , ictlnum32, imin32, imax32, init32, ifn32",
                    "opcodeName": "slider32table",
                    "functionalSynopsis": "kflag = **slider32table:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, \\)"
                },
                {
                    "description": "Stores a bank of 32 different MIDI control messages to a table, filtered before output.",
                    "synopsis": "kflag **slider32tablef** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1, icutoff1, .... , ictlnum32, imin32, imax32, init32, ifn32, icutoff32",
                    "opcodeName": "slider32tablef",
                    "functionalSynopsis": "kflag = **slider32tablef:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 64 different MIDI control message numbers.",
                    "synopsis": "i1,...,i64 **slider64** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum64, imin64, imax64, init64, ifn64\nk1,...,k64 **slider64** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum64, imin64, imax64, init64, ifn64",
                    "opcodeName": "slider64",
                    "functionalSynopsis": "i1,...,i64 = **slider64:unknown**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)\nk1,...,k64 = **slider64:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)"
                },
                {
                    "description": "Creates a bank of 64 different MIDI control message numbers, filtered before output.",
                    "synopsis": "k1,...,k64 **slider64f** ichan, ictlnum1, imin1, imax1, init1, ifn1, \\\n      icutoff1,..., ictlnum64, imin64, imax64, init64, ifn64, icutoff64",
                    "opcodeName": "slider64f",
                    "functionalSynopsis": "k1,...,k64 = **slider64f:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1, \\)"
                },
                {
                    "description": "Stores a bank of 64 different MIDI control messages to a table.",
                    "synopsis": "kflag **slider64table** ichan, ioutTable, ioffset, ictlnum1, imin1, \\\n      imax1, init1, ifn1, .... , ictlnum64, imin64, imax64, init64, ifn64",
                    "opcodeName": "slider64table",
                    "functionalSynopsis": "kflag = **slider64table:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, \\)"
                },
                {
                    "description": "Stores a bank of 64 different MIDI control messages to a table, filtered before output.",
                    "synopsis": "kflag **slider64tablef** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1, icutoff1, .... , ictlnum64, imin64, imax64, init64, ifn64, icutoff64",
                    "opcodeName": "slider64tablef",
                    "functionalSynopsis": "kflag = **slider64tablef:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 8 different MIDI control message numbers.",
                    "synopsis": "i1,...,i8 **slider8** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum8, imin8, imax8, init8, ifn8\nk1,...,k8 **slider8** ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\\n      ictlnum8, imin8, imax8, init8, ifn8",
                    "opcodeName": "slider8",
                    "functionalSynopsis": "i1,...,i8 = **slider8:unknown**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)\nk1,...,k8 = **slider8:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \\)"
                },
                {
                    "description": "Creates a bank of 8 different MIDI control message numbers, filtered before output.",
                    "synopsis": "k1,...,k8 **slider8f** ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n      ..., ictlnum8, imin8, imax8, init8, ifn8, icutoff8",
                    "opcodeName": "slider8f",
                    "functionalSynopsis": "k1,...,k8 = **slider8f:k**(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\)"
                },
                {
                    "description": "Stores a bank of 8 different MIDI control messages to a table.",
                    "synopsis": "kflag **slider8table** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1,..., ictlnum8, imin8, imax8, init8, ifn8",
                    "opcodeName": "slider8table",
                    "functionalSynopsis": "kflag = **slider8table:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Stores a bank of 8 different MIDI control messages to a table, filtered before output.",
                    "synopsis": "kflag **slider8tablef** ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n      init1, ifn1, icutoff1, .... , ictlnum8, imin8, imax8, init8, ifn8, icutoff8",
                    "opcodeName": "slider8tablef",
                    "functionalSynopsis": "kflag = **slider8tablef:k**(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\)"
                },
                {
                    "description": "Creates a bank of 16 different MIDI control message numbers from a KAWAI MM-16 midi mixer.",
                    "synopsis": "k1, k2, ...., k16 **sliderKawai** imin1, imax1, init1, ifn1, \\\n      imin2, imax2, init2, ifn2, ..., imin16, imax16, init16, ifn16",
                    "opcodeName": "sliderKawai",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Signal Flow Graph Opcodes",
            "opcodes": [
                {
                    "description": "Activates the indicated instrument in the orchestra header,\n      without need for an i statement.",
                    "synopsis": " **alwayson** Tinstrument [p4, ..., pn]",
                    "opcodeName": "alwayson",
                    "functionalSynopsis": " = **alwayson:unknown**(Tinstrument [p4, ..., pn])"
                },
                {
                    "description": "Connects a source outlet to a sink inlet.",
                    "synopsis": "**connect **Tsource1, Soutlet1, Tsink1, Sinlet1",
                    "opcodeName": "connect ",
                    "functionalSynopsis": "**connect = **Tsource1,:unknown**(Soutlet1, Tsink1, Sinlet1)"
                },
                {
                    "description": "Generate a function table from within an instrument definition, without duplication of data.",
                    "synopsis": "ifno **ftgenonce** ip1, ip2dummy, isize, igen, iarga, iargb, ...",
                    "opcodeName": "ftgenonce",
                    "functionalSynopsis": "ifno = **ftgenonce:unknown**(ip1, ip2dummy, isize, igen, iarga, iargb, ...)"
                },
                {
                    "description": "Receives an arate signal into an instrument through a named port.",
                    "synopsis": "asignal **inleta **Sname",
                    "opcodeName": "inleta ",
                    "functionalSynopsis": "asignal = **inleta:a**(**Sname)"
                },
                {
                    "description": "Receives an frate signal (fsig) into an instrument from a named port.",
                    "synopsis": "fsignal **inletf **Sname",
                    "opcodeName": "inletf ",
                    "functionalSynopsis": "fsignal = **inletf:unknown**(**Sname)"
                },
                {
                    "description": "Receives a krate signal into an instrument from a named port.",
                    "synopsis": "ksignal **inletk **Sname",
                    "opcodeName": "inletk ",
                    "functionalSynopsis": "ksignal = **inletk:k**(**Sname)"
                },
                {
                    "description": "Receives a krate signal into an instrument from a named port.",
                    "synopsis": "ksignal **inletkid **Sname, SinstanceID",
                    "opcodeName": "inletkid ",
                    "functionalSynopsis": "ksignal = **inletkid:k**(**Sname, SinstanceID)"
                },
                {
                    "description": "Receives an arate array signal into an instrument through a named port.",
                    "synopsis": "array **inletv **Sname",
                    "opcodeName": "inletv ",
                    "functionalSynopsis": "array = **inletv:a**(**Sname)"
                },
                {
                    "description": "Sends an arate signal out from an instrument to a named port.",
                    "synopsis": "**outleta **Sname, asignal",
                    "opcodeName": "outleta ",
                    "functionalSynopsis": "**outleta = **Sname,:unknown**(asignal)"
                },
                {
                    "description": "Sends a frate signal (fsig) out from an instrument to a named port.",
                    "synopsis": "**outletf **Sname, fsignal",
                    "opcodeName": "outletf ",
                    "functionalSynopsis": "**outletf = **Sname,:unknown**(fsignal)"
                },
                {
                    "description": "Sends a krate signal out from an instrument to a named port.",
                    "synopsis": "**outletk **Sname, ksignal",
                    "opcodeName": "outletk ",
                    "functionalSynopsis": "**outletk = **Sname,:unknown**(ksignal)"
                },
                {
                    "description": "Sends a krate signal out from an instrument to a named port.",
                    "synopsis": "**outletkid **Sname, SinstanceID, ksignal",
                    "opcodeName": "outletkid ",
                    "functionalSynopsis": "**outletkid = **Sname,:unknown**(SinstanceID, ksignal)"
                },
                {
                    "description": "Sends an arate array signal out from an instrument to a named port.",
                    "synopsis": "**outletv **Sname, array",
                    "opcodeName": "outletv ",
                    "functionalSynopsis": "**outletv = **Sname,:unknown**(array)"
                }
            ]
        },
        {
            "category": "Spectral Processing:STFT",
            "opcodes": [
                {
                    "description": "Deprecated.",
                    "synopsis": "**ktableseg** ifn1, idur1, ifn2 [, idur2] [, ifn3] [...]",
                    "opcodeName": "ktableseg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads from a",
                    "synopsis": "ares **pvadd** ktimpnt, kfmod, ifilcod, ifn, ibins [, ibinoffset] \\\n      [, ibinincr] [, iextractmode] [, ifreqlim] [, igatefn]",
                    "opcodeName": "pvadd",
                    "functionalSynopsis": "ares = **pvadd:a**(ktimpnt, kfmod, ifilcod, ifn, ibins [, ibinoffset] \\)"
                },
                {
                    "description": "Reads from a phase vocoder analysis file and makes the retrieved data available.",
                    "synopsis": "**pvbufread** ktimpnt, ifile",
                    "opcodeName": "pvbufread",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Applies the amplitudes from one phase vocoder analysis file to the data from a second file.",
                    "synopsis": "ares **pvcross** ktimpnt, kfmod, ifile, kampscale1, kampscale2 [, ispecwp]",
                    "opcodeName": "pvcross",
                    "functionalSynopsis": "ares = **pvcross:a**(ktimpnt, kfmod, ifile, kampscale1, kampscale2 [, ispecwp])"
                },
                {
                    "description": "Interpolates between the amplitudes and frequencies of two phase vocoder analysis files.",
                    "synopsis": "ares **pvinterp** ktimpnt, kfmod, ifile, kfreqscale1, kfreqscale2, \\\n      kampscale1, kampscale2, kfreqinterp, kampinterp",
                    "opcodeName": "pvinterp",
                    "functionalSynopsis": "ares = **pvinterp:a**(ktimpnt, kfmod, ifile, kfreqscale1, kfreqscale2, \\)"
                },
                {
                    "description": "Implements signal reconstruction using an fft-based phase vocoder.",
                    "synopsis": "ares **pvoc** ktimpnt, kfmod, ifilcod [, ispecwp] [, iextractmode] \\\n      [, ifreqlim] [, igatefn]",
                    "opcodeName": "pvoc",
                    "functionalSynopsis": "ares = **pvoc:a**(ktimpnt, kfmod, ifilcod [, ispecwp] [, iextractmode] \\)"
                },
                {
                    "description": "Reads from a phase vocoder analysis file and returns the frequency and amplitude from a single analysis channel or bin.",
                    "synopsis": "kfreq, kamp **pvread** ktimpnt, ifile, ibin",
                    "opcodeName": "pvread",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a new function table by making linear segments between values in stored function tables.",
                    "synopsis": "**tableseg** ifn1, idur1, ifn2 [, idur2] [, ifn3] [...]",
                    "opcodeName": "tableseg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a new function table by making exponential segments between values in stored function tables.",
                    "synopsis": "**tablexseg** ifn1, idur1, ifn2 [, idur2] [, ifn3] [...]",
                    "opcodeName": "tablexseg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Implements signal reconstruction using an fft-based phase vocoder and an extra envelope.",
                    "synopsis": "ares **vpvoc** ktimpnt, kfmod, ifile [, ispecwp] [, ifn]",
                    "opcodeName": "vpvoc",
                    "functionalSynopsis": "ares = **vpvoc:a**(ktimpnt, kfmod, ifile [, ispecwp] [, ifn])"
                }
            ]
        },
        {
            "category": "Spectral Processing:LPC",
            "opcodes": [
                {
                    "description": "Allpole filter implementation using direct convolution.",
                    "synopsis": "ares **allpole** asig, kCoef[]",
                    "opcodeName": "allpole",
                    "functionalSynopsis": "ares = **allpole:a**(asig, kCoef[])"
                },
                {
                    "description": "Extracts allpole filter parameters from coefficients.",
                    "synopsis": "kPar[]**apoleparams** kCoef[] ",
                    "opcodeName": "apoleparams",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Streaming linear prediction analysis.",
                    "synopsis": "kCoef[],krms,kerr,kcps **lpcanal** asrc, kflg,\n    kprd, isiz, iord[,iwin] \nkCoef[],krms,kerr,kcps **lpcanal** koff, kflg,\n    ifn, isiz, iord[,iwin] \niCoef[],irms,ierr,icps **lpcanal** ioff, iflg,\n    ifn, isiz, iord[,iwin] ",
                    "opcodeName": "lpcanal",
                    "functionalSynopsis": "kCoef[],krms,kerr,kcps = **lpcanal:k**(asrc, kflg,)\nkCoef[],krms,kerr,kcps = **lpcanal:k**(koff, kflg,)\niCoef[],irms,ierr,icps = **lpcanal:unknown**(ioff, iflg,)"
                },
                {
                    "description": "Streaming linear prediction all-pole filter.",
                    "synopsis": "ares **lpcfilter** asig, asrc, kflg,\n    kprd, isiz, iord[,iwin] \nares **lpcfilter** asig, koff, kflg,\n    ifn, isiz, iord[,iwin] ",
                    "opcodeName": "lpcfilter",
                    "functionalSynopsis": "ares = **lpcfilter:a**(asig, asrc, kflg,)\nares = **lpcfilter:a**(asig, koff, kflg,)"
                },
                {
                    "description": "Resynthesises a signal from the data passed internally by a previous lpread, applying formant shifting.",
                    "synopsis": "ares **lpfreson** asig, kfrqratio",
                    "opcodeName": "lpfreson",
                    "functionalSynopsis": "ares = **lpfreson:a**(asig, kfrqratio)"
                },
                {
                    "description": "Computes a new set of poles from the interpolation between two analysis.",
                    "synopsis": "**lpinterp** islot1, islot2, kmix",
                    "opcodeName": "lpinterp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a control file of time-ordered information frames.",
                    "synopsis": "krmsr, krmso, kerr, kcps **lpread** ktimpnt, ifilcod [, inpoles] [, ifrmrate]",
                    "opcodeName": "lpread",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Resynthesises a signal from the data passed internally by a previous lpread.",
                    "synopsis": "ares **lpreson** asig",
                    "opcodeName": "lpreson",
                    "functionalSynopsis": "ares = **lpreson:a**(asig)"
                },
                {
                    "description": "Selects the slot to be use by further lp opcodes.",
                    "synopsis": "**lpslot** islot",
                    "opcodeName": "lpslot",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Streaming linear prediction analysis.",
                    "synopsis": "fsig **pvslpc** asrc, idftsiz, ihop, iord[,iwin] ",
                    "opcodeName": "pvslpc",
                    "functionalSynopsis": "fsig = **pvslpc:unknown**(asrc, idftsiz, ihop, iord[,iwin] )"
                },
                {
                    "description": "A resonator filter bank.",
                    "synopsis": "asig**resonbnk** ain,\n    kPar[],kmin,kmax,iper[,imode,iscal,iskip] ",
                    "opcodeName": "resonbnk",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Spectral Processing:Non-Standard",
            "opcodes": [
                {
                    "description": "Perform a weighted add of two input spectra.",
                    "synopsis": "wsig **specaddm** wsig1, wsig2 [, imul2]",
                    "opcodeName": "specaddm",
                    "functionalSynopsis": "wsig = **specaddm:unknown**(wsig1, wsig2 [, imul2])"
                },
                {
                    "description": "Finds the positive difference values between consecutive spectral frames.",
                    "synopsis": "wsig **specdiff** wsigin",
                    "opcodeName": "specdiff",
                    "functionalSynopsis": "wsig = **specdiff:unknown**(wsigin)"
                },
                {
                    "description": "Displays the magnitude values of the spectrum.",
                    "synopsis": "**specdisp** wsig, iprd [, iwtflg]",
                    "opcodeName": "specdisp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Filters each channel of an input spectrum.",
                    "synopsis": "wsig **specfilt** wsigin, ifhtim",
                    "opcodeName": "specfilt",
                    "functionalSynopsis": "wsig = **specfilt:unknown**(wsigin, ifhtim)"
                },
                {
                    "description": "Accumulates the values of successive spectral frames.",
                    "synopsis": "wsig **spechist** wsigin",
                    "opcodeName": "spechist",
                    "functionalSynopsis": "wsig = **spechist:unknown**(wsigin)"
                },
                {
                    "description": "Estimates the pitch of the most prominent complex tone in the spectrum.",
                    "synopsis": "koct, kamp **specptrk** wsig, kvar, ilo, ihi, istr, idbthresh, inptls, \\\n      irolloff [, iodd] [, iconfs] [, interp] [, ifprd] [, iwtflg]",
                    "opcodeName": "specptrk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Scales an input spectral datablock with spectral envelopes.",
                    "synopsis": "wsig **specscal** wsigin, ifscale, ifthresh",
                    "opcodeName": "specscal",
                    "functionalSynopsis": "wsig = **specscal:unknown**(wsigin, ifscale, ifthresh)"
                },
                {
                    "description": "Sums the magnitudes across all channels of the spectrum.",
                    "synopsis": "ksum **specsum** wsig [, interp]",
                    "opcodeName": "specsum",
                    "functionalSynopsis": "ksum = **specsum:k**(wsig [, interp])"
                },
                {
                    "description": "Generate a constant-Q, exponentially-spaced DFT.",
                    "synopsis": "wsig **spectrum** xsig, iprd, iocts, ifrqa [, iq] [, ihann] [, idbout] \\\n      [, idsprd] [, idsinrs]",
                    "opcodeName": "spectrum",
                    "functionalSynopsis": "wsig = **spectrum:unknown**(xsig, iprd, iocts, ifrqa [, iq] [, ihann] [, idbout] \\)"
                }
            ]
        },
        {
            "category": "Spectral Processing:Streaming",
            "opcodes": [
                {
                    "description": "PVS tracks to amplitude+frequency conversion.",
                    "synopsis": "fsig **binit** fin, isize",
                    "opcodeName": "binit",
                    "functionalSynopsis": "fsig = **binit:unknown**(fin, isize)"
                },
                {
                    "description": "Generate an fsig from a mono audio source ain, using phase\n      vocoder overlap-add analysis and GPU hardware. Experimental and\n      only available as source code at the moment.",
                    "synopsis": "fsig **cudanal** ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit]",
                    "opcodeName": "cudanal",
                    "functionalSynopsis": "fsig = **cudanal:unknown**(ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit])"
                },
                {
                    "description": "Perform sliding phase vocoder algorithm with simplified\n      transformational FM using GPU hardware. Experimental and\n      only available as source code at the moment.",
                    "synopsis": "asig **cudasliding** ain, amod, iwinsize",
                    "opcodeName": "cudasliding",
                    "functionalSynopsis": "asig = **cudasliding:a**(ain, amod, iwinsize)"
                },
                {
                    "description": "Synthesis by additive synthesis and inverse FFT. Experimental and\n      only available as source code at the moment.",
                    "synopsis": "asig **cudasynth** kamp, kfreq, itab, iftab, iatab[, inum]\nasig **cudasynth** fsig, kamp, kfreq[, inum]\nasig **cudasynth** fsig",
                    "opcodeName": "cudasynth",
                    "functionalSynopsis": "asig = **cudasynth:a**(kamp, kfreq, itab, iftab, iatab[, inum])\nasig = **cudasynth:a**(fsig, kamp, kfreq[, inum])\nasig = **cudasynth:a**(fsig)"
                },
                {
                    "description": "Write a text file containing partial tracks data",
                    "synopsis": "**part2txt** SFile,ftrks",
                    "opcodeName": "part2txt",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Partial track spectral analysis.",
                    "synopsis": "ftrks **partials** ffr, fphs, kthresh, kminpts, kmaxgap, imaxtracks",
                    "opcodeName": "partials",
                    "functionalSynopsis": "ftrks = **partials:unknown**(ffr, fphs, kthresh, kminpts, kmaxgap, imaxtracks)"
                },
                {
                    "description": "Same as the pvs2tab opcode.",
                    "synopsis": "kframe **pvs2array** kvar[], fsig\nkframe **pvs2array** kmags[], kfreqs[], fsig",
                    "opcodeName": "pvs2array",
                    "functionalSynopsis": "kframe = **pvs2array:k**(kvar[], fsig)\nkframe = **pvs2array:k**(kmags[], kfreqs[], fsig)"
                },
                {
                    "description": "Copies spectral data to k-rate arrays (or t-variables). Also known as pvs2array.",
                    "synopsis": "kframe **pvs2tab** tvar|kvar[], fsig\nkframe **pvs2tab** kmags[], kfreqs[], fsig",
                    "opcodeName": "pvs2tab",
                    "functionalSynopsis": "kframe = **pvs2tab:k**(tvar|kvar[], fsig)\nkframe = **pvs2tab:k**(kmags[], kfreqs[], fsig)"
                },
                {
                    "description": "Resynthesize using a fast oscillator-bank.",
                    "synopsis": "ares **pvsadsyn** fsrc, inoscs, kfmod [, ibinoffset] [, ibinincr] [, iinit]",
                    "opcodeName": "pvsadsyn",
                    "functionalSynopsis": "ares = **pvsadsyn:a**(fsrc, inoscs, kfmod [, ibinoffset] [, ibinincr] [, iinit])"
                },
                {
                    "description": "Generate an fsig from a mono audio source ain, using phase vocoder overlap-add analysis.",
                    "synopsis": "fsig **pvsanal** ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit]",
                    "opcodeName": "pvsanal",
                    "functionalSynopsis": "fsig = **pvsanal:unknown**(ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit])"
                },
                {
                    "description": "Arpeggiate the spectral components of a streaming pv signal.",
                    "synopsis": "fsig **pvsarp** fsigin, kbin, kdepth, kgain",
                    "opcodeName": "pvsarp",
                    "functionalSynopsis": "fsig = **pvsarp:unknown**(fsigin, kbin, kdepth, kgain)"
                },
                {
                    "description": "A band pass filter working in the spectral domain.",
                    "synopsis": "fsig **pvsbandp** fsigin, xlowcut, xlowfull, \\\n      xhighfull, xhighcut[, ktype]",
                    "opcodeName": "pvsbandp",
                    "functionalSynopsis": "fsig = **pvsbandp:unknown**(fsigin, xlowcut, xlowfull, \\)"
                },
                {
                    "description": "A band reject filter working in the spectral domain.",
                    "synopsis": "fsig **pvsbandr** fsigin, xlowcut, xlowfull, \\\n      xhighfull, xhighcut[, ktype]",
                    "opcodeName": "pvsbandr",
                    "functionalSynopsis": "fsig = **pvsbandr:unknown**(fsigin, xlowcut, xlowfull, \\)"
                },
                {
                    "description": "Calculate the spectral bandwidth of a signal.",
                    "synopsis": "kbnd **pvsbandwidth** fsig",
                    "opcodeName": "pvsbandwidth",
                    "functionalSynopsis": "kbnd = **pvsbandwidth:k**(fsig)"
                },
                {
                    "description": "Obtain the amp and freq values off a PVS signal bin.",
                    "synopsis": "kamp, kfr **pvsbin** fsig, kbin",
                    "opcodeName": "pvsbin",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Average the amp/freq time functions of each analysis channel for\n    a specified time.",
                    "synopsis": "fsig **pvsblur** fsigin, kblurtime, imaxdel",
                    "opcodeName": "pvsblur",
                    "functionalSynopsis": "fsig = **pvsblur:unknown**(fsigin, kblurtime, imaxdel)"
                },
                {
                    "description": "This opcode creates and writes to a circular buffer for f-signals (streaming PV signals).",
                    "synopsis": "ihandle, ktime  **pvsbuffer** fsig, ilen ",
                    "opcodeName": "pvsbuffer",
                    "functionalSynopsis": ""
                },
                {
                    "description": "This opcode reads a circular buffer of f-signals (streaming PV signals).",
                    "synopsis": "fsig **pvsbufread**  ktime, khandle[, ilo, ihi, iclear] ",
                    "opcodeName": "pvsbufread",
                    "functionalSynopsis": "fsig = **pvsbufread:unknown**( ktime, khandle[, ilo, ihi, iclear] )"
                },
                {
                    "description": "This opcode reads a circular buffer of f-signals (streaming PV signals), with binwise additional delays.",
                    "synopsis": "fsig **pvsbufread2**  ktime, khandle, ift1, ift2 ",
                    "opcodeName": "pvsbufread2",
                    "functionalSynopsis": "fsig = **pvsbufread2:unknown**( ktime, khandle, ift1, ift2 )"
                },
                {
                    "description": "Scale the frequency components of a pv stream.",
                    "synopsis": "fsig **pvscale** fsigin, kscal[, kkeepform, kgain, kcoefs]",
                    "opcodeName": "pvscale",
                    "functionalSynopsis": "fsig = **pvscale:unknown**(fsigin, kscal[, kkeepform, kgain, kcoefs])"
                },
                {
                    "description": "Calculate the spectral centroid of a signal.",
                    "synopsis": "kcent **pvscent** fsig\nacent **pvscent** fsig",
                    "opcodeName": "pvscent",
                    "functionalSynopsis": "kcent = **pvscent:k**(fsig)\nacent = **pvscent:a**(fsig)"
                },
                {
                    "description": "Calculate the cepstrum of a pvs input, optionally liftering coefficients.",
                    "synopsis": "keps[] **pvsceps** fsig[, icoefs]",
                    "opcodeName": "pvsceps",
                    "functionalSynopsis": "keps[] = **pvsceps:k**(fsig[, icoefs])"
                },
                {
                    "description": "Performs cross-synthesis between two source fsigs.",
                    "synopsis": "fsig **pvscross** fsrc, fdest, kamp1, kamp2",
                    "opcodeName": "pvscross",
                    "functionalSynopsis": "fsig = **pvscross:unknown**(fsrc, fdest, kamp1, kamp2)"
                },
                {
                    "description": "Spectral azimuth-based de-mixing of stereo sources.",
                    "synopsis": "fsig **pvsdemix** fleft, fright, kpos, kwidth, ipoints",
                    "opcodeName": "pvsdemix",
                    "functionalSynopsis": "fsig = **pvsdemix:unknown**(fleft, fright, kpos, kwidth, ipoints)"
                },
                {
                    "description": "Read a selected channel from a PVOC-EX analysis file.",
                    "synopsis": "fsig **pvsdiskin** SFname,ktscal,kgain[,ioffset, ichan]",
                    "opcodeName": "pvsdiskin",
                    "functionalSynopsis": "fsig = **pvsdiskin:unknown**(SFname,ktscal,kgain[,ioffset, ichan])"
                },
                {
                    "description": "Displays a PVS signal as an amplitude vs. freq graph.",
                    "synopsis": "**pvsdisp** fsig[, ibins, iwtflg] ",
                    "opcodeName": "pvsdisp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Multiply amplitudes of a pvoc stream by those of a second\npvoc stream, with dynamic scaling.",
                    "synopsis": "fsig **pvsfilter** fsigin, fsigfil, kdepth[, igain]",
                    "opcodeName": "pvsfilter",
                    "functionalSynopsis": "fsig = **pvsfilter:unknown**(fsigin, fsigfil, kdepth[, igain])"
                },
                {
                    "description": "Read a selected channel from a PVOC-EX analysis file.",
                    "synopsis": "fsig **pvsfread** ktimpt, ifn [, ichan]",
                    "opcodeName": "pvsfread",
                    "functionalSynopsis": "fsig = **pvsfread:unknown**(ktimpt, ifn [, ichan])"
                },
                {
                    "description": "Freeze the amplitude and frequency time functions of a pv stream according to a control-rate\n      trigger.",
                    "synopsis": "fsig **pvsfreeze** fsigin, kfreeza, kfreezf",
                    "opcodeName": "pvsfreeze",
                    "functionalSynopsis": "fsig = **pvsfreeze:unknown**(fsigin, kfreeza, kfreezf)"
                },
                {
                    "description": "Same as the tab2pvs opcode.",
                    "synopsis": "fsig **pvsfromarray** karr[][,ihopsize, iwinsize, iwintype]\nfsig **pvsfromarray** kmags[], kfreqs[][,ihopsize, iwinsize, iwintype]",
                    "opcodeName": "pvsfromarray",
                    "functionalSynopsis": "fsig = **pvsfromarray:unknown**(karr[][,ihopsize, iwinsize, iwintype])\nfsig = **pvsfromarray:unknown**(kmags[], kfreqs[][,ihopsize, iwinsize, iwintype])"
                },
                {
                    "description": "Reads amplitude and/or frequency data from function tables.",
                    "synopsis": "**pvsftr** fsrc, ifna [, ifnf]",
                    "opcodeName": "pvsftr",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes amplitude and/or frequency data to function tables.",
                    "synopsis": "kflag **pvsftw** fsrc, ifna [, ifnf]",
                    "opcodeName": "pvsftw",
                    "functionalSynopsis": "kflag = **pvsftw:k**(fsrc, ifna [, ifnf])"
                },
                {
                    "description": "Write a fsig to a PVOCEX file.",
                    "synopsis": "**pvsfwrite** fsig, ifile",
                    "opcodeName": "pvsfwrite",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Scale the amplitude of a pv stream.",
                    "synopsis": "fsig **pvsgain** fsigin, kgain ",
                    "opcodeName": "pvsgain",
                    "functionalSynopsis": "fsig = **pvsgain:unknown**(fsigin, kgain )"
                },
                {
                    "description": "Shift the frequency components of a pv stream, stretching/compressing\n      its spectrum.",
                    "synopsis": "fsig **pvshift** fsigin, kshift, klowest[, kkeepform, igain, kcoefs]",
                    "opcodeName": "pvshift",
                    "functionalSynopsis": "fsig = **pvshift:unknown**(fsigin, kshift, klowest[, kkeepform, igain, kcoefs])"
                },
                {
                    "description": "Instantaneous Frequency Distribution, magnitude and phase analysis.",
                    "synopsis": "ffr,fphs **pvsifd** ain, ifftsize, ihopsize, iwintype[,iscal]",
                    "opcodeName": "pvsifd",
                    "functionalSynopsis": "ffr,fphs = **pvsifd:unknown**(ain, ifftsize, ihopsize, iwintype[,iscal])"
                },
                {
                    "description": "Retrieve an fsig from the input software bus; a pvs equivalent to chani.",
                    "synopsis": "fsig **pvsin** kchan[, isize, iolap, iwinsize, iwintype, iformat]",
                    "opcodeName": "pvsin",
                    "functionalSynopsis": "fsig = **pvsin:unknown**(kchan[, isize, iolap, iwinsize, iwintype, iformat])"
                },
                {
                    "description": "Get information from a PVOC-EX formatted source.",
                    "synopsis": "ioverlap, inumbins, iwinsize, iformat **pvsinfo** fsrc",
                    "opcodeName": "pvsinfo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initialise a spectral (f) variable to zero.",
                    "synopsis": "fsig **pvsinit** isize[, iolap, iwinsize, iwintype, iformat]",
                    "opcodeName": "pvsinit",
                    "functionalSynopsis": "fsig = **pvsinit:unknown**(isize[, iolap, iwinsize, iwintype, iformat])"
                },
                {
                    "description": "Modify amplitudes using a function table, with dynamic scaling.",
                    "synopsis": "fsig **pvsmaska** fsrc, ifn, kdepth",
                    "opcodeName": "pvsmaska",
                    "functionalSynopsis": "fsig = **pvsmaska:unknown**(fsrc, ifn, kdepth)"
                },
                {
                    "description": "Mix 'seamlessly' two pv signals.",
                    "synopsis": "fsig **pvsmix** fsigin1, fsigin2",
                    "opcodeName": "pvsmix",
                    "functionalSynopsis": "fsig = **pvsmix:unknown**(fsigin1, fsigin2)"
                },
                {
                    "description": "Smooth the amplitude and frequency time functions of a pv stream using parallel 1st order\n      lowpass IIR filters with time-varying cutoff frequency.",
                    "synopsis": "fsig **pvsmooth** fsigin, kacf, kfcf",
                    "opcodeName": "pvsmooth",
                    "functionalSynopsis": "fsig = **pvsmooth:unknown**(fsigin, kacf, kfcf)"
                },
                {
                    "description": "Performs morphing (or interpolation) between two source fsigs.",
                    "synopsis": "fsig **pvsmorph** fsig1, fsig2, kampint, kfrqint",
                    "opcodeName": "pvsmorph",
                    "functionalSynopsis": "fsig = **pvsmorph:unknown**(fsig1, fsig2, kampint, kfrqint)"
                },
                {
                    "description": "PVS-based oscillator simulator.",
                    "synopsis": "fsig **pvsosc** kamp, kfreq, ktype, isize [,ioverlap] [, iwinsize] [, iwintype] [, iformat]",
                    "opcodeName": "pvsosc",
                    "functionalSynopsis": "fsig = **pvsosc:unknown**(kamp, kfreq, ktype, isize [,ioverlap] [, iwinsize] [, iwintype] [, iformat])"
                },
                {
                    "description": "Write a fsig to the pvs output bus.",
                    "synopsis": "**pvsout** fsig, kchan",
                    "opcodeName": "pvsout",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Track the pitch and amplitude of a PVS signal.",
                    "synopsis": "kfr, kamp **pvspitch** fsig, kthresh",
                    "opcodeName": "pvspitch",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Phase vocoder analysis processing with onset detection/processing.",
                    "synopsis": "fsig **pvstanal** ktimescal, kamp, kpitch, ktab, [kdetect, kwrap, ioffset,ifftsize, ihop, idbthresh]\n      ",
                    "opcodeName": "pvstanal",
                    "functionalSynopsis": "fsig = **pvstanal:unknown**(ktimescal, kamp, kpitch, ktab, [kdetect, kwrap, ioffset,ifftsize, ihop, idbthresh])"
                },
                {
                    "description": "Transforms a pvoc stream according to a masking function table.",
                    "synopsis": "fsig **pvstencil** fsigin, kgain, klevel, iftable",
                    "opcodeName": "pvstencil",
                    "functionalSynopsis": "fsig = **pvstencil:unknown**(fsigin, kgain, klevel, iftable)"
                },
                {
                    "description": "Retain only the N loudest bins.",
                    "synopsis": "fsig **pvstrace** fsigin, kn \nfsig, kBins[] **pvstrace** fsigin, kn[,\n     isort, imin, imax] ",
                    "opcodeName": "pvstrace",
                    "functionalSynopsis": "fsig = **pvstrace:unknown**(fsigin, kn )"
                },
                {
                    "description": "Combine the spectral envelope of one fsig with the excitation (frequencies) of another.",
                    "synopsis": "fsig **pvsvoc** famp, fexc, kdepth, kgain [,kcoefs]",
                    "opcodeName": "pvsvoc",
                    "functionalSynopsis": "fsig = **pvsvoc:unknown**(famp, fexc, kdepth, kgain [,kcoefs])"
                },
                {
                    "description": "Warp the spectral envelope of a PVS signal",
                    "synopsis": "fsig **pvswarp** fsigin, kscal, kshift[, klowest, kmeth, kgain, kcoefs]",
                    "opcodeName": "pvswarp",
                    "functionalSynopsis": "fsig = **pvswarp:unknown**(fsigin, kscal, kshift[, klowest, kmeth, kgain, kcoefs])"
                },
                {
                    "description": "Resynthesise using a FFT overlap-add.",
                    "synopsis": "ares **pvsynth** fsrc, [iinit]",
                    "opcodeName": "pvsynth",
                    "functionalSynopsis": "ares = **pvsynth:a**(fsrc, [iinit])"
                },
                {
                    "description": "Streaming partial track additive synthesis with cubic phase interpolation with\npitch control and support for timescale-modified input",
                    "synopsis": "asig **resyn** fin, kscal, kpitch, kmaxtracks, ifn",
                    "opcodeName": "resyn",
                    "functionalSynopsis": "asig = **resyn:a**(fin, kscal, kpitch, kmaxtracks, ifn)"
                },
                {
                    "description": "Streaming partial track additive synthesis with cubic phase interpolation",
                    "synopsis": "asig **sinsyn** fin, kscal, kmaxtracks, ifn",
                    "opcodeName": "sinsyn",
                    "functionalSynopsis": "asig = **sinsyn:a**(fin, kscal, kmaxtracks, ifn)"
                },
                {
                    "description": "Copies spectral data from k-rate arrays (or t-variables.). Also known as pvsfromarray.",
                    "synopsis": "fsig **tab2pvs** tvar|karr[][,ihopsize, iwinsize, iwintype]\nfsig **tab2pvs** kmags[], kfreqs[][,ihopsize, iwinsize, iwintype]",
                    "opcodeName": "tab2pvs",
                    "functionalSynopsis": "fsig = **tab2pvs:unknown**(tvar|karr[][,ihopsize, iwinsize, iwintype])\nfsig = **tab2pvs:unknown**(kmags[], kfreqs[][,ihopsize, iwinsize, iwintype])"
                },
                {
                    "description": "Instantaneous Frequency Distribution, magnitude and phase analysis.",
                    "synopsis": "ffr,fphs **tabifd** ktimpt, kamp, kpitch, ifftsize, ihopsize, iwintype,ifn",
                    "opcodeName": "tabifd",
                    "functionalSynopsis": "ffr,fphs = **tabifd:unknown**(ktimpt, kamp, kpitch, ifftsize, ihopsize, iwintype,ifn)"
                },
                {
                    "description": "Streaming partial track additive synthesis",
                    "synopsis": "asig **tradsyn** fin, kscal, kpitch, kmaxtracks, ifn",
                    "opcodeName": "tradsyn",
                    "functionalSynopsis": "asig = **tradsyn:a**(fin, kscal, kpitch, kmaxtracks, ifn)"
                },
                {
                    "description": "Streaming partial track cross-synthesis.",
                    "synopsis": "fsig **trcross** fin1, fin2, ksearch, kdepth [, kmode] ",
                    "opcodeName": "trcross",
                    "functionalSynopsis": "fsig = **trcross:unknown**(fin1, fin2, ksearch, kdepth [, kmode] )"
                },
                {
                    "description": "Streaming partial track filtering.",
                    "synopsis": "fsig **trfilter** fin, kamnt, ifn",
                    "opcodeName": "trfilter",
                    "functionalSynopsis": "fsig = **trfilter:unknown**(fin, kamnt, ifn)"
                },
                {
                    "description": "Extracts the highest-frequency track from a streaming track input signal.",
                    "synopsis": "fsig, kfr, kamp **trhighest** fin1, kscal",
                    "opcodeName": "trhighest",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Extracts the lowest-frequency track from a streaming track input signal.",
                    "synopsis": "fsig, kfr, kamp **trlowest** fin1, kscal",
                    "opcodeName": "trlowest",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Streaming partial track mixing.",
                    "synopsis": "fsig **trmix** fin1, fin2 ",
                    "opcodeName": "trmix",
                    "functionalSynopsis": "fsig = **trmix:unknown**(fin1, fin2 )"
                },
                {
                    "description": "Streaming partial track frequency scaling.",
                    "synopsis": "fsig **trscale** fin, kpitch[, kgain]",
                    "opcodeName": "trscale",
                    "functionalSynopsis": "fsig = **trscale:unknown**(fin, kpitch[, kgain])"
                },
                {
                    "description": "Streaming partial track frequency scaling.",
                    "synopsis": "fsig **trshift** fin, kpshift[, kgain]",
                    "opcodeName": "trshift",
                    "functionalSynopsis": "fsig = **trshift:unknown**(fin, kpshift[, kgain])"
                },
                {
                    "description": "Streaming partial track frequency splitting.",
                    "synopsis": "fsiglow, fsighi **trsplit** fin, ksplit[, kgainlow, kgainhigh]",
                    "opcodeName": "trsplit",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Spectral Processing:ATS",
            "opcodes": [
                {
                    "description": "uses the data from an ATS analysis file to perform additive synthesis.",
                    "synopsis": "ar **ATSadd** ktimepnt, kfmod, iatsfile, ifn, ipartials[, ipartialoffset, \\\n        ipartialincr, igatefn]",
                    "opcodeName": "ATSadd",
                    "functionalSynopsis": "ar = **ATSadd:a**(ktimepnt, kfmod, iatsfile, ifn, ipartials[, ipartialoffset, \\)"
                },
                {
                    "description": "uses the data from an ATS analysis file to perform noise resynthesis.",
                    "synopsis": "ar **ATSaddnz** ktimepnt, iatsfile, ibands[, ibandoffset, ibandincr]",
                    "opcodeName": "ATSaddnz",
                    "functionalSynopsis": "ar = **ATSaddnz:a**(ktimepnt, iatsfile, ibands[, ibandoffset, ibandincr])"
                },
                {
                    "description": "reads data from and ATS data file and stores it in an internal data table of frequency, amplitude pairs.",
                    "synopsis": "**ATSbufread** ktimepnt, kfmod, iatsfile, ipartials[, ipartialoffset, \\\n          ipartialincr]",
                    "opcodeName": "ATSbufread",
                    "functionalSynopsis": ""
                },
                {
                    "description": "perform cross synthesis from ATS analysis files.",
                    "synopsis": "ar **ATScross** ktimepnt, kfmod, iatsfile, ifn, kmylev, kbuflev, ipartials \\\n          [, ipartialoffset, ipartialincr]",
                    "opcodeName": "ATScross",
                    "functionalSynopsis": "ar = **ATScross:a**(ktimepnt, kfmod, iatsfile, ifn, kmylev, kbuflev, ipartials \\)"
                },
                {
                    "description": "reads data out of the header of an ATS file.",
                    "synopsis": "idata **ATSinfo** iatsfile, ilocation",
                    "opcodeName": "ATSinfo",
                    "functionalSynopsis": "idata = **ATSinfo:unknown**(iatsfile, ilocation)"
                },
                {
                    "description": "allows a user to determine the frequency envelope of any",
                    "synopsis": "kamp **ATSinterpread** kfreq",
                    "opcodeName": "ATSinterpread",
                    "functionalSynopsis": "kamp = **ATSinterpread:k**(kfreq)"
                },
                {
                    "description": "returns a frequency, amplitude pair from an",
                    "synopsis": "kfrq, kamp **ATSpartialtap** ipartialnum",
                    "opcodeName": "ATSpartialtap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "reads data from an ATS file.",
                    "synopsis": "kfreq, kamp **ATSread** ktimepnt, iatsfile, ipartial",
                    "opcodeName": "ATSread",
                    "functionalSynopsis": ""
                },
                {
                    "description": "reads data from an ATS file.",
                    "synopsis": "kenergy **ATSreadnz** ktimepnt, iatsfile, iband",
                    "opcodeName": "ATSreadnz",
                    "functionalSynopsis": "kenergy = **ATSreadnz:k**(ktimepnt, iatsfile, iband)"
                },
                {
                    "description": "uses the data from an ATS analysis file to perform resynthesis.",
                    "synopsis": "ar **ATSsinnoi** ktimepnt, ksinlev, knzlev, kfmod, iatsfile, ipartials \\\n          [, ipartialoffset, ipartialincr]",
                    "opcodeName": "ATSsinnoi",
                    "functionalSynopsis": "ar = **ATSsinnoi:a**(ktimepnt, ksinlev, knzlev, kfmod, iatsfile, ipartials \\)"
                }
            ]
        },
        {
            "category": "Spectral Processing:Loris",
            "opcodes": [
                {
                    "description": "Morphs two stored sets of bandwidth-enhanced partials\n    and stores a new set of partials representing the morphed\n    sound. The morph is performed by linearly interpolating the\n    parameter envelopes (frequency, amplitude, and bandwidth, or\n    noisiness) of the bandwidth-enhanced partials according to\n    control-rate frequency, amplitude, and bandwidth morphing\n    functions.",
                    "synopsis": "**lorismorph** isrcidx, itgtidx, istoreidx, kfreqmorphenv, kampmorphenv, kbwmorphenv",
                    "opcodeName": "lorismorph",
                    "functionalSynopsis": ""
                },
                {
                    "description": "renders a stored set of bandwidth-enhanced partials using the method of Bandwidth-Enhanced Additive Synthesis implemented in the Loris software, applying control-rate frequency, amplitude, and bandwidth scaling envelopes.",
                    "synopsis": "ar **lorisplay** ireadidx, kfreqenv, kampenv, kbwenv",
                    "opcodeName": "lorisplay",
                    "functionalSynopsis": "ar = **lorisplay:a**(ireadidx, kfreqenv, kampenv, kbwenv)"
                },
                {
                    "description": "Imports a set of bandwidth-enhanced partials from a SDIF-format\n    data file, applying control-rate frequency, amplitude, and\n    bandwidth scaling envelopes, and stores the modified partials in\n    memory.",
                    "synopsis": "**lorisread** ktimpnt, ifilcod, istoreidx, kfreqenv, kampenv, kbwenv[, ifadetime]",
                    "opcodeName": "lorisread",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Spectral Processing:Other",
            "opcodes": [
                {
                    "description": "Calculate the spectral centroid of a signal.",
                    "synopsis": "kcent **centroid** asig, ktrig, ifftsize",
                    "opcodeName": "centroid",
                    "functionalSynopsis": "kcent = **centroid:k**(asig, ktrig, ifftsize)"
                },
                {
                    "description": "Phase-locked vocoder processing with onset detection/processing, 'tempo-scaling'.",
                    "synopsis": "asig[,asig2] **filescal** ktimescal, kamp, kpitch, Sfile, klock [,ifftsize, idecim, ithresh]\n      ",
                    "opcodeName": "filescal",
                    "functionalSynopsis": "asig[,asig2] = **filescal:a**(ktimescal, kamp, kpitch, Sfile, klock [,ifftsize, idecim, ithresh])"
                },
                {
                    "description": "Phase-locked vocoder processing.",
                    "synopsis": "asig **mincer** atimpt, kamp, kpitch, ktab, klock[,ifftsize,idecim]\n      ",
                    "opcodeName": "mincer",
                    "functionalSynopsis": "asig = **mincer:a**(atimpt, kamp, kpitch, ktab, klock[,ifftsize,idecim])"
                },
                {
                    "description": "Phase-locked vocoder processing with onset detection/processing, 'tempo-scaling'.",
                    "synopsis": "asig, asig2, ktime **mp3scal** Sfile, ktimescal, kpitch, kamp[, iskip, ifftsize, idecim, ilock]\n      ",
                    "opcodeName": "mp3scal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Extreme time-stretching algorithm by Nasca Octavian Paul.",
                    "synopsis": "asig **paulstretch** istretch, iwindowsize, ift\n    ",
                    "opcodeName": "paulstretch",
                    "functionalSynopsis": "asig = **paulstretch:a**(istretch, iwindowsize, ift)"
                },
                {
                    "description": "Phase-locked vocoder processing with onset detection/processing, 'tempo-scaling'.",
                    "synopsis": "asig **temposcal** ktimescal, kamp, kpitch, ktab, klock [,ifftsize, idecim, ithresh]\n      ",
                    "opcodeName": "temposcal",
                    "functionalSynopsis": "asig = **temposcal:a**(ktimescal, kamp, kpitch, ktab, klock [,ifftsize, idecim, ithresh])"
                }
            ]
        },
        {
            "category": "Strings:Definition",
            "opcodes": [
                {
                    "description": "Set string variable to value read from an URL",
                    "synopsis": "Sdst **strfromurl** StringURL",
                    "opcodeName": "strfromurl",
                    "functionalSynopsis": "Sdst = **strfromurl:unknown**(StringURL)"
                },
                {
                    "description": "Set string variable to value from strset table or string p-field",
                    "synopsis": "Sdst **strget** indx",
                    "opcodeName": "strget",
                    "functionalSynopsis": "Sdst = **strget:unknown**(indx)"
                },
                {
                    "description": "Allows a string to be linked with a numeric value.",
                    "synopsis": "**strset** iarg, istring",
                    "opcodeName": "strset",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Strings:Manipulation",
            "opcodes": [
                {
                    "description": "Print a string constant or variable",
                    "synopsis": "**puts** Sstr, ktrig[, inonl]",
                    "opcodeName": "puts",
                    "functionalSynopsis": ""
                },
                {
                    "description": "printf-style formatted output to a string variable.",
                    "synopsis": "Sdst **sprintf** Sfmt, xarg1[, xarg2[, ... ]]",
                    "opcodeName": "sprintf",
                    "functionalSynopsis": "Sdst = **sprintf:unknown**(Sfmt, xarg1[, xarg2[, ... ]])"
                },
                {
                    "description": "printf-style formatted output to a string variable at k-rate.",
                    "synopsis": "Sdst **sprintfk** Sfmt, xarg1[, xarg2[, ... ]]",
                    "opcodeName": "sprintfk",
                    "functionalSynopsis": "Sdst = **sprintfk:unknown**(Sfmt, xarg1[, xarg2[, ... ]])"
                },
                {
                    "description": "Concatenate strings",
                    "synopsis": "Sdst **strcat** Ssrc1, Ssrc2",
                    "opcodeName": "strcat",
                    "functionalSynopsis": "Sdst = **strcat:unknown**(Ssrc1, Ssrc2)"
                },
                {
                    "description": "Concatenate strings (k-rate)",
                    "synopsis": "Sdst **strcatk** Ssrc1, Ssrc2",
                    "opcodeName": "strcatk",
                    "functionalSynopsis": "Sdst = **strcatk:unknown**(Ssrc1, Ssrc2)"
                },
                {
                    "description": "Compare strings",
                    "synopsis": "ires **strcmp** S1, S2",
                    "opcodeName": "strcmp",
                    "functionalSynopsis": "ires = **strcmp:unknown**(S1, S2)"
                },
                {
                    "description": "Compare strings",
                    "synopsis": "kres **strcmpk** S1, S2",
                    "opcodeName": "strcmpk",
                    "functionalSynopsis": "kres = **strcmpk:k**(S1, S2)"
                },
                {
                    "description": "Assign value to a string variable",
                    "synopsis": "Sdst **strcpy** Ssrc\nSdst **=** Ssrc",
                    "opcodeName": "strcpy",
                    "functionalSynopsis": "Sdst = **strcpy:unknown**(Ssrc)\nSdst = **=:unknown**(Ssrc)"
                },
                {
                    "description": "Assign value to a string variable (k-rate)",
                    "synopsis": "Sdst **strcpyk** Ssrc",
                    "opcodeName": "strcpyk",
                    "functionalSynopsis": "Sdst = **strcpyk:unknown**(Ssrc)"
                },
                {
                    "description": "Return the position of the first occurence of a string in another string",
                    "synopsis": "ipos **strindex** S1, S2",
                    "opcodeName": "strindex",
                    "functionalSynopsis": "ipos = **strindex:unknown**(S1, S2)"
                },
                {
                    "description": "Return the position of the first occurence of a string in another string",
                    "synopsis": "kpos **strindexk** S1, S2",
                    "opcodeName": "strindexk",
                    "functionalSynopsis": "kpos = **strindexk:k**(S1, S2)"
                },
                {
                    "description": "Return the length of a string",
                    "synopsis": "ilen **strlen** Sstr",
                    "opcodeName": "strlen",
                    "functionalSynopsis": "ilen = **strlen:unknown**(Sstr)"
                },
                {
                    "description": "Return the length of a string",
                    "synopsis": "klen **strlenk** Sstr",
                    "opcodeName": "strlenk",
                    "functionalSynopsis": "klen = **strlenk:k**(Sstr)"
                },
                {
                    "description": "Return the position of the last occurence of a string in another string",
                    "synopsis": "ipos **strrindex** S1, S2",
                    "opcodeName": "strrindex",
                    "functionalSynopsis": "ipos = **strrindex:unknown**(S1, S2)"
                },
                {
                    "description": "Return the position of the last occurence of a string in another string",
                    "synopsis": "kpos **strrindexk** S1, S2",
                    "opcodeName": "strrindexk",
                    "functionalSynopsis": "kpos = **strrindexk:k**(S1, S2)"
                },
                {
                    "description": "Strip whitespace from string",
                    "synopsis": "Sout **strstrip** Sin [, Smode]",
                    "opcodeName": "strstrip",
                    "functionalSynopsis": "Sout = **strstrip:unknown**(Sin [, Smode])"
                },
                {
                    "description": "Extract a substring",
                    "synopsis": "Sdst **strsub** Ssrc[, istart[, iend]]",
                    "opcodeName": "strsub",
                    "functionalSynopsis": "Sdst = **strsub:unknown**(Ssrc[, istart[, iend]])"
                },
                {
                    "description": "Extract a substring",
                    "synopsis": "Sdst **strsubk** Ssrc, kstart, kend",
                    "opcodeName": "strsubk",
                    "functionalSynopsis": "Sdst = **strsubk:unknown**(Ssrc, kstart, kend)"
                }
            ]
        },
        {
            "category": "Strings:Conversion",
            "opcodes": [
                {
                    "description": "Return the ASCII code of a character in a string",
                    "synopsis": "ichr **strchar** Sstr[, ipos]",
                    "opcodeName": "strchar",
                    "functionalSynopsis": "ichr = **strchar:unknown**(Sstr[, ipos])"
                },
                {
                    "description": "Return the ASCII code of a character in a string",
                    "synopsis": "kchr **strchark** Sstr[, kpos]",
                    "opcodeName": "strchark",
                    "functionalSynopsis": "kchr = **strchark:k**(Sstr[, kpos])"
                },
                {
                    "description": "Convert a string to lower case",
                    "synopsis": "Sdst **strlower** Ssrc",
                    "opcodeName": "strlower",
                    "functionalSynopsis": "Sdst = **strlower:unknown**(Ssrc)"
                },
                {
                    "description": "Convert a string to lower case",
                    "synopsis": "Sdst **strlowerk** Ssrc",
                    "opcodeName": "strlowerk",
                    "functionalSynopsis": "Sdst = **strlowerk:unknown**(Ssrc)"
                },
                {
                    "description": "Converts a string to a float (i-rate).",
                    "synopsis": "ir **strtod** Sstr\nir **strtod** indx",
                    "opcodeName": "strtod",
                    "functionalSynopsis": "ir = **strtod:unknown**(Sstr)\nir = **strtod:unknown**(indx)"
                },
                {
                    "description": "Converts a string to a float (k-rate).",
                    "synopsis": "kr **strtodk** Sstr\nkr **strtodk** kndx",
                    "opcodeName": "strtodk",
                    "functionalSynopsis": "kr = **strtodk:k**(Sstr)\nkr = **strtodk:k**(kndx)"
                },
                {
                    "description": "Converts a string to a signed integer (i-rate).",
                    "synopsis": "ir **strtol** Sstr\nir **strtol** indx",
                    "opcodeName": "strtol",
                    "functionalSynopsis": "ir = **strtol:unknown**(Sstr)\nir = **strtol:unknown**(indx)"
                },
                {
                    "description": "Converts a string to a signed integer (k-rate).",
                    "synopsis": "kr **strtolk** Sstr\nkr **strtolk** kndx",
                    "opcodeName": "strtolk",
                    "functionalSynopsis": "kr = **strtolk:k**(Sstr)\nkr = **strtolk:k**(kndx)"
                },
                {
                    "description": "Convert a string to upper case",
                    "synopsis": "Sdst **strupper** Ssrc",
                    "opcodeName": "strupper",
                    "functionalSynopsis": "Sdst = **strupper:unknown**(Ssrc)"
                },
                {
                    "description": "Convert a string to upper case",
                    "synopsis": "Sdst **strupperk** Ssrc",
                    "opcodeName": "strupperk",
                    "functionalSynopsis": "Sdst = **strupperk:unknown**(Ssrc)"
                }
            ]
        },
        {
            "category": "Vectorial:Tables",
            "opcodes": [
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtaba**  andx, ifn, aout1 [, aout2, aout3, .... , aoutN ]",
                    "opcodeName": "vtaba",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtabi**  indx, ifn, iout1 [, iout2, iout3, .... , ioutN ]",
                    "opcodeName": "vtabi",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtabk**  kndx, ifn, kout1 [, kout2, kout3, .... , koutN ]",
                    "opcodeName": "vtabk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read a vector (several scalars simultaneously) from a table.",
                    "synopsis": "**vtable1k**  kfn,kout1 [, kout2, kout3, .... , koutN ]",
                    "opcodeName": "vtable1k",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtablea**  andx, kfn, kinterp, ixmode, aout1 [, aout2, aout3, .... , aoutN ]",
                    "opcodeName": "vtablea",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtablei**  indx, ifn, interp, ixmode, iout1 [, iout2, iout3, .... , ioutN ]",
                    "opcodeName": "vtablei",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Read vectors (from tables -or arrays of vectors).",
                    "synopsis": "**vtablek**  kndx, kfn, kinterp, ixmode, kout1 [, kout2, kout3, .... , koutN ]",
                    "opcodeName": "vtablek",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtablewa**  andx, kfn, ixmode, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ]",
                    "opcodeName": "vtablewa",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtablewi**  indx, ifn, ixmode, inarg1 [, inarg2, inarg3 , .... , inargN ]",
                    "opcodeName": "vtablewi",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtablewk**  kndx, kfn, ixmode, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ]",
                    "opcodeName": "vtablewk",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtabwa**  andx, ifn, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ]",
                    "opcodeName": "vtabwa",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtabwi**  indx, ifn, inarg1 [, inarg2, inarg3 , .... , inargN ]",
                    "opcodeName": "vtabwi",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Write vectors (to tables -or arrays of vectors).",
                    "synopsis": "**vtabwk**  kndx, ifn, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ]",
                    "opcodeName": "vtabwk",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Scalar operations",
            "opcodes": [
                {
                    "description": "Adds a scalar value to a vector in a table.",
                    "synopsis": "**vadd**  ifn, kval, kelements [, kdstoffset] [, kverbose]",
                    "opcodeName": "vadd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Adds a scalar value to a vector in a table.",
                    "synopsis": "**vadd_i**  ifn, ival, ielements [, idstoffset]",
                    "opcodeName": "vadd_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs power-of operations between a vector and a scalar",
                    "synopsis": "**vexp**  ifn, kval, kelements [, kdstoffset] [, kverbose]",
                    "opcodeName": "vexp",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs power-of operations between a vector and a scalar",
                    "synopsis": "**vexp_i**  ifn, ival, ielements[, idstoffset]",
                    "opcodeName": "vexp_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Multiplies a vector in a table by a scalar value.",
                    "synopsis": "**vmult**  ifn, kval, kelements [, kdstoffset] [, kverbose]",
                    "opcodeName": "vmult",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Multiplies a vector in a table by a scalar value.",
                    "synopsis": "**vmult_i**  ifn, ival, ielements [, idstoffset]",
                    "opcodeName": "vmult_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Raises each element of a vector to a scalar power.",
                    "synopsis": "**vpow**  ifn, kval, kelements [, kdstoffset] [, kverbose]",
                    "opcodeName": "vpow",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Raises each element of a vector to a scalar power",
                    "synopsis": "**vpow_i**  ifn, ival, ielements [, idstoffset]",
                    "opcodeName": "vpow_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Vectorial operations",
            "opcodes": [
                {
                    "description": "Performs addition between two vectorial control signals.",
                    "synopsis": "**vaddv**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vaddv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs addition between two vectorial control signals at init time.",
                    "synopsis": "**vaddv_i**  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vaddv_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Copies between two vectorial control signals",
                    "synopsis": "**vcopy**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [, kverbose]",
                    "opcodeName": "vcopy",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Copies a vector from one table to another.",
                    "synopsis": "**vcopy_i**  ifn1, ifn2, ielements [,idstoffset, isrcoffset]",
                    "opcodeName": "vcopy_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs division between two vectorial control signals",
                    "synopsis": "**vdivv**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vdivv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs division between two vectorial control signals at init time.",
                    "synopsis": "**vdivv_i**  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vdivv_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs exponential operations between two vectorial control signals",
                    "synopsis": "**vexpv**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vexpv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs exponential operations between two vectorial control signals at init time.",
                    "synopsis": "**vexpv_i**  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vexpv_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Maps elements from a vector according to indexes contained in another vector.",
                    "synopsis": "**vmap**  ifn1, ifn2, ielements [,idstoffset, isrcoffset]",
                    "opcodeName": "vmap",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs mutiplication between two vectorial control signals",
                    "synopsis": "**vmultv**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vmultv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs mutiplication between two vectorial control signals at init time.",
                    "synopsis": "**vmultv_i**  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vmultv_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs power-of operations between two vectorial control signals",
                    "synopsis": "**vpowv** ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vpowv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs power-of operations between two vectorial control signals at init time.",
                    "synopsis": "**vpowv_i** ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vpowv_i",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs subtraction between two vectorial control signals",
                    "synopsis": "**vsubv**  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]",
                    "opcodeName": "vsubv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs subtraction between two vectorial control signals at init time.",
                    "synopsis": "**vsubv_i**  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]",
                    "opcodeName": "vsubv_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Envelopes",
            "opcodes": [
                {
                    "description": "Vectorial envelope generator",
                    "synopsis": "**vexpseg**  ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]]",
                    "opcodeName": "vexpseg",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Vectorial envelope generator",
                    "synopsis": "**vlinseg**  ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]]",
                    "opcodeName": "vlinseg",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Limiting and Wrapping",
            "opcodes": [
                {
                    "description": "Limiting and Wrapping Vectorial Signals",
                    "synopsis": "**vlimit**  ifn, kmin, kmax, ielements",
                    "opcodeName": "vlimit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Limiting and Wrapping Vectorial Signals",
                    "synopsis": "**vmirror**  ifn, kmin, kmax, ielements",
                    "opcodeName": "vmirror",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Limiting and Wrapping Vectorial Signals",
                    "synopsis": "**vwrap**  ifn, kmin, kmax, ielements",
                    "opcodeName": "vwrap",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Delay Paths",
            "opcodes": [
                {
                    "description": "k-rate variable time delay.",
                    "synopsis": "kout **vdelayk**  ksig, kdel, imaxdel [, iskip, imode]",
                    "opcodeName": "vdelayk",
                    "functionalSynopsis": "kout = **vdelayk:k**( ksig, kdel, imaxdel [, iskip, imode])"
                },
                {
                    "description": "Vectorial Control-rate Delay Paths",
                    "synopsis": "**vecdelay**  ifn, ifnIn, ifnDel, ielements, imaxdel [, iskip]\n",
                    "opcodeName": "vecdelay",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Vectorial Control-rate Delay Paths",
                    "synopsis": "**vport** ifn, khtime, ielements [, ifnInit]",
                    "opcodeName": "vport",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Random",
            "opcodes": [
                {
                    "description": "Generates a vector of random numbers stored into a table, holding the values for a period of time.",
                    "synopsis": "**vrandh**  ifn,  krange, kcps, ielements [, idstoffset] [, iseed] \\\n      [, isize] [, ioffset]",
                    "opcodeName": "vrandh",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Generate a sort of 'vectorial band-limited noise'",
                    "synopsis": "**vrandi**  ifn,  krange, kcps, ielements [, idstoffset] [, iseed] \\\n      [, isize] [, ioffset]",
                    "opcodeName": "vrandi",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Vectorial:Cellular Automata",
            "opcodes": [
                {
                    "description": "Cellular Automaton",
                    "synopsis": "**cell** ktrig, kreinit, ioutFunc, initStateFunc, iRuleFunc, ielements",
                    "opcodeName": "cell",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Cellular Automata",
                    "synopsis": "**vcella** ktrig, kreinit, ioutFunc, initStateFunc, \\\n      iRuleFunc, ielements, irulelen [, iradius]",
                    "opcodeName": "vcella",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Zak Patch System",
            "opcodes": [
                {
                    "description": "Clears one or more variables in the za space.",
                    "synopsis": "**zacl** kfirst [, klast]",
                    "opcodeName": "zacl",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Establishes zak space.",
                    "synopsis": "**zakinit** isizea, isizek",
                    "opcodeName": "zakinit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Modulates one a-rate signal by a second one.",
                    "synopsis": "ares **zamod** asig, kzamod",
                    "opcodeName": "zamod",
                    "functionalSynopsis": "ares = **zamod:a**(asig, kzamod)"
                },
                {
                    "description": "Reads from a location in za space at a-rate.",
                    "synopsis": "ares **zar** kndx",
                    "opcodeName": "zar",
                    "functionalSynopsis": "ares = **zar:a**(kndx)"
                },
                {
                    "description": "Reads from a location in za space at a-rate, adds some gain.",
                    "synopsis": "ares **zarg** kndx, kgain",
                    "opcodeName": "zarg",
                    "functionalSynopsis": "ares = **zarg:a**(kndx, kgain)"
                },
                {
                    "description": "Writes to a za variable at a-rate without mixing.",
                    "synopsis": "**zaw** asig, kndx",
                    "opcodeName": "zaw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes to a za variable at a-rate with mixing.",
                    "synopsis": "**zawm** asig, kndx [, imix]",
                    "opcodeName": "zawm",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads from a location in zk space at i-rate.",
                    "synopsis": "ir **zir** indx",
                    "opcodeName": "zir",
                    "functionalSynopsis": "ir = **zir:unknown**(indx)"
                },
                {
                    "description": "Writes to a zk variable at i-rate without mixing.",
                    "synopsis": "**ziw** isig, indx",
                    "opcodeName": "ziw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes to a zk variable to an i-rate variable with mixing.",
                    "synopsis": "**ziwm** isig, indx [, imix]",
                    "opcodeName": "ziwm",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Clears one or more variables in the zk space.",
                    "synopsis": "**zkcl** kfirst, klast",
                    "opcodeName": "zkcl",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Facilitates the modulation of one signal by another.",
                    "synopsis": "kres **zkmod** ksig, kzkmod",
                    "opcodeName": "zkmod",
                    "functionalSynopsis": "kres = **zkmod:k**(ksig, kzkmod)"
                },
                {
                    "description": "Reads from a location in zk space at k-rate.",
                    "synopsis": "kres **zkr** kndx",
                    "opcodeName": "zkr",
                    "functionalSynopsis": "kres = **zkr:k**(kndx)"
                },
                {
                    "description": "Writes to a zk variable at k-rate without mixing.",
                    "synopsis": "**zkw** kval, kndx",
                    "opcodeName": "zkw",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Writes to a zk variable at k-rate with mixing.",
                    "synopsis": "**zkwm** ksig, kndx [, imix]",
                    "opcodeName": "zkwm",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Plugin Hosting:DSSI and LADSPA",
            "opcodes": [
                {
                    "description": "Activates or deactivates a DSSI or LADSPA plugin.",
                    "synopsis": "**dssiactivate** ihandle, ktoggle ",
                    "opcodeName": "dssiactivate",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Processes audio using a LADSPA or DSSI plugin.",
                    "synopsis": "[aout1, aout2, ..., aout9] **dssiaudio** ihandle, [ain1, ain2, ..., ain9]",
                    "opcodeName": "dssiaudio",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Send control information to a LADSPA or DSSI plugin.",
                    "synopsis": "**dssictls** ihandle, iport, kvalue, ktrigger ",
                    "opcodeName": "dssictls",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Loads a DSSI or LADSPA plugin.",
                    "synopsis": "ihandle **dssiinit** ilibraryname, iplugindex [, iverbose] ",
                    "opcodeName": "dssiinit",
                    "functionalSynopsis": "ihandle = **dssiinit:unknown**(ilibraryname, iplugindex [, iverbose] )"
                },
                {
                    "description": "Lists all available DSSI and LADSPA plugins.",
                    "synopsis": "**dssilist**",
                    "opcodeName": "dssilist",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "OSC",
            "opcodes": [
                {
                    "description": "Sends data to other processes using the OSC protocol by packing\n      messages in a bundle.",
                    "synopsis": "**OSCbundle** kwhen, ihost, iport,\n    Sdest[], Stype[],kArgs[][][,isize]",
                    "opcodeName": "OSCbundle",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gives the Count of OSC messages currently unread.",
                    "synopsis": "kans **OSCcount**",
                    "opcodeName": "OSCcount",
                    "functionalSynopsis": "kans = **OSCcount:k**()"
                },
                {
                    "description": "Start a listening process for OSC messages to a particular port.",
                    "synopsis": "ihandle **OSCinit** iport",
                    "opcodeName": "OSCinit",
                    "functionalSynopsis": "ihandle = **OSCinit:unknown**(iport)"
                },
                {
                    "description": "Start a listening process for multicast OSC messages to a particular port.",
                    "synopsis": "ihandle **OSCinitM** Sgroup, iport",
                    "opcodeName": "OSCinitM",
                    "functionalSynopsis": "ihandle = **OSCinitM:unknown**(Sgroup, iport)"
                },
                {
                    "description": "Listen for OSC messages to a particular path.",
                    "synopsis": "kans **OSClisten** ihandle, idest, itype [, xdata1, xdata2, ...]\nkans, kdata[] **OSClisten** ihandle, idest, itype",
                    "opcodeName": "OSClisten",
                    "functionalSynopsis": "kans = **OSClisten:k**(ihandle, idest, itype [, xdata1, xdata2, ...])"
                },
                {
                    "description": "Listen for all OSC messages at a given port.",
                    "synopsis": "Smess[],klen **OSCraw** iport",
                    "opcodeName": "OSCraw",
                    "functionalSynopsis": "Smess[],klen = **OSCraw:unknown**(iport)"
                },
                {
                    "description": "Sends data to other processes using the OSC protocol",
                    "synopsis": "**OSCsend** kwhen, ihost, iport, idestination[, itype , xdata1, xdata2, ...]",
                    "opcodeName": "OSCsend",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Faust Opcodes",
            "opcodes": [
                {
                    "description": "Instantiates and runs a compiled Faust program.",
                    "synopsis": "**ihandle,a1[,a2,...] faustaudio** ifac[,ain1,...] ",
                    "opcodeName": "ihandle,a1[,a2,...] faustaudio",
                    "functionalSynopsis": "**ihandle,a1[,a2,...] = **faustaudio:unknown**(ifac[,ain1,...] )"
                },
                {
                    "description": "Invokes the just-in-time compiler to produce a instantiable DSP process from a Faust program.",
                    "synopsis": "**ihandle faustcompile** Scode, Sargs[,iasync, istacksize]  ",
                    "opcodeName": "ihandle faustcompile",
                    "functionalSynopsis": "**ihandle = **faustcompile:unknown**(Scode, Sargs[,iasync, istacksize]  )"
                },
                {
                    "description": "Adjusts a given control in a Faust DSP instance.",
                    "synopsis": "**faustctl** idsp,Scontrol,kval ",
                    "opcodeName": "faustctl",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Instantiates a Faust program.",
                    "synopsis": "**ihandle faustdsp** ifac ",
                    "opcodeName": "ihandle faustdsp",
                    "functionalSynopsis": "**ihandle = **faustdsp:unknown**(ifac )"
                },
                {
                    "description": "Compiles, Instantiates and runs a compiled Faust program.",
                    "synopsis": "**ihandle,a1[,a2,...] faustgen** SCode[,ain1,...] ",
                    "opcodeName": "ihandle,a1[,a2,...] faustgen",
                    "functionalSynopsis": "**ihandle,a1[,a2,...] = **faustgen:unknown**(SCode[,ain1,...] )"
                },
                {
                    "description": "Runs an instantiated Faust program.",
                    "synopsis": "**a1[, a2,...] faustplay** ihandle[, ain1,...]",
                    "opcodeName": "a1[, a2,...] faustplay",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Network",
            "opcodes": [
                {
                    "description": "Defines the port for use with the remote system.",
                    "synopsis": "**remoteport** iportnum",
                    "opcodeName": "remoteport",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Receives data from other processes using the low-level UDP or TCP protocols",
                    "synopsis": "asig **sockrecv** iport, ilength\nksig **sockrecv** iport, ilength\nasigl, asigr **sockrecvs** iport, ilength\nString **sockrecv** iport, ilength\nasig[,kstate] **strecv** Sipaddr, iport",
                    "opcodeName": "sockrecv",
                    "functionalSynopsis": "asig = **sockrecv:a**(iport, ilength)\nksig = **sockrecv:k**(iport, ilength)\nString = **sockrecv:unknown**(iport, ilength)\nasig[,kstate] = **strecv:a**(Sipaddr, iport)"
                },
                {
                    "description": "Sends data to other processes using the low-level UDP or TCP protocols",
                    "synopsis": "**socksend** asig, Sipaddr, iport, ilength\n**socksend** ksig, Sipaddr, iport, ilength\n**socksends** asigl, asigr, Sipaddr, iport,\n    ilength\n**stsend** asig, Sipaddr, iport",
                    "opcodeName": "socksend",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Remote Opcodes",
            "opcodes": [
                {
                    "description": "An opcode which can be used to implement a remote\n      orchestra. This opcode will send note events from a source\n      machine to many destinations.",
                    "synopsis": "**insglobal** isource, instrnum [,instrnum...] ",
                    "opcodeName": "insglobal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "An opcode which can be used to implement a remote\n      orchestra. This opcode will send note events from a source\n      machine to one destination.",
                    "synopsis": "**insremot** idestination, isource, instrnum [,instrnum...] ",
                    "opcodeName": "insremot",
                    "functionalSynopsis": ""
                },
                {
                    "description": "An opcode which can be used to implement a remote midi orchestra. This opcode will broadcast the midi events to all the machines involved in the remote concert.",
                    "synopsis": "**midglobal** isource, instrnum [,instrnum...] ",
                    "opcodeName": "midglobal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "An opcode which can be used to implement a remote midi orchestra. This opcode will send midi events from a source machine to one destination.",
                    "synopsis": "**midremot** idestination, isource, instrnum [,instrnum...] ",
                    "opcodeName": "midremot",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Mixer Opcodes",
            "opcodes": [
                {
                    "description": "Resets all channels of a buss to 0.",
                    "synopsis": "**MixerClear**",
                    "opcodeName": "MixerClear",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets the level of a send to a buss.",
                    "synopsis": "kgain **MixerGetLevel** isend, ibuss",
                    "opcodeName": "MixerGetLevel",
                    "functionalSynopsis": "kgain = **MixerGetLevel:k**(isend, ibuss)"
                },
                {
                    "description": "Receives an arate signal from a channel of a buss.",
                    "synopsis": "asignal **MixerReceive** ibuss, ichannel",
                    "opcodeName": "MixerReceive",
                    "functionalSynopsis": "asignal = **MixerReceive:a**(ibuss, ichannel)"
                },
                {
                    "description": "Mixes an arate signal into a channel of a buss.",
                    "synopsis": "**MixerSend** asignal, isend, ibuss, ichannel",
                    "opcodeName": "MixerSend",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the level of a send to a buss.",
                    "synopsis": "**MixerSetLevel** isend, ibuss, kgain",
                    "opcodeName": "MixerSetLevel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets the level of a send to a buss.",
                    "synopsis": "**MixerSetLevel_i** isend, ibuss, igain",
                    "opcodeName": "MixerSetLevel_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Ableton Link Opcodes",
            "opcodes": [
                {
                    "description": "Forces the global network Ableton Link session to adopt a specific beat number and time.",
                    "synopsis": "**link_beat_force**  i_peer, k_beat [, k_at_time_seconds  [, k_quantum ]] ",
                    "opcodeName": "link_beat_force",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the beat, phase with respect to the local quantum, and current time for the session.",
                    "synopsis": "k_beat_number, k_phase, k_current_time_seconds **link_beat_get** i_peer [, k_quantum]",
                    "opcodeName": "link_beat_get",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Requests the global network Ableton Link session to adopt a specific beat number and time.",
                    "synopsis": "**link_beat_request**  i_peer, k_beat [, k_at_time_seconds  [, k_quantum ]] ",
                    "opcodeName": "link_beat_request",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a peer in an Ableton Link network session.",
                    "synopsis": "i_peer **link_create** [i_bpm]",
                    "opcodeName": "link_create",
                    "functionalSynopsis": "i_peer = **link_create:unknown**([i_bpm])"
                },
                {
                    "description": "Enable or disable synchronization with the Ableton Link session.",
                    "synopsis": " **ableton_link_enable** i_peer [, k_enable]",
                    "opcodeName": "ableton_link_enable",
                    "functionalSynopsis": " = **ableton_link_enable:unknown**(i_peer [, k_enable])"
                },
                {
                    "description": "Returns whether or not this peer is synchronized with the global network Ableton Link session.",
                    "synopsis": "k_is_enabled **link_is_enabled** i_peer",
                    "opcodeName": "link_is_enabled",
                    "functionalSynopsis": "k_is_enabled = **link_is_enabled:k**(i_peer)"
                },
                {
                    "description": "Returns a trigger that is 1 on the beat and 0 otherwise along with beat, phase, and time for this session of Ableton Link.",
                    "synopsis": "k_trigger, k_beat, k_phase, k_current_time_seconds **link_metro** i_peer [, k_quantum]",
                    "opcodeName": "link_metro",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the number of peers in the session.",
                    "synopsis": "k_count **link_peers** i_peer",
                    "opcodeName": "link_peers",
                    "functionalSynopsis": "k_count = **link_peers:k**(i_peer)"
                },
                {
                    "description": "Returns the current tempo of the global network Ableton Link session.",
                    "synopsis": "k_bpm **link_tempo_get** i_peer",
                    "opcodeName": "link_tempo_get",
                    "functionalSynopsis": "k_bpm = **link_tempo_get:k**(i_peer)"
                },
                {
                    "description": "Sets the tempo.",
                    "synopsis": "**link_tempo_set** i_peer, k_bpm [, k_at_time_seconds]",
                    "opcodeName": "link_tempo_set",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Python Opcodes",
            "opcodes": [
                {
                    "description": "Assign the value of the given Csound variable to a Python variable possibly destroying its previous content.",
                    "synopsis": "**pyassign** &quot;variable&quot;, kvalue\n**pyassigni** &quot;variable&quot;, ivalue\n**pylassign** &quot;variable&quot;, kvalue\n**pylassigni** &quot;variable&quot;, ivalue\n**pyassignt** ktrigger, &quot;variable&quot;, kvalue\n**pylassignt** ktrigger, &quot;variable&quot;, kvalue",
                    "opcodeName": "pyassign",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Invoke the specified Python callable at\n      k-time and i-time (i suffix), passing the given arguments. The call is\n      perfomed in the global environment, and the result (the returning\n      value) is copied into the Csound output variables specified.",
                    "synopsis": "                                        **pycall**   &quot;callable&quot;, karg1, ...\nkresult                                 **pycall1**  &quot;callable&quot;, karg1, ...\nkresult1, kresult2                      **pycall2**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3                           **pycall3**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4                      **pycall4**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5                 **pycall5**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6            **pycall6**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7       **pycall7**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  **pycall8**  &quot;callable&quot;, karg1, ...\n                                        **pycallt**   ktrigger, &quot;callable&quot;, karg1, ...\nkresult                                 **pycall1t**  ktrigger, &quot;callable&quot;, karg1, ...\nkresult1, kresult2                      **pycall2t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3                           **pycall3t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4                      **pycall4t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5                 **pycall5t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6            **pycall6t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7       **pycall7t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  **pycall8t**  ktrigger, &quot;callable&quot;, karg1, ...\n                                        **pycalli**   &quot;callable&quot;, karg1, ...\niresult                                 **pycall1i**  &quot;callable&quot;, iarg1, ...\niresult1, iresult2                      **pycall2i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3                           **pycall3i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4                      **pycall4i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5                 **pycall5i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6            **pycall6i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6, ir7       **pycall7i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8  **pycall8i**  &quot;callable&quot;, iarg1, ...\n**pycalln**   &quot;callable&quot;, nresults, kresult1, ..., kresultn, karg1, ...\n**pycallni**  &quot;callable&quot;, nresults, iresult1, ..., iresultn, iarg1,  ...\n                                        **pylcall**   &quot;callable&quot;, karg1, ...\nkresult                                 **pylcall1**  &quot;callable&quot;, karg1, ...\nkresult1, kresult2                      **pylcall2**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3                           **pylcall3**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4                      **pylcall4**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5                 **pylcall5**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6            **pylcall6**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7       **pylcall7**  &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  **pylcall8**   &quot;callable&quot;, karg1, ...\n                                        **pylcallt**   ktrigger, &quot;callable&quot;, karg1, ...\nkresult                                 **pylcall1t**  ktrigger, &quot;callable&quot;, karg1, ...\nkresult1, kresult2                      **pylcall2t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3                           **pylcall3t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4                      **pylcall4t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5                 **pylcall5t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6            **pylcall6t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7       **pylcall7t**  ktrigger, &quot;callable&quot;, karg1, ...\nkr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  **pylcall8t**  ktrigger, &quot;callable&quot;, karg1, ...\n                                        **pylcalli**   &quot;callable&quot;, karg1, ...\niresult                                 **pylcall1i**  &quot;callable&quot;, iarg1, ...\niresult1, iresult2                      **pylcall2i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3                           **pylcall3i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4                      **pylcall4i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5                 **pylcall5i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6            **pylcall6i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6, ir7       **pylcall7i**  &quot;callable&quot;, iarg1, ...\nir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8  **pylcall8i**  &quot;callable&quot;, iarg1, ...\n**pylcalln**   &quot;callable&quot;, nresults, kresult1, ..., kresultn, karg1, ...\n**pylcallni**  &quot;callable&quot;, nresults, iresult1, ..., iresultn, iarg1, ...",
                    "opcodeName": "pycall",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Evaluate a generic Python expression and store the result in a Csound variable at k-time or i-time (i suffix).",
                    "synopsis": "kresult **pyeval** &quot;expression&quot;\niresult **pyevali** &quot;expression&quot;\nkresult **pyleval** &quot;expression&quot;\niresult **pylevali** &quot;expression&quot;\nkresult **pyevalt** ktrigger, &quot;expression&quot;\nkresult **pylevalt** ktrigger, &quot;expression&quot;",
                    "opcodeName": "pyeval",
                    "functionalSynopsis": "kresult = **pyeval:k**(&quot;expression&quot;)\niresult = **pyevali:unknown**(&quot;expression&quot;)\nkresult = **pyleval:k**(&quot;expression&quot;)\niresult = **pylevali:unknown**(&quot;expression&quot;)\nkresult = **pyevalt:k**(ktrigger, &quot;expression&quot;)\nkresult = **pylevalt:k**(ktrigger, &quot;expression&quot;)"
                },
                {
                    "description": "Execute a script from a file at k-time or i-time (i suffix).",
                    "synopsis": "**pyexec** &quot;filename&quot;\n**pyexeci** &quot;filename&quot;\n**pylexec** &quot;filename&quot;\n**pylexeci** &quot;filename&quot;\n**pyexect** ktrigger, &quot;filename&quot;\n**plyexect** ktrigger, &quot;filename&quot;",
                    "opcodeName": "pyexec",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Initialize the Python interpreter.",
                    "synopsis": "**pyinit**",
                    "opcodeName": "pyinit",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Run a Python statement or block of statements.",
                    "synopsis": "**pyrun** &quot;statement&quot;\n**pyruni** &quot;statement&quot;\n**pylrun** &quot;statement&quot;\n**pylruni** &quot;statement&quot;\n**pyrunt** ktrigger, &quot;statement&quot;\n**pylrunt** ktrigger, &quot;statement&quot;",
                    "opcodeName": "pyrun",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Image Processing Opcodes",
            "opcodes": [
                {
                    "description": "Create an empty image of a given size.",
                    "synopsis": "iimagenum **imagecreate** iwidth, iheight",
                    "opcodeName": "imagecreate",
                    "functionalSynopsis": "iimagenum = **imagecreate:unknown**(iwidth, iheight)"
                },
                {
                    "description": "Frees memory allocated for a previously loaded or created image.",
                    "synopsis": "**imagefree** iimagenum",
                    "opcodeName": "imagefree",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Return the RGB pixel values of a previously opened or created image.",
                    "synopsis": "ared, agreen, ablue **imagegetpixel** iimagenum, ax, ay\nkred, kgreen, kblue **imagegetpixel** iimagenum, kx, ky",
                    "opcodeName": "imagegetpixel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Load an image.",
                    "synopsis": "iimagenum **imageload** filename",
                    "opcodeName": "imageload",
                    "functionalSynopsis": "iimagenum = **imageload:unknown**(filename)"
                },
                {
                    "description": "Save a previously created image.",
                    "synopsis": "**imagesave** iimagenum, filename",
                    "opcodeName": "imagesave",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Set the RGB value of a pixel inside a previously opened or created image.",
                    "synopsis": "**imagesetpixel** iimagenum, ax, ay, ared, agreen, ablue\n**imagesetpixel** iimagenum, kx, ky, kred, kgreen, kblue",
                    "opcodeName": "imagesetpixel",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Return the width and height of a previously opened or created image.",
                    "synopsis": "iwidth, iheight **imagesize** iimagenum",
                    "opcodeName": "imagesize",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Array Opcodes",
            "opcodes": [
                {
                    "description": "Copy data from a vector to an f-table.",
                    "synopsis": "**copya2ftab** kArray[], ktab [, koffset]\n**copya2ftab** iArray[], itab [, ioffset]",
                    "opcodeName": "copya2ftab",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Copy data from an f-table to a vector.",
                    "synopsis": "**copyf2array** tab, kftbl",
                    "opcodeName": "copyf2array",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deinterleaves arrays by picking alternate data from its input.",
                    "synopsis": "kout1[], kout2[] **deinterleave** kin[]",
                    "opcodeName": "deinterleave",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Gets a given column from a 2-dimensional array as a vector.",
                    "synopsis": "i/kout[] **getcol**i/kin[],i/kcol",
                    "opcodeName": "getcol",
                    "functionalSynopsis": "i/kout[] = **getcoli/kin[],i/kcol:unknown**()"
                },
                {
                    "description": "Gets a given row from a 2-dimensional array as a vector.",
                    "synopsis": "i/kout[] **getrow**i/kin[],i/krow",
                    "opcodeName": "getrow",
                    "functionalSynopsis": "i/kout[] = **getrowi/kin[],i/krow:unknown**()"
                },
                {
                    "description": "Interleaves arrays into a a single one by placing the input data\n    in alternate positions.",
                    "synopsis": "kout[] **interleave** kin1[], kin2[]",
                    "opcodeName": "interleave",
                    "functionalSynopsis": "kout[] = **interleave:k**(kin1[], kin2[])"
                },
                {
                    "description": "returns the maximum value in an array.",
                    "synopsis": "kmax [,kindx] **maxarray** karray",
                    "opcodeName": "maxarray",
                    "functionalSynopsis": ""
                },
                {
                    "description": "returns the minimum value in an array.",
                    "synopsis": "kmin [,kindx] **minarray** karray",
                    "opcodeName": "minarray",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Print the contents of an array",
                    "synopsis": "**printarray** ixs[] [, Smft, Slabel ]\n**printarray** kxs[] [, ktrig, Sfmt, Slabel ]",
                    "opcodeName": "printarray",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Calculates the product of an array.",
                    "synopsis": "kres/ires **product** karr[]/iarr[]  (k- or i-arrays )",
                    "opcodeName": "product",
                    "functionalSynopsis": "kres/ires = **product:k**(karr[]/iarr[]  (k- or i-arrays ))"
                },
                {
                    "description": "Reshape an array, maintaining its capacity",
                    "synopsis": "**reshapearray** array[], isize0 [, isize1 ]",
                    "opcodeName": "reshapearray",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Scales the values in a range of a vector (one dimensional array).",
                    "synopsis": "**scalearray** tarray, kmin, kmax[, kleft, kright]",
                    "opcodeName": "scalearray",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sets a given column of a 2-dimensional array from a vector.",
                    "synopsis": "i/kout[] **setcol** i/kin[],i/kcol",
                    "opcodeName": "setcol",
                    "functionalSynopsis": "i/kout[] = **setcol:unknown**(i/kin[],i/kcol)"
                },
                {
                    "description": "Sets a given row of a 2-dimensional array from a vector.",
                    "synopsis": "i/kout[] **setrow** i/kin[],i/krow",
                    "opcodeName": "setrow",
                    "functionalSynopsis": "i/kout[] = **setrow:unknown**(i/kin[],i/krow)"
                },
                {
                    "description": "Shifts the contents of an audio variable into a 1-dimensional array.",
                    "synopsis": "kout[] **shiftin** asig",
                    "opcodeName": "shiftin",
                    "functionalSynopsis": "kout[] = **shiftin:k**(asig)"
                },
                {
                    "description": "Shifts the contents of a 1-dimensional array into an audio variable.",
                    "synopsis": "asig **shiftout** kIn[][, ioff]",
                    "opcodeName": "shiftout",
                    "functionalSynopsis": "asig = **shiftout:a**(kIn[][, ioff])"
                },
                {
                    "description": "returns the sum of the elements in an array.",
                    "synopsis": "ksum **sumarray** karray",
                    "opcodeName": "sumarray",
                    "functionalSynopsis": "ksum = **sumarray:k**(karray)"
                },
                {
                    "description": "Copy a slice from an f-table to an array",
                    "synopsis": "kout[] **tab2array** ifn [, kstart, kend, kstep ]\niout[] **tab2array** ifn [, istart, iend, istep ]",
                    "opcodeName": "tab2array",
                    "functionalSynopsis": "kout[] = **tab2array:k**(ifn [, kstart, kend, kstep ])\niout[] = **tab2array:unknown**(ifn [, istart, iend, istep ])"
                },
                {
                    "description": "Adjust size of a one-dimensional array.",
                    "synopsis": "**trim_i** iarray, ilen\n**trim** xarray, klen",
                    "opcodeName": "trim_i",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Array Operations: Fast Fourier Transform",
            "opcodes": [
                {
                    "description": "Complex-to-complex Fast Fourier Transform.",
                    "synopsis": "kout[] **fft** kin[]",
                    "opcodeName": "fft",
                    "functionalSynopsis": "kout[] = **fft:k**(kin[])"
                },
                {
                    "description": "Complex-to-complex Inverse Fast Fourier Transform.",
                    "synopsis": "kout[] **fftinv** kin[]",
                    "opcodeName": "fftinv",
                    "functionalSynopsis": "kout[] = **fftinv:k**(kin[])"
                },
                {
                    "description": "Fast Fourier Transform of a real-value array.",
                    "synopsis": "kout[] **rfft** kin[]",
                    "opcodeName": "rfft",
                    "functionalSynopsis": "kout[] = **rfft:k**(kin[])"
                },
                {
                    "description": "Complex-to-real Inverse Fast Fourier Transform.",
                    "synopsis": "kout[] **rifft** kin[]",
                    "opcodeName": "rifft",
                    "functionalSynopsis": "kout[] = **rifft:k**(kin[])"
                },
                {
                    "description": "Applies a unwrapping operation to an array of phase values.",
                    "synopsis": "kout[] **unwrap** kin[] ",
                    "opcodeName": "unwrap",
                    "functionalSynopsis": "kout[] = **unwrap:k**(kin[] )"
                },
                {
                    "description": "Applies a window to an array.",
                    "synopsis": "kout[] **window** kin[][, koff, itype]",
                    "opcodeName": "window",
                    "functionalSynopsis": "kout[] = **window:k**(kin[][, koff, itype])"
                }
            ]
        },
        {
            "category": "Array Operations: complex numbers",
            "opcodes": [
                {
                    "description": "Real to complex format conversion.",
                    "synopsis": "kout[] **c2r** kin[]",
                    "opcodeName": "c2r",
                    "functionalSynopsis": "kout[] = **c2r:k**(kin[])"
                },
                {
                    "description": "Complex product of two arrays.",
                    "synopsis": "kout[] **cmplxprod** kin1[], kin2[]",
                    "opcodeName": "cmplxprod",
                    "functionalSynopsis": "kout[] = **cmplxprod:k**(kin1[], kin2[])"
                },
                {
                    "description": "Obtains the magnitudes of a complex-number array",
                    "synopsis": "kout[] **mags** kin[]",
                    "opcodeName": "mags",
                    "functionalSynopsis": "kout[] = **mags:k**(kin[])"
                },
                {
                    "description": "Obtains the phases of a complex-number array",
                    "synopsis": "kout[] **phs** kin[]",
                    "opcodeName": "phs",
                    "functionalSynopsis": "kout[] = **phs:k**(kin[])"
                },
                {
                    "description": "Polar to rectangular format conversion.",
                    "synopsis": "kout[] **pol2rect** kin[]\nkout[] **pol2rect** kmags[], kphs[]",
                    "opcodeName": "pol2rect",
                    "functionalSynopsis": "kout[] = **pol2rect:k**(kin[])\nkout[] = **pol2rect:k**(kmags[], kphs[])"
                },
                {
                    "description": "Real to complex format conversion.",
                    "synopsis": "kout[] **r2c** kin[]",
                    "opcodeName": "r2c",
                    "functionalSynopsis": "kout[] = **r2c:k**(kin[])"
                },
                {
                    "description": "Rectangular to polar format conversion.",
                    "synopsis": "kout[] **rect2pol** kin[]",
                    "opcodeName": "rect2pol",
                    "functionalSynopsis": "kout[] = **rect2pol:k**(kin[])"
                }
            ]
        },
        {
            "category": "Array Operations: Discrete Cosine Transform",
            "opcodes": [
                {
                    "description": "Discrete Cosine Transform of a sample array (type-II DCT)",
                    "synopsis": "kout[] **dct** kin[]\niout[] **dct** iin[]",
                    "opcodeName": "dct",
                    "functionalSynopsis": "kout[] = **dct:k**(kin[])\niout[] = **dct:unknown**(iin[])"
                },
                {
                    "description": "Inverse Discrete Cosine Transform of a sample array (type-III DCT)",
                    "synopsis": "kout[] **dctinv** kin[]\niout[] **dctinv** iin[]",
                    "opcodeName": "dctinv",
                    "functionalSynopsis": "kout[] = **dctinv:k**(kin[])\niout[] = **dctinv:unknown**(iin[])"
                }
            ]
        },
        {
            "category": "Array Operations: dot product",
            "opcodes": [
                {
                    "description": "Calculates the dot product of two arrays.",
                    "synopsis": "kres/ires **dot** karr1[]/iarr1[], karr2[]/iarr2[]   (k- or i-arrays )",
                    "opcodeName": "dot",
                    "functionalSynopsis": "kres/ires = **dot:k**(karr1[]/iarr1[], karr2[]/iarr2[]   (k- or i-arrays ))"
                }
            ]
        },
        {
            "category": "Array Operations: Mel scale filterbank",
            "opcodes": [
                {
                    "description": "Mel scale filterbank for spectral magnitudes.",
                    "synopsis": "kout[] **mfb** kin[],klow,khigh,ibands",
                    "opcodeName": "mfb",
                    "functionalSynopsis": "kout[] = **mfb:k**(kin[],klow,khigh,ibands)"
                }
            ]
        },
        {
            "category": "Array Operations: sorting",
            "opcodes": [
                {
                    "description": "Sorts an array in ascending order.",
                    "synopsis": "k/i[]**sorta** k/i[]  (k- or i-arrays )",
                    "opcodeName": "sorta",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Sorts an array in descending order.",
                    "synopsis": "k/i[]**sortd** k/i[]  (k- or i-arrays )",
                    "opcodeName": "sortd",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Array Operations: Cepstrum",
            "opcodes": [
                {
                    "description": "Calculate the cepstrum of an array input, optionally filtering coefficients.",
                    "synopsis": "keps[] **ceps** kmags[][, icoefs]",
                    "opcodeName": "ceps",
                    "functionalSynopsis": "keps[] = **ceps:k**(kmags[][, icoefs])"
                },
                {
                    "description": "Calculate the inverse cepstrum of an array.",
                    "synopsis": "kenv **cepsinv** keps[]",
                    "opcodeName": "cepsinv",
                    "functionalSynopsis": "kenv = **cepsinv:k**(keps[])"
                }
            ]
        },
        {
            "category": "Deprecated",
            "opcodes": [
                {
                    "description": "Enables or disables all Jack ports.",
                    "synopsis": "**JackoOn **[iactive] ",
                    "opcodeName": "JackoOn ",
                    "functionalSynopsis": "**JackoOn = **[iactive]:unknown**()"
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "**tableiw** isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]",
                    "opcodeName": "tableiw",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Miscellaneous",
            "opcodes": [
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reads a directory and outputs to a string array a list of file names.",
                    "synopsis": "SFiles[] **directory** SDirectory[, SExtention]",
                    "opcodeName": "directory",
                    "functionalSynopsis": "SFiles[] = **directory:unknown**(SDirectory[, SExtention])"
                },
                {
                    "description": "returns the length of a Farey Sequence.",
                    "synopsis": "kfl **fareylen** kfn",
                    "opcodeName": "fareylen",
                    "functionalSynopsis": "kfl = **fareylen:k**(kfn)"
                },
                {
                    "description": "returns the length of a Farey Sequence.",
                    "synopsis": "ifl **fareyleni** ifn",
                    "opcodeName": "fareyleni",
                    "functionalSynopsis": "ifl = **fareyleni:unknown**(ifn)"
                },
                {
                    "description": "Read audio signals into 1 dimensional k-rate arrays and vice-versa with a specified buffer size.",
                    "synopsis": "kout[] **framebuffer** ain, isize\naout **framebuffer** kin, isize",
                    "opcodeName": "framebuffer",
                    "functionalSynopsis": "kout[] = **framebuffer:k**(ain, isize)\naout = **framebuffer:a**(kin, isize)"
                },
                {
                    "description": "Modulation matrix opcode with optimizations for sparse matrices.",
                    "synopsis": "**modmatrix** iresfn, isrcmodfn, isrcparmfn, imodscale, inum_mod, \\\\\ninum_parm, kupdate",
                    "opcodeName": "modmatrix",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Returns the number of audio channels in the underlying hardware.",
                    "synopsis": "idacc,iadcc **nchnls_hw**",
                    "opcodeName": "nchnls_hw",
                    "functionalSynopsis": "idacc,iadcc = **nchnls_hw:unknown**()"
                },
                {
                    "description": "Sum overlapping frames of audio as k-rate arrays and read as an audio signal",
                    "synopsis": "aout **olabuffer** kin, ioverlap",
                    "opcodeName": "olabuffer",
                    "functionalSynopsis": "aout = **olabuffer:a**(kin, ioverlap)"
                },
                {
                    "description": "Asks the underlying operating system for the current directory\n      name as a string.",
                    "synopsis": "Sres **pwd**",
                    "opcodeName": "pwd",
                    "functionalSynopsis": "Sres = **pwd:unknown**()"
                },
                {
                    "description": "Select sample value based on audio-rate comparisons.",
                    "synopsis": "aout **select** a1, a2, aless, aequal, amore",
                    "opcodeName": "select",
                    "functionalSynopsis": "aout = **select:a**(a1, a2, aless, aequal, amore)"
                },
                {
                    "description": "Call an external program via the system call",
                    "synopsis": "ires **system_i** itrig, Scmd, [inowait]\nkres **system** ktrig, Scmd, [knowait]",
                    "opcodeName": "system_i",
                    "functionalSynopsis": "ires = **system_i:unknown**(itrig, Scmd, [inowait])\nkres = **system:k**(ktrig, Scmd, [knowait])"
                },
                {
                    "description": "shuffles the content of a function table so that each element of the source\n      table is put into a different random position.",
                    "synopsis": "**tableshuffle** ktablenum\n**tableshufflei** itablenum",
                    "opcodeName": "tableshuffle",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                },
                {
                    "description": "",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                }
            ]
        },
        {
            "category": "Utilities",
            "opcodes": [
                {
                    "description": "Momentary, Integrated and Short-Term Loudness meter in LUFS",
                    "synopsis": "kmom, kint, kshort **lufs** kreset, ain1 [, ain2]",
                    "opcodeName": "lufs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs ATS analysis on a soundfile.",
                    "synopsis": "**csound -U atsa** [flags] infilename outfilename",
                    "opcodeName": "csound -U atsa",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Starts Csound with a set of options that can be controlled\n      by environment variables, and input and output files\n      determined by the specified filename stem.",
                    "synopsis": "**cs** [-OPTIONS] &lt;name&gt; [CSOUND OPTIONS ... ]",
                    "opcodeName": "cs",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a binary file to a Base64 encoded text file.",
                    "synopsis": "**csb64enc** [OPTIONS ... ] infile1 [ infile2 [ ... ]]",
                    "opcodeName": "csb64enc",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a soundfile into a single Fourier transform frame.",
                    "synopsis": "**csound -U cvanal** [flags] infilename outfilename\n**cvanal** [flags] infilename outfilename",
                    "opcodeName": "csound -U cvanal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Reduces noise in a file.",
                    "synopsis": "**dnoise** [flags] -i noise_ref_file  -o output_soundfile  soundfile_format  input_soundfile",
                    "opcodeName": "dnoise",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Extracts the envelope of a file to a text file.",
                    "synopsis": "**envext** [-flags] soundfile\ncsound -U **envext** [-flags] soundfile",
                    "opcodeName": "envext",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Extract a section of audio from an audio file.",
                    "synopsis": "**extractor** [OPTIONS ... ] infile",
                    "opcodeName": "extractor",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a .het file to a comma separated text file.",
                    "synopsis": "**het_export** het_file cstext_file\ncsound -U **het_export** het_file cstext_file",
                    "opcodeName": "het_export",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a comma-separated text file to a .het file.",
                    "synopsis": "**het_import** cstext_file het_file\ncsound -U **het_import** cstext_file het_file",
                    "opcodeName": "het_import",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Decomposes an input soundfile into component sinusoids.",
                    "synopsis": "**csound -U hetro** [flags] infilename outfilename\n**hetro** [flags] infilename outfilename",
                    "opcodeName": "csound -U hetro",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Performs both linear predictive and pitch-tracking analysis on a soundfile.",
                    "synopsis": "**csound -U lpanal** [flags] infilename outfilename\n**lpanal** [flags] infilename outfilename",
                    "opcodeName": "csound -U lpanal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Creates a CSD file from the specified input files.",
                    "synopsis": "**makecsd** [OPTIONS ... ] infile1 [ infile2 [ ... ]]",
                    "opcodeName": "makecsd",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Mixes together a number of soundfiles.",
                    "synopsis": "**mixer** [OPTIONS ... ] infile [[OPTIONS... ] infile] ...",
                    "opcodeName": "mixer",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Outputs a catalog of opcodes and plugin modules.",
                    "synopsis": "**mkdb** [-m] [base_directory]",
                    "opcodeName": "mkdb",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a .pvx file to a comma separated text file.",
                    "synopsis": "**pv_export** pv_file cstext_file\ncsound -U **pv_export** pv_file cstext_file",
                    "opcodeName": "pv_export",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a comma-separated text file to a .pvx file.",
                    "synopsis": "**pv_import** cstext_file pv_file\ncsound -U **pv_import** cstext_file pv_file",
                    "opcodeName": "pv_import",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts a soundfile into a series of short-time Fourier transform frames.",
                    "synopsis": "**csound -U pvanal** [flags] infilename outfilename\n**pvanal** [flags] infilename outfilename",
                    "opcodeName": "csound -U pvanal",
                    "functionalSynopsis": ""
                },
                {
                    "description": "View formatted text output of STFT analysis files.",
                    "synopsis": "**csound** -U **pvlook** [flags] infilename\n**pvlook** [flags] infilename",
                    "opcodeName": "csound",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Scale the amplitude of a sound file.",
                    "synopsis": "**scale** [OPTIONS ... ] infile",
                    "opcodeName": "scale",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts SDIF files to files usable by adsyn.",
                    "synopsis": "**sdif2ad** [flags] infilename outfilename",
                    "opcodeName": "sdif2ad",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Displays information about a soundfile.",
                    "synopsis": "**csound -U sndinfo** [options] soundfilenames ...\n**sndinfo** [options] soundfilenames ...",
                    "opcodeName": "csound -U sndinfo",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Converts the sample rate of an audio file.",
                    "synopsis": "**src_conv** [flags] infile",
                    "opcodeName": "src_conv",
                    "functionalSynopsis": ""
                },
                {
                    "description": "Deprecated.",
                    "synopsis": "",
                    "opcodeName": "",
                    "functionalSynopsis": ""
                }
            ]
        }
    ]
}